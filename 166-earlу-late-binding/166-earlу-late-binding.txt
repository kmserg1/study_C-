Урок No 166. Раннее и Позднее Связывания

Как мы уже знаем из предыдущих уроков, выполнение программы в языке C++ происходит последовательно, строка за строкой,
начиная с функции main(). Когда компилятор встречает вызов функции, то точка выполнения переходит к началу кода
вызываемой функции. Откуда компилятор знает, что это нужно сделать?
При компиляции программы компилятор конвертирует каждый стейтмент программы в одну или несколько строк машинного
кода. Каждой строке машинного кода присваивается собственный уникальный адрес. Так же и с функциями: когда компилятор
встречает функцию, она конвертируется в машинный код и получает свой адрес.
Связывание — это процесс, который используется для конвертации идентификаторов (таких как имена переменных или
функций) в адреса. Хотя связывание используется как для переменных, так и для функций, на этом уроке мы сосредоточимся
только на функциях.

Оглавление:
1. Раннее связывание
2. Позднее связывание


Раннее связывание

Большинство вызовов функций, которые встречает компилятор, являются прямыми вызовами функций. Прямой вызов
функции — это стейтмент, который напрямую вызывает функцию. Например:

1 #include <iostream>
2
3 void printValue(int value)
4 {
5 	std::cout << value;
6 }
7
8 int main()
9 {
10 	printValue(7); // это прямой вызов функции
11 	return 0;
12 }

Прямые вызовы функций выполняются с помощью раннего связывания. Раннее связывание (или «статическая привязка»)
означает, что компилятор (или линкер) может напрямую связать имя идентификатора (например, имя функции или
переменной) с машинным адресом. Помните, что все функции имеют свой уникальный адрес. Поэтому, когда компилятор (или
линкер) встречает вызов функции, он заменяет его инструкцией машинного кода, которая сообщает процессору перейти к
адресу функции.

Рассмотрим простую программу-калькулятор, в которой используется раннее связывание:

1 #include <iostream>
2
3 int add(int a, int b)
4 {
5 	return a + b;
6 }
7
8 int subtract(int a, int b)
9  {
10 	return a - b;
11 }
12
13 int multiply(int a, int b)
14 {
15 	return a * b;
16 }
17
18 int main()
19 {
20 	int a;
21 	std::cout << "Enter a number: ";
22 	std::cin >> a;
23
24 	int b;
25 	std::cout << "Enter another number: ";
26 	std::cin >> b;
27
28 	int op;
29 	do
30 	{
31 		std::cout << "Enter an operation (0 = add, 1 = subtract, 2 = multiply): ";
32 		std::cin >> op;
33 	} while (op < 0 || op > 2);
34
35 	int result = 0;
36 	switch (op)
37 	{
38 		// Вызываем конкретную функцию напрямую. Используется раннее связывание
39 		case 0: result = add(a, b); break;
40 		case 1: result = subtract(a, b); break;
41 		case 2: result = multiply(a, b); break;
42 	}
43
44 	std::cout << "The answer is: " << result << std::endl;
45
46 	return 0;
47 }

Поскольку add(a, b) , subtract(a, b) и multiply(a, b) являются прямыми вызовами функций, то компилятор будет
использовать раннее связывание. Он заменит вызов add(a, b) инструкцией, которая сообщит процессору перейти к адресу
add(). То же самое выполнится и для subtract(a, b) и для multiply(a, b).


Позднее связывание

В некоторых программах невозможно знать наперёд, какая функция будет вызываться первой. В таком случае используется
позднее связывание (или «динамическая привязка»). В языке C++ для выполнения позднего связывания используются
указатели на функции. Вкратце, указатель на функцию — это тип указателя, который указывает на функцию вместо
переменной. Функция, на которую указывает указатель, может быть вызвана через указатель и оператор вызова функции.

Например, вызовем функцию add():

1 #include <iostream>
2
3 int add(int a, int b)
4 {
5 	return a + b;
6 }
7
8 int main()
9 {
10 // Создаем указатель на функцию add
11 int (*pFcn)(int, int) = add;
12 std::cout << pFcn(4, 5) << std::endl; // вызов add(4 + 5)
13
14 return 0;
15 }

Вызов функции через указатель на функцию также известен как непрямой (или «косвенный») вызов функции. Следующая
программа-калькулятор идентична вышеприведенной программе, за исключением того, что вместо прямых вызовов функций
используется указатель на функцию:

1 #include <iostream>
2
3 int add(int a, int b)
4 {
5 return a + b;
6 }
7
8 int subtract(int a, int b)
9 {
10 return a - b;
11 }
12
13 int multiply(int a, int b)
14 {
15 return a * b;
16 }
17
18 int main()
19 {
20 	int a;
21 	std::cout << "Enter a number: ";
22 	std::cin >> a;
23
24 	int b;
25 	std::cout << "Enter another number: ";
26 	std::cin >> b;
27
28 	int op;
29 	do
30 	{
31 		std::cout << "Enter an operation (0 = add, 1 = subtract, 2 = multiply): ";
32 		std::cin >> op;
33 	} while (op < 0 || op > 2);
34
35 	// Создаем указатель на функцию с именем pFcn (согласен, синтаксис ужасен)
36 	int (*pFcn)(int, int) = nullptr;
37
38 	// Указываем pFcn указывать на функцию, которую выберет пользователь
39 	switch (op)
40 	{
41 		case 0: pFcn = add; break;
42 		case 1: pFcn = subtract; break;
43 		case 2: pFcn = multiply; break;
44 	}
45
46 	// Вызываем функцию, на которую указывает pFcn с параметрами a и b.
47 	// Используется позднее связывание
48 	std::cout << "The answer is: " << pFcn(a, b) << std::endl;
49
50 	return 0;
51 }

Здесь мы указываем pFcn указывать на функцию, которую выберет пользователь. Затем мы вызываем через указатель
функцию, которую выбрал пользователь. Компилятор не может использовать раннее связывание для выполнения вызова
функции pFcn(a, b), так как он не может наперёд определить, на какую функцию pFcn будет указывать!

Позднее связывание менее эффективное, так как присутствует «посредник» между процессором и функцией. С ранним
связыванием процессор может перейти непосредственно к адресу функции. С поздним связыванием процессор должен
прочитать адрес, хранящийся в указателе, и только затем перейти к этому адресу. Этот дополнительный шаг и замедляет весь
процесс. Однако преимущество позднего связывания заключается в том, что оно более гибкое, нежели раннее связывание, так
как не нужно решать, какую функцию следует вызывать до, собственно, запуска самой программы.

На следующем уроке мы рассмотрим, как позднее связывание используется для реализации виртуальных функций.
