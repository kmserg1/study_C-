Урок No 123. Классы и const


На уроке No37 мы узнали, что фундаментальные типы данных (int, double,char ит.д.) можно сделать константными, используя
ключевое слово const, и что все константные переменные должныбыть инициализированы во время объявления. В случае с
константными фундаментальными типами данных инициализация может быть копирующей, прямой или uniform:

1 const int value1 = 6; // копирующая инициализация
2 const int value2(8); // прямая инициализация
3 const int value3 { 11 }; // uniform-инициализация (C++11)

Оглавление:
1. Константные объекты классов
2. Константные методы классов
3. Константные ссылкии классы
4. Перегрузка константных и неконстантных функций
5. Заключение


Константные объекты классов

Объекты классов можно сделать константными (используя ключевое слово const). Инициализация выполняется через
конструкторы классов:

1 const Date date1; // инициализация через конструктор по умолчанию
2 const Date date2(12, 11, 2018); // инициализация через конструктор с параметрами
3 const Date date3 { 12, 11, 2018 }; // инициализация через конструктор с параметрами в C++11

Как только константный объект класса инициализируется через конструктор, то любая попытка изменить переменные-члены
объекта запрещена, так как это нарушаетп ринципы константности объекта. Запрещается как изменение переменных-членов
напрямую (если они являются public), так и вызов методов (сеттеров), с помощью которых можно установить значения
переменным-членам. Рассмотрим следующий класс:

1 class Anything
2 {
3 public:
4 	int m_value;
5
6 	Anything(): m_value(0) { }
7
8 	void setValue(int value) { m_value = value; }
9 	int getValue() { return m_value ; }
10 };
11
12 int main()
13 {
14 	const Anything anything; // вызываем конструктор по умолчанию
15
16 	anything.m_value = 7; // ошибка компиляции: нарушение const
17 	anything.setValue(7); // ошибка компиляции: нарушение const
18
19 	return 0;
20 }

Строки No 16-17 вызовут ошибки компиляции, так как они нарушают принципы константности объекта, пытаясь напрямую
изменить переменную-член и вызывая сеттер для изменения значения переменной-члена.


Константные методы классов

Теперь рассмотрим следующую строку кода:

1 std::cout << anything.getValue();

Удивительно, но это также вызовет ошибку компиляции, хотяметод getValue() не делает ничего для изменения переменной-
члена! Оказывается, константные объекты класса могут явно вызывать только константные методы класса, а getValue() не
указан, как константный метод. Константный метод — это метод, который гарантирует, что не будет изменять объект или
вызывать неконстантные методы класса (поскольку они могут изменить объект).
Чтобы сделать getValue() константным, нужно просто добавить ключевое слово const к прототипу функции после списка
параметров, но перед телом функции:

1 class Anything
2 {
3 public:
4 int m_value;
5
6 Anything() { m_value= 0; }
7
8 void resetValue() { m_value = 0; }
9 void setValue(int value) { m_value = value; }
10
11 int getValue() const { return m_value; } // ключевое слово const находится после списка параметров, но перед телом функции
12 };

Теперь getValue() является константным методом. Это означает, что мы можем вызывать его через любой константный объект.
Для методов, определенных вне тела класса, ключевое слово const должно использоваться как в прототипе функции (в теле
класса), так и в определении функции:

1 class Anything
2 {
3 public:
4 int m_value;
5
6 Anything() { m_value= 0; }
7
8 void resetValue() { m_value = 0; }
9 void setValue(int value) { m_value = value; }
10
11 int getValue() const; // обратите внимание на ключевое слово const здесь
12 };
13
14 int Anything::getValue() const // и здесь
15 {
16 return m_value;
17 }

Кроме того, любой константный метод, который пытается изменить переменную-член или вызвать неконстантный метод
класса, также приведет к ошибке компиляции, например:

1 class Anything
2 {
3 public:
4 int m_value ;
5
6 void resetValue() const { m_value = 0; } // ошибка компиляции, константные методы не могут изменять переменные-члены класса
7 };

В этом примере метод resetValue() был установлен константным, но он пытается изменить значение m_value . Это вызовет
ошибку компиляции.

Обратите внимание, конструкторы не могут быть константными. Это связано с тем, что они должны иметь возможность
инициализировать переменные-члены класса, а константный конструктор этого не может сделать. Следовательно, в языке С++
константные конструкторы запрещены.

Стоит отметить, что константный объект класса может вызывать конструктор, который будет инициализировать все или
некоторые переменные-члены, или же не будет их инициализировать вообще!

Правило: Делайте все ваши методы, которые не изменяют данные объекта класса, константными.


Константные ссылки и классы

Еще одним способом создания константных объектов является передача объектов в функцию по константной ссылке.
На уроке No 98 мы рассмотрели преимущества передачи аргументов по константной ссылке, нежели по значению. Если
вкратце,то передача аргументов по значению создает копию значения (что является медленным процессом). Большую часть
времени нам не нужна копия, а ссылка уже указывает на исходный аргумент и является более эффективной, так как избегает
создания и использования ненужной копии. Мы обычно делаем ссылку константной для гарантии того,что функция не
изменит значение аргумента и сможет работать с r-values (например, с литералами).

Можете ли вы определить, что не так со следующим кодом?

1 #include <iostream>
2
3 class Date
4 {
5 private:
6 	int m_day;
7 	int m_month;
8 	int m_year;
9
10 public:
11 	Date(int day, int month, int year)
12 	{
13 		setDate(day, month, year);
14 	}
15
16 	void setDate(int day, int month, int year)
17 	{
18 		m_day = day;
19 		m_month = month;
20 		m_year = year;
21 	}
22
23 int getDay() { return m_day; }
24 int getMonth() { return m_month; }
25 int getYear() { return m_year; }
26 };
27
28 // Примечание: Мы передаем объект date по константной ссылке, дабы избежать создания копии объекта date
29 void printDate(const Date &date)
30 {
31 	std::cout << date.getDay() << "." << date.getMonth() << "." << date.getYear() << '\n';
32 }
33
34 int main()
35 {
36 	Date date(12, 11, 2018);
37 	printDate(date);
38
39 	return 0;
40 }


Ответ заключается в том, что внутри функции printDate(), объект date рассматриваетсякак константный. И через этот
константный date мы вызываем методы getDay(), getMonth() и getYear(), которые являются неконстантными. Поскольку мы не
можем вызывать неконстантные методы через константные объекты, то здесь мы получим ошибку компиляции.
Решение простое — сделать getDay(), getMonth() и getYear() константными:

1 class Date
2 {
3 private:
4 	int m_day;
5 	int m_month;
6 	int m_year;
7
8 public:
9 	Date(int day, int month, int year)
10 	{
11 		setDate(day, month, year);
12 	}
13
14 	// Метод setDate() не может быть const, так как изменяет значения переменных-членов
15 	void setDate(int day, int month, int year)
16 	{
17 		m_day = day;
18 		m_month = month;
19 		m_year = year;
20 	}
21
22 	// Все следующие геттеры могут быть const
23 	int getDay() const { return m_day; }
24 	int getMonth() const { return m_month; }
25 	int getYear() const { return m_year; }
26 };

Теперь в функции printDate() константный date сможет вызывать getDay(), getMonth() и getYear().


Перегрузка константных и неконстантных функций

Хотя это делается не очень часто, но функцию можно перегрузить таким образом, чтобы иметь константную и неконстантную
версии одной и той же функции

1 #include <string>
2
3 class Anything
4 {
5 private:
6 	std::string m_value;
7
8 public:
9 	Anything(const std::string &value="") { m_value= value; }
10
11 	const std::string& getValue() const { return m_value; } // getValue() для константных объектов
12 	std::string& getValue() { return m_value; } // getValue() для неконстантных объектов
13 };

Константная версия функции будет вызываться для константных объектов, а неконстантная версия будет вызываться для
неконстантных объектов:

1 int main()
2 {
3  Anything anything;
4  anything.getValue() = "Hello!"; // вызывается неконстантный getValue()
5 
6 const Anything anything2;
7 anything2.getValue(); // вызывается константный getValue()
8
9 return 0;
10 }

Перегрузка метода и разделение его на константную и неконстантную версии обычно выполняется, когда возвращаемое
значение должно отличаться по константности (когда требуется константа, икогда она не требуется). В примере, приведенном
выше, неконстантная версия getValue() будет работать только с неконстантными объектами, но эта версия более гибкая, так
как мы можем использовать её как для чтения, так и для записи m_value (что мы, собственно, и делаем, присваивая строку
Hello! ).

Но, когда мы не изменяем данные объекта класса, тогда вызывается константная версия getValue().

Заключение

Любой метод, который не изменяет данные объекта класса, должен быть const!