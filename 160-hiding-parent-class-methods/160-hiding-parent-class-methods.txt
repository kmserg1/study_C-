Урок No 160. Сокрытие методов родительского класса


Язык C++ предоставляет возможность изменить спецификатор доступа родительского члена в дочернем классе. Это делается с
помощью «using-объявления». Например, рассмотрим следующий класс Parent:

1 #include <iostream>
2
3 class Parent
4 {
5 private:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		: m_value(value)
11 	{
12 	}
13
14 protected:
15 	void printValue() { std::cout << m_value; }
16 };

Поскольку Parent::printValue() объявлен как protected, то он доступен только другим членам Parent и своим дочерним классам.
Для других объектов доступ к нему закрыт.
Определим класс Child, который изменяет спецификатор доступа printValue() с protected на public:

1 class Child: public Parent
2 {
3 public:
4 	Child(int value)
5 		: Parent(value)
6 	{
7 	}
8
9 	// Parent::printValue является protected, поэтому доступ к нему не является открытым для всех объектов.
10 	// Но мы можем это исправить с помощью "using-объявления"
11 	using Parent::printValue; // обратите внимание, нет никаких скобок
12 };

Это означает, что следующий код выполнится без ошибок:
1 int main()
2 {
3 	Child child(9);
4
5 	// Метод printValue() является public в классе Child, поэтому всё хорошо
6 	child.printValue(); // выведется 9
7 	return 0;
8 }

Здесь есть два примечания:

 Во-первых, вы можете изменить спецификаторы доступа только для тех членов родительского класса, к которым есть
доступ у дочернего класса. Вы не сможете изменить спецификатор доступа члена родительского класса с private на protected
или public, поскольку дочерний класс не имеет доступа к private-членам родительского класса.

 Во-вторых, начиная с C++11 использование «using-объявления» является предпочтительным способом изменения
спецификаторов доступа. Однако вы также можете использовать «access-объявление». Это работает идентично «using-
объявлению», только без ключевого слова using. Сейчас этот способ считается устаревшим, но, проглядывая более старый
код, вы можете увидеть «access-объявления», поэтому об этом стоит знать.


Сокрытие родительских методов в дочернем классе

В языке C++ невозможно удалить или ограничить функционал родительского класса, кроме как с помощью непосредственного
изменения исходного кода. Однако в дочернем классе вы можете скрыть функционал, существующий в родительском классе,
так чтобы к нему нельзя было получить доступ через объекты дочернего класса. Это делается путем изменения
соответствующих спецификаторов доступа.

Например, вы можете сделать открытый член родительского класса закрытым:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	int m_value;
7 };
8
9 class Child : public Parent
10 {
11 private:
12 	using Parent::m_value;
13
14 public:
15 	Child(int value)
16 	// Мы не можем инициализировать m_value, поскольку это член класса Parent (Parent должен инициализировать m_value)
17      {
18 		// Но мы можем присвоить значение
19 		m_value = value;
20 	}
21 };
22
23 int main()
24 {
25 	Child child(9);
26
27 	// Следующее не сработает, поскольку m_value был переопределен как private
28 	std::cout << child.m_value;
29
30 	return 0;
31 }

Это позволяет инкапсулировать данные родительского класса в дочернем классе. В качестве альтернативы можно
использовать наследование типа private, что приведет к тому, что все наследуемые public- и protected-члены класса Parent
станут private в классе Child.

Вы также можете закрыть родительские методы в дочернем классе, используя ключевое слово delete:

1 #include <iostream>
2
3 class Parent
4 {
5 private:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		: m_value(value)
11 	{
12 	}
13
14 	int getValue() { return m_value; }
15 };
16
17 class Child : public Parent
18 {
19 public:
20 	Child(int value)
21 		: Parent(value)
22 	{
23 	}
24
25
26 	int getValue() = delete; // делаем этот метод недоступным
27 };
28
29 int main()
30 {
31 	Child child(9);
32
33 	// Следующее не сработает, поскольку getValue() удален
34 	std::cout << child.getValue();
35
36 	return 0;
37 }

Таким образом, компилятор будет жаловаться, если мы попытаемся вызвать метод getValue() через объект класса Child. Однако
через объект родительского класса всё будет работать, так как мы «удалили» getValue() только в дочернем классе.
