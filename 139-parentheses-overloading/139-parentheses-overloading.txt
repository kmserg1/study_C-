Урок No 139. Перегрузка оператора ()


На этом уроке м ырассмотрим перегрузку оператора () в языке С++.

Оглавление:
1. Перегрузка оператора ()
2. Функторы в C++
3. Заключение
4. Тест


Перегрузка оператора()

Все операторы, перегрузку которых мы рассматривали до сих пор, позволяли нам самостоятельно определять тип
параметров в функции перегрузки оператора, но не их количество. Например, оператор == всегда принимает два
параметра, тогда как оператор ! всегда принимает один параметр. Оператор () является особенно интересным,
посколькуп озволяет изменять как тип параметров, так и их количество.

Но следует помнить о двух вещах:

 Во-первых, перегрузка круглых скобок должна осуществляться через метод класса.

 Во-вторых,в необъектно-ориентированном C++ оператор () является оператором вызова функции. В случае с
  классами перегрузка круглых скобок выполняется в методе operator()(){} (в объявлени ифункции перегрузки
  находятся две пары круглых скобок).

Рассмотрим следующий класс:

1 class Matrix
2 {
3 private:
4 	double data[5][5];
5 public:
6 	Matrix()
7 	{
8 		// Присваиваем всем элементам массива значение 0.0
9 		for(int row=0; row < 5; ++row)
10 			for (int col=0; col< 5; ++col)
11 				data[row][col] = 0.0;
12 	}
13 };

Матрицы являются ключевой концепцией в линейной алгебре и часто используются в геометрическом моделировании и в
3D-графике. Всё,что вам нужно знать сейчас — это то, что класс Matrix является двумерным массивом (5×5 типа double).

На уроке о перегрузке оператора индексации мы использовали оператор [] для прямого доступа к элементам
закрытого одномерного массива. Здесь же нам нужен доступ к элементам двумерного массива. Поскольку оператор []
ограничен лишь одним параметром, то его функциональности недостаточно для доступа к двумерному массиву.
Однако, поскольку оператор() может принимать разное количество параметров, мы можем объявить версию operator(),
которая будет принимать два целочисленных параметра (два индекса), и использовать эти индексы для доступа к
элементам нашего двумерного массива. Например:

1 #include <iostream>
2 #include <cassert> //для assert()
3
4 class Matrix
5 {
6 private:
7 	double data[5][5];
8 public:
9 	Matrix()
10 	{
11 		// Присваиваем всем элементам массива значение 0.0
12 		for(introw=0; row < 5; ++row)
13 			for (int col=0; col< 5;++col)
14 				data[row][col] = 0.0;
15 	}
16
17 	double& operator()(int row,int col);
18 	const double& operator()(int row, int col) const; //для константных объектов
19 };
20
21 double& Matrix::operator()(int row, int col)
22 {
23 	assert(col >= 0 && col< 5);
24 	assert(row >= 0 && row< 5);
25
26 	return data[row][col];
27 }
28
29 const double& Matrix::operator()(int row, int col) const
30 {
31 	assert(col >= 0 && col< 5);
32 	assert(row >= 0 && row< 5);
33
34 	return data[row][col];
35 }
36
37 int main()
38 {
39 	Matrix matrix;
40 	matrix(2, 3) = 3.6;
41 	std::cout << matrix(2,3);
42
43 	return 0;
44 }

Результат выполненияп рограммы:
3.6

Выполним перегрузку оператора () еще раз, но уже без использования каких-либо параметров:

1 #include <iostream>
2 #include <cassert> //для assert()
3
4 class Matrix
5 {
6 private:
7 	double data[5][5];
8 public:
9 	Matrix()
10 	{
11 		// Присваиваем всем элементам массива значение 0.0
12 		for(introw=0; row < 5; ++row)
13 			for (int col=0; col< 5;++col)
14 				data[row][col] = 0.0;
15 	}
16
17 	double& operator()(int row, int col);
18 	const double& operator()(int row, int col) const;
19 	void operator()();                    
20 };
21
22 double& Matrix::operator()(int row, int col)
23 {
24 	assert(col >= 0 && col< 5);
25 	assert(row >= 0 && row< 5);
26
27 	return data[row][col];
28 }
29
30 const double& Matrix::operator()(introw,int col) const
31 {
32 	assert(col >= 0 && col< 5);
33 	assert(row >= 0 && row< 5);
34
35 	return data[row][col];
36 }
37
38 void Matrix::operator()()
39 {
40 	// Сбрасываем значения всех элементов массива на 0.0
41 	for (int row=0; row < 5; ++row)
42 		for(intcol=0; col < 5; ++col)
43 			data[row][col]= 0.0;
44 }
45
46 int main()
47 {
48 	Matrix matrix;
49 	matrix(2, 3)= 3.6;
50 	matrix(); //выполняемсброс
51 	std::cout <<matrix(2,3);
52
53 	return 0;
54 }

Результат выполнения программы:
0

Поскольку оператор () является очень гибким, то может возникнуть соблазн использовать его для самых разных целей.
Однако это настоятельно не рекомендуется делать, поскольку оператор () не является очень информативным и зачастую
может быть не понятно, что он делает. В примере, приведенном выше, функцию очистки массива лучше было бы записать
в виде метода clear() или erase(), поскольку matrix.erase() выглядит намного информативнее, нежели matrix().


Функторы в C++

Перегрузка оператора () используется в реализации функторов (или «функциональных объектов») — классы, которые
работают как функции. Преимущество функтора над обычной функцией заключается в том,что функторы могут хранить
данные в переменных-членах (поскольку они самиявляются классами). Вот пример использования простого функтора:

1 #include <iostream>
2
3 class Accumulator
4 {
5 private:
6 	int m_counter = 0;
7
8 public:
9 Accumulator()
10 {
11 }
12
13 int operator() (int i){ return (m_counter+= i); }
14 };
15
16 int main()
17 {
18 	Accumulator accum;
19 	std::cout <<accum(30)<< std::endl; // выведется 30
20 	std::cout <<accum(40)<< std::endl; // выведется 70
21
22 	return 0;
23 }

Обратитевнимание, использованиеклассаAccumulatorвыглядиттакже,каки вызовобычной функции, нонашобъект
классаAccumulatorможет хранить значение,котороеувеличивается.
Выможете спросить: «Зачемиспользовать класс, есливсёможнореализовать ичерезобычнуюфункцию состатической
локальнойпеременной?».Можносделать ичерезstatic,но,посколькуфункции представленытолькооднимглобальным
экземпляром(т.е.нельзясоздать несколькообъектов функции), использовать этуфункциюмыможемтолько для
выполнения чего-тоодногоза раз.С помощьюфункторовмыможемсоздать любоеколичество отдельных
функциональных объектов,которыенамнужны,и использоватьих одновременно.
Заключение
Перегрузка оператора () сдвумя параметрамииспользуетсядля получения доступак двумерныммассивам илидля
возвратаподмножестводномерного массива (двапараметра будутконкретизировать условия отбора элементов
подмножества).Всё остальноелучшереализовать через отдельныеметоды с болееинформативныминазваниями, нежели
черезперегрузку оператора () .
Перегрузка оператора () такжечастоиспользуетсяпри создании функторов.Хотя функторы,которые мыиспользовали
выше, являются довольнопростыми ипонятными,но обычноони используются в болеепродвинутых/сложныхтемах
программирования изаслуживаютотдельного урока.
Тест
Напишитекласс,переменной-членом которогоявляется строка. Перегрузитеоператор ()для возвратаподстроки,
котораяначинаетсясиндекса, указанногов значении первого параметра.Второй параметрдолженуказыватьтребуемую
длину подстроки.
Подсказки:

 Выможете использоватьиндексмассива [] длядоступа котдельнымсимволам строки.

 Выможете использоватьоператор += для добавлениячего-либо к строке.
Следующийфрагмент кода:
1 int main()
2 {
3
 Mystringstring("Hello,world!");
4
 std::cout << string(7, 6); // начинаемс 7-го символа(индекса)и возвращаем следующие 6символов
5
6
 return 0;
7 }
Долженвыдаватьследующий результат:
world!
Ответ