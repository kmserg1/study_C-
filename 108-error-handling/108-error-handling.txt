Урок No 108. Обработка ошибок, cerr и exit()

При написании программ возникновение ошибок почти неизбежно. Ошибки в языке C++ делятся на две категории:
синтаксическиеи семантические.

Оглавление:
1. Синтаксические ошибки
2. Семантические ошибки
3. Определение ложных предположений
4. Обработка ложных предположений

Синтаксические ошибки

Синтаксическая ошибка возникает при нарушении правил грамматики языка C++. Например:
если 7 не равно 8, то пишем "not equal";

Хотя этот стейтмент нам (людям) понятен, компьютер не сможет его корректно обработать. В соответствии с правилами
грамматики языка C++, корректно будет:

1 if (7 != 8)
2 std::cout << "not equal";

Синтаксические ошибки почти всегда улавливаются компилятороми их обычно легко исправить. Следовательно, о них
слишком беспокоиться не стоит.


Семантические ошибки

Семантическая (или «смысловая») ошибка возникает, когда код синтаксически правильный, но выполняет не то, что нужно
программисту. Например

1 for (int count=0; count <= 4; ++count)
2 std::cout << count << " ";

Возможно, программист хотел, чтобы вывелось 0 1 2 3, но на самом деле выведется 0 1 2 3 4 .
Семантические ошибки не улавливаются компилятороми могут иметь разное влияние: некоторые могут вообще не
отображаться, что приведет к неверным результатам, к повреждению данных или вообще к сбою программы. Поэтому
о семантических ошибках беспокоиться уже придется.
Они могут возникать несколькими способами. Одной из наиболее распространенных семантических ошибок является
логическая ошибка. Логическая ошибка возникает, когда программист неправильно программирует логику выполнения
кода. Например, вышеприведенный фрагмент кода имеет логическую ошибку. Вот еще один пример:

1 if (x >= 4)
2 std::cout << "x is greater than 4";

Что произойдет, если x будет равен 4 ? Условие выполнится как true , а программа выведет x is greater than 4.
Логические ошибки иногда бывает довольно-таки трудно обнаружить.

Другой распространенной семантической ошибкой является ложное предположение. Ложное предположение возникает,
когда программист предполагает, что что-то будет истинным или ложным, а оказывается наоборот. Например:

1 std::string hello = "Hello, world!";
2 std::cout << "Enter an index: ";
3
4 int index;
5 std::cin >> index;
6
7 std::cout << "Letter #" << index << " is " << hello[index] << std::endl;

Заметили потенциальную проблему здесь? Предполагается, что пользователь введет значение между 0 и длиной строки
Hello, world!. Если же пользователь введет отрицательное число или число, которое больше длины указанной строки, то
index окажетсяза пределами диапазона массива. В этом случае, посколькумы просто выводим значение по индексу,
результатом будет вывод мусора (при условии, что пользователь введет число вне диапазона). Но в других случаях ложное
предположение может привести и к изменениям значений переменных, и к сбою в программе.

Безопасное программирование — это методика разработки программ, которая включает анализ областей, где могут быть
допущены ложные предположения, и написание кода, который обнаруживает и обрабатывает любой случай такого
нарушения, чтобы свести к минимуму риск возникновения сбоя или повреждения программы.


Определение ложных предположений

Оказывается, мы можем найти почти все предположения, которые необходимо проверить в одном из следующих трех мест:
  При вызове функции, когда caller может передать некорректные или семантически бессмысленные аргументы.
  При возврате значения функцией, когда возвращаемое значение может быть индикатором выполнения (произошла ли
ошибкаили нет).
  При обработке данных ввода (либо от пользователя, либо из файла), когда эти данные могут быть не того типа, что
нужно.

Поэтому, придерживаясь безопасного программирования, нужно следовать следующим 3-м правилам:

  В верхней части каждой функции убедитесь, что все параметры имеют соответствующие значения.
  После возврата функцией значения, проверьте возвращаемое значение (если оно есть) и любые другие механизмы
сообщения обошибках на предмет того, произошла ли ошибка.                                            
  Проверяйте данные ввода на соответствие ожидаемому типу данных и его диапазону.

Рассмотрим примеры проблем:

Проблема No 1: При вызове функции caller может передать некорректные или семантически бессмысленные
аргументы:

1 void printString(const char *cstring)
2 {
3 std::cout << cstring;
4 }

Можетели вы определить потенциальную проблему здесь? Дело в том, что caller может передать нулевой указатель вместо
допустимой строки C-style. Если это произойдет, то в программе будет сбой. Вот как правильно (с проверкой параметра
функции на то, не является ли он нулевым):

1 void printString(const char *cstring)
2 {
3 // Выводим cstring при условии, что он не нулевой
4 if (cstring)
5 std::cout << cstring;
6 }

Проблема No 2: Возвращаемое значение может указывать на возникшую ошибку:

1 #include <iostream>
2 #include <string>
3
4 int main()
5 {
6 std::string hello = "Hello, world!";
7
 std::cout << "Enter a letter: ";
8
9 char ch;
10 std::cin >> ch;
11
12 int index = hello.find(ch);
13 std::cout << ch << " was found at index " << index << '\n';
14
15 return 0;
16 }

Можете ли вы определить потенциальную проблему здесь? Пользователь может ввести символ, который не находится в строке
hello . Если это произойдет, то функция find() возвратит индекс -1 , который и выведется. Правильно:

1 #include <iostream>
2 #include <string>
3
4 int main()
5 {
6 std::string hello = "Hello, world!";
7 std::cout << "Enter a letter: ";
8
9 char ch;
10 std::cin >> ch;
11
12 int index = hello.find(ch);
13 if (index != -1) // обрабатываем случай, когда функция find() не нашла символ в строке hello
14 	std::cout << ch << " was found at index " << index << '\n';
15 else
16 	std::cout << ch << " wasn't found" << '\n';
17
18 return 0;
19 }

Проблема No 3: При обработке данных ввода (либо от пользователя, либо из файла), эти данные могут быть не того
типа и диапазона, что нужно. Разберем программу из предыдущего примера, код которой позволяет проиллюстрировать
ситуацию с обработкой ввода:

1 #include <iostream>
2 #include <string>
3
4 int main()
5 {
6 std::string hello = "Hello, world!";
7 std::cout << "Enter an index: ";
8
9 int index;
10 std::cin >> index;
11
12 std::cout << "Letter #" << index << " is " << hello [index] << std::endl;
13
14 return 0;
15 }

Вот как правильно (с проверкой пользовательского ввода):

1 #include <iostream>
2 #include <string>
3
4 int main()
5 {
6 std::string hello = "Hello, world!";
7 int index;
8
9 do
10 {
11 	std::cout << "Enter an index: ";
12 	std::cin >> index;
13
14 	// Обрабатываем случай, когда пользователь ввел нецелочисленное значение
15 	if (std::cin.fail())
16 	{
17 		std::cin.clear();
18 		std::cin.ignore(32767, '\n');
19 		index = -1; // убеждаемся, что index имеет недопустимое значение, чтобы цикл продолжался
20		continue; // этот continue может показаться здесь лишним, но он явно указывает на готовность прекратить выполнение
21 	}
22
23 } while (index < 0 || index >= hello.size()); // обрабатываем случай, когда пользователь ввел значение вне диапазона
24
25 std::cout << "Letter #" << index << " is " << hello [index] << std::endl;
26
27 return 0;
28 }

Обратите внимание, здесь проверка двухуровневая:
 Во-первых, мыдолжны убедиться,чтопользователь введет значениетоготипа данных,которыймы используем.
 Во-вторых, это значение должно находитьсявдиапазоне массива.


Обработка ложных предположений

Теперь, когда вы знаете, где обычно возникают ложные предположения, давайте поговорим о способах, позволяющ их
избежатьих. Одного универсального способа исправления всех ошибок нет, всё зависит от характера проблемы.
Но все же есть несколько способов обработки ложных предположений:

Способ No 1: Пропустите код, который зависит напрямую от правильности предположения:

1 void printString(const char *cstring)
2 {
3  // Выводим cstring только при условии, что он не нулевой
4  if (cstring)
5  std::cout << cstring;
6 }

В примере, приведенном выше, если cstring окажется NULL , то мы ничего не будем выводить. Мы пропустили тот код,
который напрямую зависит от значения cstring и который с ним работает (вкоде мы простовыводим этот cstring). Это
может быть хорошим вариантом, если пропущенный стейтмент не является критическим и не влияет на логику программы.
Основной недостаток при этом заключается в том, что caller или пользователь не имеет возможности определить, что что-то
пошло не так.

Способ No 2: Из функции возвращайте код ошибки обратно в caller и позволяйте caller-у обработать эту ошибку:

1 int getArrayValue(const std::array &array, int index)
2 {
3 // Используем условие if для обнаружения ложного предположения
4 if (index < 0 || index >= array.size())
5 return -1; // возвращаем код ошибки обратно в caller
6
7 return array[index];
8 }

Здесь функция возвратит -1, если caller передаст некорректный index . Возврат перечислителя в качествекода ошибки
будет ещелучшим вариантом.

Способ No 3: Если нужно немедленно завершить программу, то используйте функцию exit(), которая находится в
заголовочном файле cstdlib, для возврата кода ошибки обратно в операционную систему:
1 #include <cstdlib> // для exit()
2
3 int getArrayValue(const std::array &array, int index)
4 {
5 // Используем условие if для обнаружения ложного предположения
6 if (index < 0 || index >= array.size())
7 exit(2); // завершаем программу и возвращаем код ошибки (2) обратно в операционную систему
8
9 return array[index];
10 }

Если caller передаст некорректный index, то программа немедленно завершит свое выполнение и передаст код ошибки 2
обратно в операционную систему.


Способ No 4: Если пользователь ввел данные не того типа, что нужно — попросите пользователя ввести данные еще раз:

1 #include <iostream>
2 #include <string>
3
4 int main()
5 {
6 std::string hello = "Hello, world!";
7 int index;
8
9 do
10 {
11 	std::cout << "Enter an index: ";
12 	std::cin >> index;
13
14 	// Обрабатываем случай, когда пользователь ввел нецелочисленное значение
15 	if (std::cin.fail())
16 	{
17 		std::cin.clear();
18 		std::cin.ignore(32767, '\n');
19 		index = -1; // убеждаемся, что index имеет недопустимое значение, чтобы цикл продолжался
20 		continue; // этот continue может показаться здесь лишним, но он явно указывает на готовность прекратить выполнение
21 	}
22
23 } while (index < 0 || index >= hello.size()); // обрабатываем случай, когда пользователь ввел значение вне диапазона
24
25 std::cout << "Letter #" << index << " is " << hello [index] << std::endl;
26
27 return 0;
28 }


Способ No 5: Используйте cerr. 

cerr — это объект вывода (как и cout), который находится в заголовочном файле iostream и
выводит сообщения об ошибках в консоль (как и cout), но только эти сообщения можно ещеи перенаправитьв отдельный
файл с ошибками. Т.е. основное отличие cerr от cout заключается в том, что cerr целенаправленно используется для вывода
сообщений об ошибках, тогда как cout — для выводавсего остального. Например:

1 void printString(const char *cstring)
2 {
3 // Выводим cstring при условии, что он не нулевой
4 if (cstring)
5 	std::cout << cstring;
6 else
7 	std::cerr << "function printString() received a null parameter";
8 }

В примере, приведенном выше, мы не только пропускаем код, который напрямую зависит от правильности предположения, но
также регистрируем ошибку, чтобы пользователь мог позже определить, почему программа выполняетсяне так, как нужно.


Способ No 6: Если вы работаете в какой-то графической среде, то распространенной практикойявляется вывод
всплывающего окна с кодом ошибки, а затем немедленное завершение программы. То, как этосделать, зависит от
конкретной среды разработки.

