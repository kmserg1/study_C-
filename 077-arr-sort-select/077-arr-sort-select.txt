Урок No 77. Сортировка массивов методом выбора

Сортировка массива — это процесс распределения всех элементов массива в определенном порядке. Очень часто это
бывает полезным. Например, в вашемпочтовом ящике электронные письма отображаются в зависимости от времени
получения; новые письма считаются более релевантными, чем те, которые вы получили полчаса,ч ас, два или день назад;
когда вы переходите в свой список контактов, имена обычно находятся в алфавитном порядке, потому что так легче что-то
найти. Все эти случаи включают в себя сортировку данных перед их фактическим выводом.

Оглавление:
1. Как работает сортировка?
2. Сортировка массивов методом выбора
3. Сортировка массивов методомв ыбора в C++
4. Функцияstd::sort()
5. Тест
 

Как работает сортировка?

Сортировка данных может сделать поиск внутри массива более эффективным не только для людей, но и для компьютеров. 
Например, рассмотрим случай, когда нам нужно узнать, отображается ли определенное имя в списке имен. Чтобы это узнать, 
нужно проверить каждый элемент массива на соответствие нашему значению. Поиск в массиве с множеством элементов может 
оказаться слишком неэффективным (затратным).

Однако, предположим, что наш массив с именами отсортирован в алфавитном порядке. Тогда наш поиск начинается с первой 
буквы нашего значения и заканчивается буквой, которая идет следующей по алфавиту. В таком случае, если мы дошли до этой 
буквы и не нашли имя, то точно знаем, что оно не находится в остальной части массива, так как в алфавитном порядке 
нашу букву мы уже прошли!

Не секрет, что есть алгоритмы поиска внутри отсортированных массивов и получше. Применяя простой алгоритм, мы можем 
искать определенный элемент в отсортированном массиве, содержащем 1 000 000 элементов, используя всего лишь 20 сравнений! 
Недостатком, конечно же, является то, что сортировка массива с таким огромным количеством элементов — дело сравнительно 
затратное, и оно точно не выполняется ради одного поискового запроса.

В некоторых случаях сортировка массива делает поиск ненужным. Например, мы ищем наилучший результат прохождения теста 
среди студентов. Если массив не отсортирован, то нам придется просмотреть каждый элемент массива, чтобы найти наивысшую 
оценку. Если же массив отсортирован, то наивысшая оценка будет находиться либо на первой позиции, либо на последней (в 
зависимости от метода сортировки массива: в порядке возрастания или в порядке убывания), поэтому нам не нужно искать вообще!

Сортировка обычно выполняется путем повторного сравнения пар элементов массива и замены значений, если они отвечают 
заданным критериям. Порядок, в котором эти элементы сравниваются, зависит от того, какой алгоритм сортировки используется. 
Критерии определяют, как будет сортироваться массив (например, в порядке возрастания или в порядке убывания).

Чтобы поменять два элемента местами, мы можем использовать функцию std::swap() из Стандартной библиотеки C++, которая определена 
в заголовочном файле algorithm. В C++11 функция std::swap() была перенесена в заголовочный файл utility:

1 #include <iostream>
2 #include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>
3
4 int main()
5 {
6 	int a = 3;
7 	int b = 5;
8	std::cout<<"Before swap: a=" << a << ", b=" << b << '\n';
9 	std::swap(a,b); // меняем местами значения переменных a и b
10 	std::cout << "After swap: a= " << a << ", b= " << b <<'\n';
11 }

Результат выполнения программы:
Before swap: a= 3, b =5
After swap: a=5, b=3
После выполнения операции замены значения переменных a и b поменялись местами.

Моя реализация swap для int.

#include <iostream>

int swapInt(int* a, int* b){
	int c;
	c=*a;
	*a=*b;
	*b=c;
}

int main()
{
	int a = 3;
	int b = 5;
	std::cout<<"Before swap: a=" << a << ", b=" << b << '\n';
	swapInt(&a,&b); // меняем местами значения переменных a и b
 	std::cout << "After swap: a= " << a << ", b= " << b <<'\n';
}


Сортировка массивов методом выбора

Существует множество способов сортировки массивов. Сортировка массивов методом выбора, пожалуй, самая простая 
для понимания, хотя и одна из самых медленных.

Для сортировки массива методом выбора от наименьшего до наибольшего элемента выполняются следующие шаги:
-  Начиная с элемента под индексом 0, ищем в массиве наименьшее значение.
-  Найденное значение меняем местами с нулевым элементом.
-  Повторяем шаги №1 и №2 уже для следующего индекса в массиве (отсортированный элемент больше не трогаем).

Другими словами, мы ищем наименьший элемент в массиве и перемещаем его на первое место. Затем ищем второй 
наименьший элемент и перемещаем его уже на второе место после первого наименьшего элемента. Этот процесс продолжается 
до тех пор, пока в массиве не закончатся неотсортированные элементы.

Вот пример работы этого алгоритма в массиве с 5-ю элементами:

{ 30, 50, 20, 10, 40 }

Сначала ищем наименьший элемент, начиная с индекса 0:

{ 30, 50, 20, 10, 40 }

Затем меняем местами наименьший элемент с элементом под индексом 0:

{ 10, 50, 20, 30, 40 }

Теперь, когда первый элемент массива отсортирован, мы его игнорируем. Ищем следующий наименьший элемент, но уже начиная с индекса 1:

{ 10, 50, 20, 30, 40 }

И меняем его местами с элементом под индексом 1:

{ 10, 20, 50, 30, 40 }

Теперь мы игнорируем первые два элемента. Ищем следующий наименьший элемент, начиная с индекса 2:

{ 10, 20, 50, 30, 40 }

И меняем его местами с элементом под индексом 2:

{ 10, 20, 30, 50, 40 }

Ищем следующий наименьший элемент, начиная с индекса 3:

{ 10, 20, 30, 50, 40 }

И меняем его местами с элементом под индексом 3:

{ 10, 20, 30, 40, 50 }

Ищем следующий наименьший элемент, начиная с индекса 4:

{ 10, 20, 30, 40, 50 }

И меняем его местами с элементом под индексом 4 (выполняется самозамена, т.е. ничего не делаем):

{ 10, 20, 30, 40 50 }

Готово!

{ 10, 20, 30, 40, 50 }

Обратите внимание, последнее сравнение всегда будет одиночным (т.е. самозамена), что является лишней 
операцией, поэтому, фактически, мы можем остановить выполнение сортировки перед последним элементом 
массива.

Сортировка массивов методом выбора в C++

Вот как этот алгоритм реализован в C++:

#include <iostream> 
#include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>
 
int main()
{
	const int length = 5;
	int array[length] = { 30, 50, 20, 10, 40 };
 
	// Перебираем каждый элемент массива (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберемся)
	for (int startIndex = 0; startIndex < length - 1; ++startIndex)
	{
		// В переменной smallestIndex хранится индекс наименьшего значения, которое мы нашли в этой итерации.
		// Начинаем с того, что наименьший элемент в этой итерации - это первый элемент (индекс 0)
		int smallestIndex = startIndex;
 
		// Затем ищем элемент поменьше в остальной части массива
		for (int currentIndex = startIndex + 1; currentIndex < length; ++currentIndex)
		{
			// Если мы нашли элемент, который меньше нашего наименьшего элемента,
			if (array[currentIndex] < array[smallestIndex])
				// то запоминаем его
				smallestIndex = currentIndex;
		}
 
		// smallestIndex теперь наименьший элемент. 
        // Меняем местами наше начальное наименьшее число с тем, которое мы обнаружили
		std::swap(array[startIndex], array[smallestIndex]);
	}
 
	// Теперь, когда весь массив отсортирован - выводим его на экран
	for (int index = 0; index < length; ++index)
		std::cout << array[index] << ' ';
 
	return 0;
}

Наиболее запутанной частью этого алгоритма является цикл внутри другого цикла (так называемый «вложенный цикл»). Внешний цикл 
(startIndex) перебирает элементы один за другим (поочередно). В каждой итерации внешнего цикла внутренний цикл (currentIndex) 
используется для поиска наименьшего элемента среди элементов, которые остались в массиве (начиная со startIndex + 1). 
smallestIndex отслеживает индекс наименьшего элемента, найденного внутренним циклом. Затем smallestIndex меняется значением с 
startIndex. И, наконец, внешний цикл (startIndex) переходит к следующему индексу массива, и процесс повторяется.

Подсказка: Если у вас возникли проблемы с пониманием того, как работает программа, приведенная выше, то попробуйте записать 
её выполнение на листке бумаги. Запишите начальные (неотсортированные) элементы массива горизонтально в строке в верхней части листа. 
Нарисуйте стрелки, указывающие на то, какими элементами являются startIndex, currentIndex и smallestIndex на данный момент. 
Прокрутите выполнение программы вручную и перерисуйте стрелки по мере изменения индексов. После каждой итерации внешнего цикла 
нарисуйте новую строку, показывающую текущее состояние массива (расположение его элементов).

Сортировка текста выполняется с помощью того же алгоритма. Просто измените тип массива с int на std::string и инициализируйте 
его с помощью соответствующих значений.


Функция std::sort()

Поскольку операция сортировки массивов очень распространена, то Стандартная библиотека C++ предоставляет встроенную функцию 
сортировки std::sort(). Она находится в заголовочном файле algorithm и вызывается следующим образом:

#include <iostream> 
#include <algorithm> // для std::sort()
 
int main()
{
	const int length = 5;
	int array[length] = { 30, 50, 20, 10, 40 };
 
	std::sort(array, array+length);
 
	for (int i=0; i < length; ++i)
		std::cout << array[i] << ' ';
 
	return 0;
}



Тест

Задание №1
Напишите на листке бумаги выполнение сортировки следующего массива методом выбора (так, как мы это делали выше):

{30, 60, 20, 50, 40, 10}

Ответ №1

Задание №2
Перепишите код программы из подзаголовка «Сортировка массивов методом выбора в C++» так, чтобы сортировка выполнялась 
в порядке убывания (от наибольшего числа к наименьшему). Хотя это может показаться сложным на первый взгляд, но на самом 
деле это очень просто.

#include <iostream> 
#include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>
 
int main()
{
	const int length = 5;
	int array[length] = { 30, 50, 20, 10, 40 };
 
	// Перебираем каждый элемент массива (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберемся)
	for (int startIndex = 0; startIndex < length - 1; ++startIndex)
	{
		// В переменной smallestIndex хранится индекс наименьшего значения, которое мы нашли в этой итерации.
		// Начинаем с того, что наименьший элемент в этой итерации - это первый элемент (индекс 0)
		int smallestIndex = startIndex;
 
		// Затем ищем элемент поменьше в остальной части массива
		for (int currentIndex = startIndex + 1; currentIndex < length; ++currentIndex)
		{
			// Если мы нашли элемент, который меньше нашего наименьшего элемента,
			if (array[currentIndex] > array[smallestIndex])
				// то запоминаем его
				smallestIndex = currentIndex;
		}
 
		// smallestIndex теперь наименьший элемент. 
        // Меняем местами наше начальное наименьшее число с тем, которое мы обнаружили
		std::swap(array[startIndex], array[smallestIndex]);
	}
 
	// Теперь, когда весь массив отсортирован - выводим его на экран
	for (int index = 0; index < length; ++index)
		std::cout << array[index] << ' ';
 
	return 0;
}


Ответ №2


Задание №3

Это задание уже немного сложнее.

Еще одним простым методом сортировки элементов является «сортировка пузырьком» (или «пузырьковая сортировка»). 
Суть заключается в сравнении пары значений, которые находятся рядом, и, если удовлетворены заданные критерии, 
значения из этой пары меняются местами. И таким образом элементы «скачут пузырьком» до конца массива. Хотя есть 
несколько способов оптимизировать сортировку пузырьком, в этом задании мы будем придерживаться неоптимизированной 
версии, так как она проще.

При неоптимизированной версии сортировки пузырьком выполняются следующие шаги для сортировки массива от наименьшего 
до наибольшего значения:
- Сравнивается элемент массива под индексом 0 с элементом массива под индексом 1. Если элемент под индексом 0 больше элемента под индексом 1, то значения меняются местами.
- Затем мы перемещаемся к следующей паре значений: элемент под индексом 1 и элемент под индексом 2 и так до тех пор, пока не достигнем конца массива.
- Повторяем шаг №1 и шаг №2 до тех пор, пока весь массив не будет отсортирован.

Напишите программу, которая отсортирует следующий массив сортировкой пузырьком в соответствии с правилами, указанными выше:

const int length(9);
int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };

В конце программы выведите отсортированные элементы массива.

Подсказка: Если мы можем отсортировать только один элемент за одну итерацию, то это означает, что нам нужно будет повторить 
выполнение цикла столько раз, сколько есть чисел в нашем массиве (его длина), дабы гарантировать выполнение сортировки всего массива.


#include <iostream>
#include <algorithm>

int main(){
	const int length(9);
	int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
	for(int i=0;i<length;++i){
		for(int j=i;j<length;++j)
			if(array[i]>array[j]) std::swap(array[i],array[j]);
	}
	for(int i=0;i<length;++i)
		std::cout << array[i] << " ";

	std::cout << "\n";
	return 0;
}




Задание №4

Реализуйте следующие два решения оптимизации алгоритма сортировки пузырьком, который вы написали в предыдущем задании:
-  Обратите внимание, с каждым выполнением сортировки пузырьком наибольшее значения в массиве «пузырится» до конца. После первой 
  итерации последний элемент массива уже отсортирован. После второй итерации отсортирован предпоследний элемент массива и т.д. 
  С каждой новой итерацией нам не нужно перепроверять элементы, которые уже были отсортированы. Измените свой цикл соответствующим образом.
-  Если на протяжении всей итерации не выполнится ни одной замены, то мы знаем, что массив уже отсортирован. Внедрите проверку того, 
  были ли сделаны какие-либо замены в текущей итерации, и, если нет — завершите выполнение цикла. Если цикл был завершен, то выведите 
  информацию о том, на какой итерации сортировка элементов завершилась.

Пример результата выполнения вашей программы:

Early termination on iteration: 8
1 2 3 4 5 6 7 8 9

#include <iostream> 
#include <algorithm> 
#define ARPRINT(ARR,N) for(int i=0;i<N;++i) std::cout << ARR[i] << " "; std::cout << "\n"

int main(){
    int const n = 9;
	int arr[n]{1, 2, 3, 4, 5, 6, 7, 9, 8};
    std::cout << "Initial array: \n";
    ARPRINT(arr,n);
    int i;
    for(i=0;i<n-i;++i){
        bool swapped = false;
        for(int j=0;j<n-1;++j){
            if(arr[j]>arr[j+1]){
                std::swap(arr[j],arr[j+1]);
                swapped = true;
            }
        }
        if(!swapped) break;
    }
    std::cout << "Stopped after iteration "  << i+1 << "\n";
    std::cout << "Final array: \n";
    ARPRINT(arr,n);
    

    return 0;   
}




Ответ №4

#include <iostream> 
#include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>
 
int main()
{
    const int length(9);
    int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
 
    for (int iteration = 0; iteration < length-1; ++iteration)
    {
        // Помните о том, что последний элемент будет отсортирован и в каждой последующей итерации цикла,
        // поэтому наша сортировка «заканчивается» на один элемент раньше
        int endOfArrayIndex(length - iteration);
 
        bool swapped(false); // отслеживаем, были ли выполнены замены в этой итерации
 
        // Перебираем каждый элемент массива до последнего (не включительно).
        // Последний элемент не имеет пары для сравнения
        for (int currentIndex = 0; currentIndex < endOfArrayIndex - 1; ++currentIndex)
        {
            // Если текущий элемент больше элемента, следующего за ним,
            if (array[currentIndex] > array[currentIndex + 1])
            {
                // то выполняем замену
                std::swap(array[currentIndex], array[currentIndex + 1]);
                swapped = true;
            }
        }
 
        // Если в этой итерации не выполнилось ни одной замены, то цикл можно завершать
        if (!swapped)
        {
            // Выполнение начинается с 0-й итерации, но мы привыкли считать, начиная с 1, поэтому для подсчета количества итераций добавляем единицу
            std::cout << "Early termination on iteration: " << iteration+1 << '\n';
            break;
        }
    }
 
    // Выводим отсортированный массив на экран
    for (int index = 0; index < length; ++index)
        std::cout << array[index] << ' ';
 
    return 0;
}
