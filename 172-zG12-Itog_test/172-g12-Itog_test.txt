Глава No 12. Итоговый тест

Итак, наше путешествие в наследование и виртуальные функции в языке C++ подошло к концу. Пора закрепить пройденный
материал.

Оглавление:
1. Теория
2. Задание No 1
3. Задание No 2


Теория

Язык C++ позволяет создавать указатели/ссылки родительского класса на объекты дочерних классов. Это полезно при
использовании функций или массивов, которые должны работать с объектами дочерних классов.

Без виртуальных функций указатели/ссылки родительского класса на объект дочернего класса будут иметь доступ только
к членам родительского класса.

Виртуальная функция — это особый тип функции, которая, при обращении к ней, вызывает наиболее дочерний метод
(переопределение), существующий между родительским и дочерними классами. Чтобы считаться переопределением, метод
дочернего класса должен иметь ту же сигнатуру и тип возврата, что и виртуальная функция родительского класса.
Единственное исключение — ковариантный тип возврата, который позволяет переопределению возвращать указатель или
ссылку на дочерний класс, если метод родительского класса возвращает указатель или ссылку на себя.

Модификатор override используется для обозначения того факта, что метод является переопределением.

Модификатор final запрещает переопределять виртуальную функцию или наследовать определенный класс.

Используя виртуальные функции, не забывайте добавлять в родительский класс виртуальный деструктор, чтобы, в случае
удаления указателя на родительский класс, вызывался соответствующий деструктор.

Вы можете игнорировать вызов переопределений виртуальной функции, используя оператор разрешенияо бласти видимости,
чтобы напрямую указать, какую функцию вы хотите вызвать. Например, parent.Parent::GetName().

Раннее связывание происходит, когда компилятор встречает прямой вызов функции. Компилятор или линкер могут
напрямую обрабатывать прямые вызовы функций. 

Позднее связывание происходит при вызове указателя на функцию. В таких случаях невозможно знать наперёд, какая 
функция будет вызываться первой. Виртуальные функции используют позднее связывание и виртуальные таблицы для 
определения того, какую версию функции следует вызывать.

Относительные недостатки виртуальных функций:
 Вызов виртуальных функций занимает больше времени.
 Необходимость наличия виртуальной таблицы увеличивает размер каждого объекта класса, содержащего виртуальную
функцию, на размер одного указателя.

Виртуальную функцию можно сделать чистой виртуальной/абстрактной функцией, добавив =0 в конец её прототипа.
Класс, содержащий чистую виртуальную функцию, называется абстрактным классом. Объекты абстрактного класса не могут
быть созданы. Класс, который наследует чистые виртуальные функции, должен предоставить свои переопределения этих
функций, или он также будет считаться абстрактным. Чистые виртуальные функции могут иметь тело (определение,
записанное отдельно), но они по-прежнему считаются абстрактными функциями.

Интерфейс (или «интерфейсный класс») — это класс без переменных-членов, все методы которогоявляются чистыми
виртуальными функциями. Имена интерфейсов частоначинаются с I.
Виртуальный базовый класс — это родительский класс, объект которогоявляется общим для использования всеми
дочернимик лассами.
При присваивании объекта дочернего класса объекту родительского класса, в объект родительского класса копируется 
лишь родительская часть копируемого объекта, дочерняя часть копируемого объекта обрезается.
Этот процессназывается обрезкой объектов.

Динамическое приведение используется для конвертации указателя родительского класса в указатель дочернего класса.
Это называется понижающим приведением типа. Если конвертация прошла неудачно, то возвращается нулевой указатель.
Самый простой способ перегрузить оператор вывода << для классов с наследованием — записать перегрузку оператора
<< в родительском классе, а выполнение операции вывода делегировать виртуальному методу.


Тест

Задание No 1

Каждая из следующих программ имеет какую-то ошибку. Ваша задача состоит в том, чтобы найти эту ошибку визуально
(не запуская код). Предполагаемый вывод каждой программы:
Child

a)
1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		:m_value(value)
11 	{
12 	}
13
14 	const char* getName() const { return "Parent"; }
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	Child(intvalue)
21 		:Parent(value)
22 	{
23 	}
24
25 	const char* getName() const { return "Child"; }
26 };
27
28 int main()
29 {
30 	Child ch(7);
31 	Parent &p=ch;
32 	std::cout<< p.getName();
33
34 	return 0;
35 }

Мой ответ
getName не является виртуальной функцией. Поэтому p имеет доступ только к p.Parent::getName(), 
поэтому будет выведено "Parent".


Ответ No 1.a)


b)
1  #include <iostream>
2
3  class Parent
4  {
5  protected:
6  	int m_value;
7
8  public:
9  	Parent(int value)
10 		:m_value(value)
11 	{
12 	}
13
14 	virtual const char* getName() { return "Parent"; }
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	Child(intvalue)
21 		:Parent(value)
22 	{
23 	}
24
25 	virtual const char* getName() const { return"Child"; }
26 };
27
28 int main()
29 {
30 	Child ch(7);
31 	Parent &p=ch;
32 	std::cout<< p.getName();
33
34 	return 0;
35 }

Мой ответ
Функции getName() в Parent и в Child имеют разные сигнатуры.


Ответ No 1.b)


c)
1  #include <iostream>
2
3 class Parent
4 {
5 protected:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		:m_value(value)
11 	{
12 	}
13
14 	virtual const char* getName() { return "Parent"; }
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	Child(intvalue)
21 		:Parent(value)
22 	{
23 	}
24
25 	virtual const char* getName() override { return "Child"; }
26 };
27
28 int main()
29 {
30 	Child ch(7);
31 	Parent p = ch;
32 	std::cout<< p.getName();
33
34 	return 0;
35 }


Мой ответ
Т.к. p - это не ссылка и не указатель, то при p = ch происходит обрезка объекта и функции p.Child::getName() просто нет.

Ответ No 1.c)


d)
1 #include <iostream>
2
3 class Parent final
4 {
5 protected:
6 	int m_value;
7
8 public:
9 Parent(int value)
10 	:m_value(value)
11 {
12 }
13
14 virtual const char* getName(){return "Parent";}
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	Child(intvalue)
21 		:Parent(value)
22 	{
23 	}
24
25 virtual const char* getName() override {return "Child"; }
26 };
27
28 int main()
29 {
30 	Child ch(7);
31 	Parent &p=ch;
32 	std::cout<< p.getName();
33
34 	return 0;
35 }

Мой ответ
Класс Parent имеет модификатор final, поэтому он не может быть унаследован классом Child 


Ответ No 1.d)


e)
1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 intm_value;
7
8 public:
9 Parent(int value)
10 :m_value(value)
11 {
12 }
13
14 virtualconstchar* getName(){return "Parent";}
15 };
16
17 class Child: public Parent
18 {
19 public:
20 Child(intvalue)
21 :Parent(value)
22 {
23 }
24
25 virtualconstchar* getName()=0;
26 };
27
28 const char*Child::getName()
29 {
30 return "Child";
31 }
32
33 int main()
34 {
35 Childch(7);
36 Parent &p=ch;
37 std::cout<< p.getName();
38
39 return 0;
40 }


Ответ No 1.e)


f)
1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 intm_value;
7
8 public:
9 Parent(int value)
10 :m_value(value)
11 {
12 }
13
14 virtualconstchar* getName(){return "Parent";}
15 };
16
17 class Child: public Parent
18 {
19 public:
20 Child(intvalue)
21 :Parent(value)
22 {
23 }
24
25 virtualconstchar* getName(){return "Child"; }
26 };
27
28 int main()
29 {
30 Child*ch=new Child(7);
31 Parent *p=ch;
32 std::cout<< p->getName();
33 delete p;
34
35 return 0;
36 }


Ответ No 1.f)


Задание No 2
a) Создайте абстрактныйкласс Shape. Этот класс должен иметьтри метода:
 чистую виртуальную функцию print() с параметром типа std::ostream;
 перегрузку operator<<;
 пустой виртуальный деструктор.

ОтветNo2.a)

b) Создайте два класса: Triangle и Circle, которые наследуют класс Shape.
 Triangle должен иметь 3 точки в качестве переменных-членов.
 Circle должени меть одну центральную точку и целочисленный радиус в качестве переменных-членов.
Перегрузите функцию print(), чтобы следующий код:

1 int main()
2 {
3 Circle c(Point(1, 2,3),7);
4 std::cout<< c << '\n';
5
6 Triangle t(Point(1, 2,3), Point(4,5, 6),Point(7,8, 9));
7 std::cout<< t << '\n';
8
9 return 0;
10 }

Выдавал следующий результат:
Circle(Point(1, 2, 3), radius 7)
Triangle(Point(1,2,3), Point(4, 5, 6), Point(7, 8, 9))

Вот класс Point, который вы можете использовать:
1 class Point
2 {
3 private:
4 	int m_x=0;
5 	int m_y=0;
6 	int m_z=0;
7
8 public:
9 	Point(intx, inty, int z)
10 		:m_x(x),m_y(y), m_z(z)
11 	{
12
13 	}
14
15 	friend std::ostream& operator<< (std::ostream &out, const Point &p)
16 	{
17 		out << "Point(" <<p.m_x <<", " << p.m_y <<","<< p.m_z << ")";
18 		return out;
19 	}
20 };

Ответ No 2.b)
c) Используя код из предыдущих заданий (классы Point, Shape, Circle и Triangle) завершите следующую программу:
1 #include <iostream>
2 #include <vector>
3
4 int main()
5 {
6 	std::vector<Shape*> v;
7 	v.push_back(new Circle(Point(1,2, 3), 7));
8 	v.push_back(new Triangle(Point(1,2, 3),Point(4, 5, 6), Point(7, 8,9)));
9 	v.push_back(new Circle(Point(4,5, 6), 3));
10
11 	// Вывод элементов вектора v здесь
12
13 	std::cout << "The largest radius is:" << getLargestRadius(v) <<'\n'; // реализуйте эту функцию
14
15 	// Удаление элементов вектора v здесь
16 }

Подсказка: Вам нужно добавить метод getRadius() в Circle и выполнить понижающее приведение Shape* в Circle*, чтобы
получить доступ к этому методу.

Ответ No 2.c)
