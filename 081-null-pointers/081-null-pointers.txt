Урок No 81. Нулевые указатели

Как и в случае с обычными переменными, указатели не инициализируются при создании. Если значение не было присвоено,
то указатель по умолчанию будет указывать на любой адрес, содержимым которого является мусор.

Оглавление:
1. Нулевое значение и нулевые указатели
2. Разыменование нулевых указателей
3. Макрос NULL
4. Ключевое слово nullptr в C++11
5. Тип данных std::nullptr_t в C++11


Нулевое значение и нулевые указатели

Помимо адресов памяти, есть еще одно значение, которое указатель может хранить: значение null. Нулевое значение (или
«значение null») — это специальное значение, которое означает, что указатель ни на что не указывает. Указатель,
содержащий значение null, называется нулевым указателем.

В языке C++ мы можем присвоить указателю нулевое значение, инициализируя его/присваивая ему литерал 0:

1 int *ptr(0); // ptr теперь нулевой указатель
2
3 int *ptr1; // ptr1 не инициализирован
4 ptr1 = 0; // ptr1 теперь нулевой указатель

Поскольку значением нулевого указателя является нуль, то это можно использовать внутри условного ветвления для
проверки того, является ли указатель нулевым или нет:
1 #include <iostream>
2
3 int main()
4 {
5 	double *ptr(0);
6
7 	if (ptr)
8 		std::cout << "ptr is pointing to a double value.";
9 	else
10 		std::cout << "ptr is a null pointer.";
11
12 	return 0;
13 }

Совет: Инициализируйте указатели нулевым значением, если не собираетесь присваивать им другие значения.


Разыменование нулевых указателей

Как мы уже знаем из предыдущего урока, разыменование указателей с мусором приведет к неожиданным результатам. С
разыменованием нулевого указателя дела обстоят так же. В большинстве случаев вы получите сбой в программе.
В этом есть смысл, ведь разыменование указателя означает,что нужно «перейти к адресу, на который указывает указатель, и
достать из этого адреса значение». Нулевой указатель не имеет адреса, поэтому и такой результат.


Макрос NULL

В языке Cи (но не в C++) есть специальный макрос препроцессора с именем NULL, который определен как значение 0 . Хоть он
и не является частью языка C++, его использование достаточно распространено, и должно работать вкаждом компиляторе С++:
присваиваем адрес указателю

1 int *ptr(NULL); // 0 ptr

Однако, поскольку NULL является макросом препроцессора и, технически, не является частью C++, то его не рекомендуется
использовать.


Ключевое слово nullptr в C++11

Обратите внимание, значение 0 не является типом указателя, и присваивание указателю значения 0 для обозначения того,
что он является нулевым — немного противоречиво, вам не кажется? В редких случаях,использование 0 в качестве
аргумента-литерала может привести к проблемам, так каккомпилятор не сможет определить, используется ли нулевой
указатель или целое число 0 :

1 doAnything(0); // является ли 0 аргументом-значением или аргументом-указателем? (компилятор определит его как целочисленное значение)

Для решения этой проблемыв C++11 ввели новое ключевое слово nullptr, которое также является константой r-value.
Начиная с C++11, при работе с нулевыми указателями, использование nullptr является более предпочтительным вариантом,
нежели использование 0 :

1 int *ptr = nullptr; // примечание: ptr по-прежнему остается указателем типа int, просто со значением null (0)

Язык C++ неявно преобразует nullptr в соответствующий тип указателя. Таким образом, в вышеприведенном примере, nullptr
неявно преобразуется в указатель типа int, а затем значение nullptr присваивается ptr .
nullptr также может использоваться для вызова функции (в качестве аргумента-литерала):

1 #include <iostream>
2
3 void doAnything(int *ptr)
4 {
5 	if (ptr)
6 		std::cout << "You passed in " << *ptr << '\n';
	7 else
8 		std::cout << "You passed in a null pointer\n";
9 }
10
11 int main()
12 {
13 	doAnything(nullptr); // теперь аргумент является точно нулевым указателем, а не целочисленным значением
14
15 return 0;
16 }

Совет: В C++11 используйте nullptr для инициализации нулевых указателей.


Тип данных std::nullptr_t в C++11

В C++11 добавили новый тип данных std::nullptr_t, которыйнаходится взаголовочном файле cstddef. std::nullptr_t может
иметь толькоодно значение — nullptr! Хотя это может показаться немного глупым, но это полезно в одном случае. Если вам
нужно написать функцию, которая принимает аргумент nullptr, то какой тип параметра нужно использовать? Правильно!
std::nullptr_t. Например:

1 #include <iostream>
2 #include <cstddef> // для std::nullptr_t
3
4 void doAnything(std::nullptr_t ptr)
5 {
6 	std::cout << "in doAnything()\n";
7 }
8
9 int main()
10 {
11 	doAnything(nullptr); // вызов функции doAnything() с аргументом типа std::nullptr_t
12
13 	return 0;
14 }

Вам, вероятно, никогда это не придется использовать, но знать об этом стоит (на всякий пожарный).
