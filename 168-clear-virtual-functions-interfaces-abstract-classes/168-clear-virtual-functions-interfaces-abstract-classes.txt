Урок No168. Чистые виртуальные функции, Интерфейсы и Абстрактные классы

На этом уроке мы рассмотрим чистые виртуальные функции, интерфейсы и абстрактные классы.

Оглавление:
1. Абстрактные функци и иклассы
2. Пример чистой виртуальной функции
3. Чистые виртуальные функции с определениями
4. Интерфейсы
5. Чистые виртуальные функции и виртуальная таблица
6. Тест


Абстрактные функции и классы

До этого момента мы записывали определения всех наших виртуальных функций. Однако C++ позволяет создавать особый
вид виртуальных функций, так называемых чистых виртуальных функций (или «абстрактных функций»), которые вообще
не имеют определения! Переопределяют их дочерние классы.

Присоздании чистой виртуальной функции,вместо определения(написания тела) виртуальной функции,мы просто
присваиваемей значение 0.

1 class Parent
2 {
3 public:
4 	const char* sayHi() { return "Hi"; } // обычная невиртуальная функция
5
6 	virtual const char* getName() { return "Parent"; } // обычная виртуальная функция
7
8 	virtual int getValue() = 0; // чистая виртуальная функция
9
10 	int doSomething() = 0; // ошибка компиляции: нельзя присвоить невиртуальным функциям значение 0
11 };

Таким образом, мы сообщаем компилятору: «Реализацией этой функции займутся дочерние классы».

Использование чистой виртуальной функции имеет два основных последствия. Во-первых, любой класс с одной и более
чистыми виртуальными функциями становится абстрактным классом, объекты которого создавать нельзя! Подумайте, что
произойдет, если мы создадим объекткласса Parent:

1 int main()
2 {
3 	Parent parent; // мы не можем создавать объекты абстрактного класса, но, ради эксперимента, представьте, что это возможно
4 	parent.getValue(); // какой результат выполнения этой строки кода?
5 }

Поскольку мы не определяли метод getValue(), то какой результат выполнения parent.getValue() ?
Во-вторых, все дочерние классы абстрактного родительского класса должны переопределять все чистые виртуальные
функции, в противном случае — они также будут считаться абстрактными классами.


Пример чистой виртуальной функции

Рассмотрим пример чистой виртуальной функции на практике. На одном из предыдущих уроков мы создавали родительский
класс Animal и дочерние классы Cat и Dog:

1 #include <iostream>
2 #include <string>
3
4 class Animal
5 {
6 protected:
7 	std::string m_name;
8
9 	// Мы сделали этот конструктор protected так как не хотим, чтобы пользователи могли создавать объекты класса Animal напрямую
10 	// но хотим, чтобы эта возможность оставалась в дочерних классах
11 	Animal(std::string name)
12 		: m_name(name)
13 	{
14 	}
15
16 public:
17 	std::string getName() { return m_name; }
18 	virtual const char* speak() { return "???"; }
19 	};
20
21 class Cat: public Animal
22 {
23 public:
24 	Cat(std::string name)
25 		: Animal(name)
26 	{
27 	}
28
29 	virtual const char* speak() { return "Meow"; }
30 };
31
32 class Dog: public Animal
33 {
34 public:
35 	Dog(std::string name)
36 		: Animal(name)
37 	{
38 	}
39
40 	virtual const char* speak() { return "Woof"; }
41 };

Мы запретили создавать объекты класса Animal, сделав конструктор protected. Однако, остаются две проблемы:
 Конструктор по-прежнему доступен дочерним классам, что позволяет создавать объекты класса Animal.
 По-прежнему могут быть дочерние классы, которые не переопределяют метод speak().

Например:
1 class Lion: public Animal
2 {
3 public:
4 	Lion(std::string name)
5 		: Animal(name)
6 	{
7 	}
8
9 	// Мы забыли переопределить метод speak()
10 };
11
12 int main()
13 {
14 	Lion lion("John");
15 	std::cout << lion.getName() << " says " << lion.speak() << '\n';
16 }

Результат выполненияпрограммы:
John says ???

Что случилось? Мы забыли переопределить метод speak(), поэтому lion.Speak() вызвал Animal.speak() и получили то, что
получили.
Решение — использовать чистую виртуальную функцию:

1 #include <iostream>
2 #include <string>
3
4 class Animal // этот Animal является абстрактным родительским классом
5 {
6 protected:
7 	std::string m_name;
8
9 public:
10 	Animal(std::string name)
11 		: m_name(name)
12 	{
13 	}
14
15 	std::string getName() { return m_name; }
16 	virtual const char* speak() = 0; // обратите внимание, speak() является чистой виртуальной функцией
17 };

Здесь есть несколько вещей, на которые следует обратить внимание. 

Во-первых, speak() теперь является чистой виртуальной функцией. 
Это означает, что Animal теперь абстрактный родительский класс, и нам уже не нужен спецификатор protected (хотя
он и не будет лишним). 

Во-вторых, поскольку наш класс Lion является дочерним классу Animal, но мы не определили Lion::speak(),
то Lion считается также абстрактным классом. Поэтому, если мы попытаемся скомпилировать следующий код:

1 class Lion: public Animal
2 {
3 public:
4 	Lion(std::string name)
5 		: Animal(name)
6 	{
7 	}
8
9 // Мы забыли переопределить метод speak()
10 };
11
12 int main()
13 {
14 	Lion lion("John");
15 	std::cout << lion.getName() << " says " << lion.speak() << '\n';
16 }

То получим ошибку, сообщающую о том, что Lion является абстрактным классом, а создавать объекты абстрактного класса
нельзя. Из этого можносделать вывод, что для того, чтобы создать объект класса Lion, нам нужно переопределить метод
speak():

1 class Lion: public Animal
2 {
3 public:
4 	Lion(std::string name)
5 		: Animal(name)
6 	{
7 	}
8
9 	virtual const char* speak() { return "RAWRR!"; }
10 };
11
12 int main()
13 {
14 	Lion lion("John");
15 	std::cout << lion.getName() << " says " << lion.speak() << '\n';
16 }

Теперьуже другое дело:
John says RAWRR!

Чистая виртуальная функция полезна, когда у нас есть функция, которую мы хотим поместить в родительский класс, но
реализацию оставить дочерним классам. Чистая виртуальная функция абстрактного родительского класса вынуждает
дочерние классы переопределить эту функцию, иначе объекты этих классов создавать будет невозможно.


Чистые виртуальные функции с определениями

Оказывается, мы можем определить чистые виртуальные функции:

1 #include <iostream>
2 #include <string>
3
4 class Animal // это абстрактный родительский класс
5 {
6 protected:
7 	std::string m_name;
8
9 public:
10 	Animal(std::string name)
11 		: m_name(name)
12 	{
13 	}
14
15 	std::string getName() { return m_name; }
16 	virtual const char* speak() = 0; // присваивание значения "= 0" говорит о том, что эта функция является чистой виртуальной
17 };
18
19 const char* Animal::speak() // несмотря на то, что вот здесь находится её определение
20 {
21 	return "buzz";
22 }

В этом случае speak() по-прежнему считается чистой виртуальной функцией (хотя позже мы её определили), а Animal по-
прежнему считается абстрактным родительским классом (и, следовательно, объекты этого класса не могут быть созданы).
Любой класс, который наследует класс Animal, должен переопределить метод speak() или он также будетсчитаться
абстрактным классом.

При определении чистой виртуальной функции, её тело(определение) должно быть записано отдельно (не встроено).
Это полезно, когда вы хотите, чтобы дочерние классы имели возможность переопределять виртуальную функцию или оставить
её реализацию по умолчанию (которую предоставляет родительский класс). В случае, если дочерний класс доволен
реализацией по умолчанию, он может просто вызвать её напрямую. Например:

1 #include <iostream>
2 #include <string>
3
4 class Animal // это абстрактный родительский класс
5 {
6 protected:
7 	std::string m_name;
8
9 public:
10 	Animal(std::string name)
11 		: m_name(name)
12 	{
13 	}
14
15 	std::string getName() { return m_name; }
16 	virtual const char* speak() = 0; // обратите внимание, speak() является чистой виртуальной функцией
17 };
18
19 const char* Animal::speak()
20 {
21 	return "buzz"; // реализация по умолчанию
22 }
23
24 class Dragonfly: public Animal
25 {
26
27 public:
28 	Dragonfly(std::string name)
29 	: Animal(name)
30 	{
31 	}
32
33 	virtual const char* speak() // этот класс уже не является абстрактным, так как мы переопределили функцию speak()
34 	{
35 		return Animal::speak(); // используется реализация по умолчанию класса Animal
36 	}
37 };
38
39 int main()
40 {
41 	Dragonfly dfly("Barbara");
42 	std::cout << dfly.getName() << " says " << dfly.speak() << '\n';
43 }

Результат выполненияпрограммы:
Barbara says buzz


Интерфейсы

Интерфейс — это класс, который не имеет переменных-членов и все методы которого являются чистыми виртуальными
функциями! 

Интерфейсы еще называют «классами-интерфейсами» или «интерфейсными классами».
Интерфейсные классы принято называть с I в начале, например:

1 class IErrorLog
2 {
3 public:
4 	virtual bool openLog(const char *filename) = 0;
5 	virtual bool closeLog() = 0;
6
7 	virtual bool writeError(const char *errorMessage) = 0;
8
9 	virtual ~IErrorLog() {}; // создаем виртуальный деструктор, чтобы вызывался соответствующий деструктор дочернего класса в случае, если удалим указатель на IErrorLog
10 };

Любой класс, который наследует IErrorLog, должен предоставить свою реализацию всех 3 методов класса IErrorLog.
Вы можете создать дочерний класс с именем FileErrorLog, где openLog() открывает файл на диске, closeLog() — закрывает 
файл, а writeError() — записывает сообщение в файл. 
Выможете создать еще один дочерний класс с именем ScreenErrorLog, где openLog()и closeLog() ничего не делают, 
а writeError() выводит сообщение во всплывающем окне.

Теперь предположим, что вам нужно написать программу, которая использует журнал ошибок. Если вы будете писать классы
FileErrorLog или ScreenErrorLog напрямую,то это неэффективно. Например, следующая функция заставляет все объекты,
вызывающие mySqrt(), использовать FileErrorLog, что может быть не всегда уместно:

1 #include <cmath> // для sqrt()
2
3 double mySqrt(double value, FileErrorLog &log)
4 {
5 	if (value < 0.0)
6 	{
7 		log.writeError("Tried to take square root of value less than 0");
8 		return 0.0;
9 	}
10 	else
11 		return sqrt(value);
12 }

Намного лучшим вариантом будет реализация через IErrorLog:

1 #include <cmath> // для sqrt()
2
3 double mySqrt(double value, IErrorLog &log)
4 {
5 	if (value < 0.0)
6 	{
7 		log.writeError("Tried to take square root of value less than 0");
8 		return 0.0;
9 	}
10 	else
11 		return sqrt(value);
12 }

Теперь пользователь через передачу объектов может определить самостоятельно, какой класс следует вызывать. Если он
хочет, чтобы ошибка была записана в файле, то он передаст в функциюmy Sqrt() объект класса FileErrorLog. Если он хочет,
чтобы ошибка выводилась на экран, то он передаст объекткласса ScreenErrorLog. Или, если он хочет сделать то, что вы не
предусмотрели, например, отправить кому-то Email-ом сообщение ошибки, то он может создать новый дочерний класс
EmailErrorLog, который будет наследовать IErrorLog, и передавать объект этого класса!
Таким образом, реализация через IErrorLog делает нашу функциюболее гибкой и независимой.

Не забудьте о подключении виртуальных деструкторов в ваши интерфейсные классы, чтобы при удалении указателя на
интерфейс вызывался деструктор соответствующего (дочернего) класса.

Интерфейсы чрезвычайно популярны, так как они просты в использовании, удобны в поддержке, и их функционал легко
расширять. Некоторые языки, такие как Java и C#, даже добавили в свой синтаксис ключевоеслово interface, которое
позволяет программистам напрямую определять интерфейсный класс, не указывая явно, что все методы являются абстрактными.


Чистые виртуальные функции и виртуальная таблица

Абстрактные классы имеют виртуальные таблицы, которые могут использоваться, если у вас есть указатель или ссылка на
абстрактный класс. Запись чистой виртуальной функции в виртуальной таблице обычно содержит либо нулевой указатель,
либо указывает на общую функцию, которая выводит ошибку (иногда эта функция называется __purecall ), если не было
обнаружено переопределения.

Тест

Чем отличается абстрактный класс от интерфейса в языке C++?

Мой ответ.
Абстрактный класс содержит чистую виртуальную функцию и другие члены.
В отличие от него интефейс - это класс, который содержит только чистые виртуальные функции и ничего больше.

Ответ
Абстрактный класс может иметь переменные-члены и имеет как минимум одну чистую виртуальную функцию, в то время как 
интерфейс не имеет переменных-членов, и все его методы должны быть чистыми виртуальными функциями.

