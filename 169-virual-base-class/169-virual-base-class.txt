Урок No169. Виртуальный базовый класс

На уроке о множественном наследовании мы говорили о проблеме «алмаза смерти». На этом уроке мы продолжим эту тему.

Оглавление:
1. Алмаз смерти
2. Виртуальные базовые классы


Алмаз смерти

Код из того же урока, иллюстрирующий «алмаз смерти» (мы добавили еще конструкторы):

1 class PoweredDevice
2 {
3 public:
4 	PoweredDevice(int power)
5 	{
6 		std::cout << "PoweredDevice: " << power << '\n';
7 	}
8 };
9
10 class Scanner: public PoweredDevice
11 {
12 public:
13 	Scanner(int scanner, int power)
14 		: PoweredDevice(power)
15 	{
16 		std::cout << "Scanner: " << scanner << '\n';
17 	}
18 };
19
20 class Printer: public PoweredDevice
21 {
22 public:
23 	Printer(int printer, int power)
24 		: PoweredDevice(power)
25 	{
26 		std::cout << "Printer: " << printer << '\n';
27 	}
28 };
29
30 class Copier: public Scanner, public Printer
31 {
32 public:
33 	Copier(int scanner, int printer, int power)
34 		: Scanner(scanner, power), Printer(printer, power)
35 	{
36 	}
37 };

Хотя вы можете ожидать, что диаграмма наследования будет следующая:
        
                        ┌───────────────────────┐
                        │                       │
                        │     PoweredDevice     │
                        │                       │
                        └─↑────────────────────↑┘
                          ↑                    ↑
                          │                    │
                          │                    │
      ┌───────────────────┴───┐             ┌──┴────────────────────┐
      │                       │             │                       │
      │       Scanner         │             │       Printer         │
      │                       │             │                       │
      └──────────────────↑────┘             └──↑────────────────────┘
                         ↑                     ↑
                         │                     │
                         │                     │
                        ┌┴─────────────────────┴┐
                        │                       │
                        │       Copier          │
                        │                       │
                        └───────────────────────┘


На самом деле, это не так. Если вы создадите объект класса Copier, то получите две копии класса PoweredDevice: одну от Printer
и одну от Scanner.
Диаграмму получим следующую:

        
     ┌───────────────────────┐              ┌───────────────────────┐     
     │                       │              │                       │     
     │     PoweredDevice     │              │     PoweredDevice     │     
     │                       │              │                       │     
     └────────────────────↑──┘              └──↑────────────────────┘     
                          │                    │
                          │                    │
                          │                    │
      ┌───────────────────┴───┐             ┌──┴────────────────────┐
      │                       │             │                       │
      │       Scanner         │             │       Printer         │
      │                       │             │                       │
      └──────────────────↑────┘             └──↑────────────────────┘
                         │                     │
                         │                     │
                         │                     │
                        ┌┴─────────────────────┴┐
                        │                       │
                        │       Copier          │
                        │                       │
                        └───────────────────────┘

Рассмотрим пример в коде

1 int main()
2 {
3 	Copier copier(1, 2, 3);
4 }

Результат:
PoweredDevice: 3
Scanner: 1
PoweredDevice: 3
Printer: 2

Как вы видите, PoweredDevice создается дважды. Иногда так и нужно, а иногда нужно, чтобы была одна копия PoweredDevice:
общая как для Scanner, так и для Printer.


Виртуальные базовые классы

Чтобы сделать родительский (базовый) класс общим, используется ключевое слово virtual в строке объявления дочернего
класса. Виртуальный базовый класс — это класс, объект которого является общим для использования всеми дочерними
классами. Вот пример (без конструкторов для простоты) создания общего родительского класса:

1 class PoweredDevice
2 {
3 };
4
5 class Scanner: virtual public PoweredDevice
6 {
7 };
8
9 class Printer: virtual public PoweredDevice
10 {
11 };
12
13 class Copier: public Scanner, public Printer
14 {
15 };

Теперь, при создании класса Copier, мы получим только одну копию PoweredDevice, которая будет общей как для Scanner, так и
для Printer.

Следует вопрос: «Если Scanner и Printer совместно используют родительский класс PoweredDevice, то кто ответственный за его
создание?». Оказывается, Copier. Конструктор Copier отвечает за создание объекта PoweredDevice. Это один из тех случаев,
когда дочернему классу разрешено вызывать конструктор родительского класса, который не является его непосредственным
родителем:

1 #include <iostream>
2
3 class PoweredDevice
4 {
5 public:
6 	PoweredDevice(int power)
7 	{
8 		std::cout << "PoweredDevice: " << power << '\n';
9 	}
10 };
11
12 class Scanner: virtual public PoweredDevice // примечание: PoweredDevice теперь виртуальный базовый класс
13 {
14 public:
15 	Scanner(int scanner, int power)
16 		: PoweredDevice(power) // эта строка необходима для создания объектов класса Scanner, но в этой программе она игнорируется
17 	{
18 		std::cout << "Scanner: " << scanner << '\n';
19 	}
20 };
21
22 class Printer: virtual public PoweredDevice // примечание: PoweredDevice теперь виртуальный базовый класс
23 {
24 public:
25 	Printer(int printer, int power)
26 		: PoweredDevice(power) // эта строка необходима для создания объектов класса Printer, но в этой программе она игнорируется
27 	{
28 		std::cout << "Printer: " << printer << '\n';
29 	}
30 };
31
32 class Copier: public Scanner, public Printer
33 {
34 public:
35 	Copier(int scanner, int printer, int power)
36 		: Scanner(scanner, power), Printer(printer, power),
37 	PoweredDevice(power) // построение PoweredDevice выполняется здесь
38 	{
39 	}
40 };
41
42 int main()
43 {
44 	Copier copier(1, 2, 3);
45 }

Результат выполнения программы:
PoweredDevice: 3
Scanner: 1
Printer: 2

Здесь уже PoweredDevice создается только один раз.

Обсудим несколько деталей.

Во-первых, виртуальные базовые классы всегда создаются перед невиртуальными базовыми классами, что обеспечивает
построение всех базовых классов до построения их производных классов.

Во-вторых, конструкторы Scanner и Printer по-прежнему вызывают конструктор PoweredDevice. При создании объекта Copier
эти вызовы конструктора просто игнорируются, так как именно Copier отвечает за создание PoweredDevice, а не Scanner или
Printer. Однако, если бы мы создавали объекты Scanner или Printer, то эти конструкторы вызывались бы и применялись
обычные правила наследования.

В-третьих, если класс, становясь дочерним, наследует один или несколько классов, которые, в свою очередь, имеют
виртуальные родительские классы, то наиболее дочерний класс отвечает за создание виртуального родительского класса. В
программе, приведенной выше, Copier наследует Printer и Scanner, которые оба имеют общий виртуальный родительский
класс PoweredDevice. Copier, наиболее дочерний класс, отвечает за создание PoweredDevice. Это работает даже в случае
одиночного наследования: когда Copier наследует только Printer, а Printer виртуально наследует PoweredDevice, то Copier по-
прежнему ответственный за создание PoweredDevice.
