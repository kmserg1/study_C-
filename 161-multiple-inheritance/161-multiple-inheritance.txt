Урок No 161. Множественное наследование

До сих пор мы рассматривали только одиночные наследования, когда дочерний класс имеет только одного родителя. Однако
C++ предоставляет возможность множественного наследования.

Оглавление:
1. Множественное наследование
2. Проблемы с множественным наследованием
3. Стоит ли использовать множественное наследование?


Множественное наследование

Множественное наследование позволяет одному дочернему классу иметь несколько родителей. Предположим, что мы хотим
написать программу для отслеживания работы учителей. Учитель — это Human. Тем не менее, он также является Сотрудником
(Employee).

Множественное наследование может быть использовано для создания класса Teacher, который будет наследовать свойства как
Human, так и Employee. Для использования множественного наследования нужно просто указать через запятую тип
наследования и второй родительский класс:

1 #include <string>
2
3 class Human
4 {
5 private:
6 	std::string m_name;
7 	int m_age;
8
9 public:
10 	Human(std::string name, int age)
11 		: m_name(name), m_age(age)
12 	{
13 	}
14
15 	std::string getName() { return m_name; }
16 	int getAge() { return m_age; }
17 };
18
19 class Employee
20 {
21 private:
22 	std::string m_employer;
23 	double m_wage;
24
25 public:
26 	Employee(std::string employer, double wage)
27 		: m_employer(employer), m_wage(wage)
28 	{
29 	}
30
31 	std::string getEmployer() { return m_employer; }
32 	double getWage() { return m_wage; }
33	 };
34
35 // Класс Teacher открыто наследует свойства классов Human и Employee
36 class Teacher: public Human, public Employee
37 {
38 private:
39 	int m_teachesGrade;
40
41 public:
42 	Teacher(std::string name, int age, std::string employer, double wage, int teachesGrade)
43 		: Human(name, age), Employee(employer, wage), m_teachesGrade(teachesGrade)
44 	{
45 	}
46 };

Здесь мы используем наследование типа public.


Проблемы с множественным наследованием

Хотя множественное наследование кажется простым расширением одиночного наследования, оно может привести к
множеству проблем, которые могут заметно увеличить сложность программ и сделать кошмаром дальнейшую поддержку кода.

Рассмотрим некоторые из подобных ситуаций.
Во-первых, может возникнуть неоднозначность, когда несколько родительских классов имеют метод с одним и тем же именем,
например:

1 #include <iostream>
2
3 class USBDevice
4 {
5 private:
6 	long m_id;
7
8 public:
9 	USBDevice(long id)
10 		: m_id(id)
11 	{
12 	}
13
14 	long getID() { return m_id; }
15 };
16
17 class NetworkDevice
18 {
19 private:
20 	long m_id;
21
22 public:
23 	NetworkDevice(long id)
24 		: m_id(id)
25 	{
26 	}
27
28 	long getID() { return m_id; }
29 };
30
31 class WirelessAdapter: public USBDevice, public NetworkDevice
32 {
33 public:
34 	WirelessAdapter(long usbId, long networkId)
35 		: USBDevice(usbId), NetworkDevice(networkId)
36 	{
37 	}
38 };
39
40 int main()
41 {
42 	WirelessAdapter c54G(6334, 292651);
43 	std::cout << c54G.getID(); // какую версию getID() здесь следует вызывать?
44
45 	return 0;
46 }


При компиляции c54G.getID() компилятор смотрит, есть ли у WirelessAdapter метод getID(). Этого метода у него нет, поэтому
компилятор двигается по цепочке наследования вверх и смотрит, есть ли этот метод в каком-либо из родительских классов. И
здесь возникает проблема — getID() есть как у USBDevice, так и у NetworkDevice. Следовательно, вызов этого метода приведет к
неоднозначности и мы получим ошибку, так как компилятор не будет знать какую версию getID() ему вызывать.
Тем не менее, есть способ обойти эту проблему. Мы можем явно указать, какую версию getID() следует вызывать:

1 int main()
2 {
3 	WirelessAdapter c54G(6334, 292651);
4 	std::cout << c54G.USBDevice::getID();
5
6 	return 0;
7 }

Хотя это решение довольно простое, но всё может стать намного сложнее, если наш класс будет иметь от 4 родительских
классов, которые, в свою очередь, будут иметь свои родительские классы. 
Во-вторых, возможность возникновения конфликтов имен увеличивается экспоненциально с каждым добавленным родительским классом, 
и в каждом из таких случаев нужно будет явно указывать версии методов, которые следует вызывать, дабы избежать возможности 
возникновения конфликтов имен.
Во-вторых, более серьезной проблемой является «алмаз смерти» (или «алмаз обреченности»). Это ситуация, когда один класс
имеет 2 родительских класса, каждый из которых, в свою очередь, наследует свойства одного и того же родительского класса.
Иллюстративно мы получаем форму алмаза.
                                 
                                 ┌───────────────────────┐
                                 │                       │
                                 │    Powered device     │
                                 └───────────────────────┘
                                  /                     \
                                 /                       \
                                /                         \
                               /                           \
    ┌───────────────────────┐                                ┌───────────────────────┐ 
    │                       │                                │                       │ 
    │      Scanner          │                                │        Printer        │ 
    └───────────────────────┘                                └───────────────────────┘ 
                              \                            /
                               \                          / 
                                \                        /  
                                 \                      /   
                            
                                 ┌───────────────────────┐  
                                 │                       │  
                                 │       Copier          │  
                                 └───────────────────────┘  


Например, рассмотрим следующие классы:
1 class PoweredDevice
2 {
3 };
4
5 class Scanner: public PoweredDevice
6 {
7 };
8
9 class Printer: public PoweredDevice
10 {
11 };
12
13 class Copier: public Scanner, public Printer
14 {
15 };

Сканеры и принтеры — это устройства, которые получают питание от розетки, поэтому они наследуют свойства PoweredDevice.
Однако ксерокс (Copier) включает в себя функции как сканеров, так и принтеров.

В этом контексте возникает много проблем, включая неоднозначность при вызове методов и копирование данных
PoweredDevice в класс Copier дважды. 
Хотя большинство из этих проблем можно решить с помощью явного указания, поддержка и обслуживание такого кода может 
привести к непредсказуемым временным затратам. Мы поговорим детально о способах решения проблемы «алмаза смерти» на соответствующем уроке.


Стоит ли использовать множественное наследование?

Большинство задач, решаемых с помощью множественного наследования, можно решить и с использованием одиночного
наследования. Многие объектно-ориентированные языки программирования (например, Smalltalk, PHP) даже не
поддерживают множественное наследование. Многие, относительно современные языки, такие как Java и C#, ограничивают
классы одиночным наследованием обычных классов, но допускают множественное наследование интерфейсных классов. Суть
идеи, запрещающей множественное наследование в этих языках, заключается в том, что это излишняя сложность, которая
порождает больше проблем, чем удобств.

Многие опытные программисты считают, что множественное наследование в языке C++ следует избегать любой ценой из-за
потенциальных проблем, которые могут возникнуть. Однако все же остается вероятность, когда множественное наследование
будет лучшим решением, нежели придумывание двухуровневых «костылей».

Стоит отметить, что вы сами уже использовали классы, написанные с использованием множественного наследования, даже не
подозревая об этом: такие объекты, как std::cin и std::cout библиотеки iostream, реализованы с использованием
множественного наследования!

Правило: Используйте множественное наследование только в крайних случаях, когда задачу нельзя решить
одиночным наследованием, либо другим альтернативным способом (без изобретения «велосипеда»).
