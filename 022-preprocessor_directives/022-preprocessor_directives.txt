Урок No22. Директивы препроцессора

Препроцессор лучше всего рассматривать как отдельную программу, которая выполняется перед компиляцией. При запуске
программы, препроцессор просматривает кодсверху вниз, файл за файлом,в поиске директив. Директивы — это
специальные команды, которые начинаются с символа # и НЕ заканчиваютсяточкой с запятой. Есть несколько типов
директив,которые мы рассмотрим ниже.

Оглавление:
1. Директива #include
2. Директива #define
3. Макросы-объекты с текст_замена
4. Макросы-объекты без текст_замена
5. Условная компиляция
6. Область видимости директивы #define


Директива #include

Вы уже видели директиву #include вдействии. Когда вы подключаете файл с помощью директивы #include, препроцессор
копирует содержимое подключаемого файла в текущий файл сразу послестроки с #include. Это очень полезно при
использовании определенных данных (например, предварительных объявлений функций) сразу в нескольких местах.
Директива #include имеет две формы:

 #include <filename>, которая сообщает препроцессору искать файл в системных путях (в местах хранения системных
библиотек языка С++). Чаще всего вы будете использовать эту форму при подключении заголовочных файлов из
Стандартной библиотекиC++.
 #include "filename", которая сообщает препроцессору искать файл в текущей директории проекта. Если его там не
окажется,то препроцессор начнет проверять системные пути и любые другие, которые вы указали в настройках вашей IDE.
Эта форма используется для подключения пользовательских заголовочных файлов.

Директива #define

Директиву #define можнои спользовать для создания макросов. 
Макрос — это правило, которое определяет конвертацию идентификатора в указанные данные.
Есть два основных типа макросов: макросы-функции и макросы-объекты.

Макросы-функции ведут себя как функции и используются в тех же целях. Мы не будем сейчас их обсуждать, так как их
использование, как правило, считается опасным, и почти всё,что они могут сделать, можно осуществить с помощью простой
(линейной) функции.

Макросы-объекты можно определить одним из следующих двух способов:
#define идентификатор
Или:
#define идентификатор текст_замена

Верхнее определение не имеет никакого текст_замена, в то время как нижнее — имеет. Поскольку это директивы
препроцессора (а не простые стейтменты), то ни одна из форм не заканчивается точкой с запятой.

Макросы-объекты с текст_замена

Когда препроцессор встречает макросы-объекты с текст_замена, то любое дальнейшее появление идентификатор
заменяется на текст_замена. идентификатор обычно пишется заглавными буквами с символами подчёркивания вместо
пробелов.
Рассмотрим следующий фрагмент кода:

1 #define MY_FAVORITE_NUMBER 9
2
3 std::cout << "My favorite numberis: "<< MY_FAVORITE_NUMBER << std::endl;

Препроцессор преобразует вышеприведенный код в:
1 std::cout << "My favorite numberis: "<< 9 << std::endl;

Результат выполнения:
My favorite number is: 9

Мы обсудим это детально, и почему так не стоит делать, на следующих уроках.


Макросы-объекты без текст_замена

Макросы-объекты также могут быть определены без текст_замена, например:

1 #define USE_YEN

Любое дальнейшее появление идентификатора USE_YEN удаляется и заменяется «ничем» (пустым местом)!
Это может показаться довольно бесполезным, однако, это не основное предназначение подобных директив. В отличие от
макросов-объектов с текст_замена, эта форма макросов считается приемлемой для использования.


Условная компиляция

Директивы препроцессора условной компиляции позволяют определить, при каких условиях код будет компилироваться, а
при каких — нет. На этом уроке мы рассмотрим только три директивы условной компиляции:
 #ifdef
 #ifndef
 #endif

Директива #ifdef (сокр. от «ifdefined» = «если определено») позволяет препроцессору проверить, было ли значение ранее
определено с помощью директивы #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код будет
проигнорирован. Например:

1 #define PRINT_JOE
2
3 #ifdef PRINT_JOE
4 std::cout << "Joe" << std::endl;
5 #endif
6
7 #ifdef PRINT_BOB
8 std::cout << "Bob" << std::endl;
9 #endif

Поскольку PRINT_JOE уже был определен, то строка std::cout << "Joe" << std::endl; скомпилируетсяи выполнится. А
поскольку PRINT_BOB не был определен, то строка std::cout << "Bob" << std::endl; не скомпилируется и,
следовательно, не выполнится.
Директива #ifndef (сокр. от «ifnotdefined» = «если неопределено») — это полная противоположность к #ifdef, которая
позволяет проверить, не было ли значение ранее определено. Например:

1 #ifndef PRINT_BOB
2 std::cout << "Bob" << std::endl;
3 #endif

Результатом выполнения этого фрагмента кода будет Bob, так как PRINT_BOB ранее никогда не был определен. Условная
компиляция очень часто используется в качестве headerguards (о них мы поговорим на следующем уроке).


Область видимости директивы #define

Директивы выполняются перед компиляцией программы: сверху вниз, файл за файлом. Рассмотрим следующую программу:

1 #include <iostream>
2
3 void boo()
4 {
5 #define MY_NAME "Alex"
6 }
7
8 int main()
9 {
10 std::cout<< "My nameis: "<< MY_NAME;
11
12 return 0;
13 }

Несмотря на то, что директива #define MY_NAME "Alex" определена внутри функции boo(), препроцессор этого не заметит,
так как онне понимает такие понятия языка C++, как функции. Следовательно, выполнение этой программы будет идентично
той, в которой бы #define MY_NAME "Alex" было определено ДО, либо сразу ПОСЛЕ функции boo(). Для лучшей читабельности
кода определяйте идентификаторы (с помощью #define) вне функций.
После того, как препроцессор завершит свое выполнение, все идентификаторы (определенные с помощью #define) из этого
файла — отбрасываются. Это означает, что директивы действительны только с точки определения и до конца файла, в котором
они определены. Директивы, определенныев одном файле кода, не влияют на директивы, определенные внутри других
файлов этого же проекта.
Рассмотрим следующий пример:

function.cpp:
1 #include <iostream>
2
3 void doSomething()
4 {
5 #ifdef PRINT
6 std::cout<< "Printing!";
7 #endif
8 #ifndef PRINT
9 std::cout<< "Not printing!";
10 #endif
11 }


main.cpp:
1 void doSomething();// предварительное объявлениефункции doSomething()
2
3 int main()
4 {
5 #define PRINT
6
7 doSomething();
8
9 return 0;
10 }

Результатвыполненияпрограммы:
Not printing!

Несмотря на то, что мы объявили PRINT в main.cpp ( #define PRINT ), это все равно не имеет никакого влияния на что-либо в
function.cpp. Поэтому, при выполнении функции doSomething(), у нас выводится Not printing!, так как в файле function.cpp
мы не объявляли идентификатор PRINT (с помощью директивы #define). Это связано с header guards.
