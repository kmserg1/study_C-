Урок No 155. Порядок построения дочерних классов

На предыдущем уроке мы узнали, что классы могут наследовать переменные-члены и методы от других классов. На этом уроке
мы рассмотрим порядок событий, которые выполняются при инициализации объектов дочернего класса.
Во-первых, вот 2 класса, которые будут помогать нам иллюстрировать важные моменты:

1 class Parent
2 {
3 public:
4 	int m_id;
5
6 	Parent(int id=0)
7 		: m_id(id)
8 	{
9 	}
10
11 	int getId() const { return m_id; }
12 };
13
14 class Child: public Parent
15 {
16 public:
17 	double m_value;
18
19 	Child(double value=0.0)
20 		: m_value(value)
21 	{
22 	}
23
24 	double getValue() const { return m_value; }
25 };

В этом примере класс Child является дочерним, а класс Parent — родительским:

 ┌───────────────────┐
 │     Parent:       │
 │    int m_id       │
 │   int getId()     │
 └────────┬──────────┘
┌─────────┴─────────────┐
│      Child:           │
│    double m_value     │
│   double getValue()   │
└───────────────────────┘

Поскольку Child наследует переменные-члены и методы класса Parent, то вы можете предположить, что члены класса Parent
копируются в класс Child, но это не так. Вместо этого рассматривайте Child как класс, который состоит из двух частей: первая —
Parent, вторая — Child.

Вы уже видели множество примеров того, что происходит при создании объектов обычного (не дочернего) класса:

1 int main()
2 {
3 	Parent parent;
4
5 	return 0;
6 }

Parent — это не дочерний класс, так как он не наследует свойства каких-либо других классов. C++ выделяет память для Parent,
затем вызывается конструктор по умолчанию класса Parent для выполнения инициализации.
Теперь рассмотрим, что происходит при создании объектов дочернего класса:

1 int main()
2 {
3 	Child child;
4
5 	return 0;
6 }

На первый взгляд всё вроде бы так же, как и в предыдущем примере, но «под капотом» всё несколько иначе. Как мы уже
говорили, класс Child состоит из двух частей: часть Parent и часть Child. Когда C++ создает объекты дочерних классов, то он
делает это поэтапно. Сначала создается самый верхний класс иерархии (тот, который родитель). Затем создается дочерний
класс, который идет следующим по порядку, и так до тех пор, пока не будет создан последний класс (тот, который находится в
самом низу иерархии).
Поэтому, при создании объекта класса Child, сначала создается часть Parent класса Child (с использованием конструктора по
умолчанию класса Parent) и после того, как с частью Parent покончено, создается вторая часть Child (с использованием
конструктора по умолчанию класса Child). В нашем примере больше нет дочерних классов, поэтому на этом всё и
заканчивается.

Этот процесс на самом деле легко проиллюстрировать:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	int m_id;
7
8 	Parent(int id=0)
9 		: m_id(id)
10 	{
11 		std::cout << "Parent\n";
12 	}
13
14 	int getId() const { return m_id; }
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	double m_value;
21
22 	Child(double value=0.0)
23 		: m_value(value)
24 	{
25 		std::cout << "Child\n";
26 	}
27
28 	double getValue() const { return m_value; }
29 };
30
31 int main()
32 {
33 	std::cout << "Instantiating Parent:\n";
34 	Parent dParent;
35
36 	std::cout << "Instantiating Child:\n";
37 	Child dChild;
38
39 	return 0;
40 }

Результат выполнения программы:
Instantiating Parent:
Parent
Instantiating Child:
Parent
Child

Как вы можете видеть, при создании Child сначала создается часть Parent класса Child. В этом есть смысл, так как по логике
вещей ребенок не может существовать без родителей. Это также способствует безопасности и эффективности выполнения
кода: дочерний класс часто использует переменные-члены и методы родителя, но родительский класс ничего не знает о своем
дочернем классе. Первоначальная инициализация родительского класса гарантирует, что его переменные-члены и методы
будут проинициализированы до момента использования их дочерним классом.


Порядок построения классов в цепочке наследования

Часто случаются ситуации, когда одни классы наследуют свойства других классов, которые, в свою очередь, наследуют
свойства своих предыдущих (родительских) классов. Например:

1 class A
2 {
3 public:
4 	A()
5 	{
6 		std::cout << "A\n";
7 	}
8 };
9
10 class B: public A
11 {
12 public:
13 	B()
14 	{
15 		std::cout << "B\n";
16 	}
17 };
18
19 class C: public B
20 {
21 public:
22 	C()
23 	{
24 		std::cout << "C\n";
25 	}
26 };
27
28 class D: public C
29 {
30 public:
31 	D()
32 	{
33 		std::cout << "D\n";
34 	}
35 };

Помните, что в C++ всегда идет построение с «первого» или «топового» класса иерархии. Затем C++ переходит к следующему
классу в иерархии и выполняет его построение. Этот процесс последовательный.
Проиллюстрируем порядок построения классов в цепочке наследования, приведенной выше:

1 int main()
2 {
3 	std::cout << "Constructing A: \n";
4 	A cA;
5
6 	std::cout << "Constructing B: \n";
7 	B cB;
8
9 	std::cout << "Constructing C: \n";
10 	C cC;
11
12 	std::cout << "Constructing D: \n";
13 	D cD;
14 }

Результат:
Constructing A:
A
Constructing B:
A
B
Constructing C:
A
B
C
Constructing D:
A
B
C
D

Заключение
Язык C++ выполняет построение дочерних классов поэтапно, начиная с верхнего класса иерархии и заканчивая нижним
классом иерархии. По мере построения каждого класса для выполнения инициализации вызывается соответствующий
конструктор соответствующего класса.
На следующем уроке мы рассмотрим роль конструкторов в процессе построения дочерних классов.
