Урок No175. Шаблоны классов


На предыдущих уроках мы узнали, как с помощью шаблонов функций сделать одну версию функции, которая будет
работать с разными типами данных. Хотя это значительный шаг на пути к обобщенному программированию, это не
решает всех наших проблем. Рассмотрим пример такой проблемы и то, как шаблоны могут нам помочьв её решении.

Оглавление:
1. Шаблоны и контейнерные классы
2. Шаблоны классов в Стандартной библиотеке С++
3. Шаблоны классов и Заголовочные файлы


Шаблоны и контейнерные классы

На уроке о контейнерных классах мы узнали то, как, используя композицию, реализовать классы, содержащие несколько
объектов определенного типа данных. В качестве примера мы использовали класс ArrayInt:

1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 #include <assert.h> // для assert()
5
6 class ArrayInt
7 {
8 private:
9 	int m_length;
10 	int *m_data;
11
12 public:
13 	ArrayInt()
14 	{
15 		m_length = 0;
16 		m_data = nullptr;
17 	}
18
19 	ArrayInt(int length)
20 	{
21 		assert(length > 0);
22 		m_data = new int[length];
23 		m_length = length;
24 	}
25
26 	~ArrayInt()
27 	{
28 		delete[] m_data;
29 	}
30
31 	void Erase()
32 	{
33 		delete[] m_data;
34 		// Присваиваем значение nullptr для m_data, чтобы на выходе не получить висячий указатель!
35 		m_data = nullptr;
36 		m_length = 0;
37 	}
38
39 	int& operator[](int index)
40 	{
41 		assert(index >= 0 && index < m_length);
42 		return m_data[index];
43 	}
44
45 	int getLength() { return m_length; }
46 };
47
48 #endif

Хотя этот класс обеспечивает простой способ создания массива целочисленных значений, но что, если нам нужно будет
работать со значениями типа double? Используя традиционные методы программированиямы создали бы новый класс
ArrayDouble для работы со значениями типа double:

1 #ifndef ARRAYDOUBLE_H
2 #define ARRAYDOUBLE_H
3
4 #include <assert.h> // для assert()
5
6 class ArrayDouble
7 {
8 private:
9 	int m_length;
10 	double *m_data;
11
12 public:
13 	ArrayDouble()
14 	{
15 		m_length = 0;
16 		m_data = nullptr;
17 	}
18
19 	ArrayDouble(int length)
20 	{
21 		assert(length > 0);
22 		m_data = new double[length];
23 		m_length = length;
24 	}
25
26 	~ArrayDouble()
27 	{
28 		delete[] m_data;
29 	}
30
31 	void Erase()
32 	{
33 		delete[] m_data;
34 		// Присваиваем значение nullptr для m_data, чтобы на выходе не получить висячий указатель!
35 		m_data = nullptr;
36 		m_length = 0;
37 	}
38
39 	double & operator[](int index)
40 	{
41 		assert(index >= 0 && index < m_length);
42 		return m_data[index];
43 	}
44
45 	int getLength() { return m_length; }
46 };
47
48 #endif

Хотя кода много, но классы почти идентичны, меняется только тип данных!
Каквы уже могли бы догадаться, это идеальный случай для использования шаблонов. 
Создание шаблона класса аналогично созданию шаблона функции. Например, создадим 
шаблон класса Array:

Array.h:
1 #ifndef ARRAY_H
2 #define ARRAY_H
3
4 #include <assert.h> // для assert()
5
6 template <class T> // это шаблон класса с T вместо фактического (передаваемого) типа данных
7 class Array
8 {
9 private:
10 	int m_length;
11 	T *m_data;
12
13 public:
14 	Array()
15 	{
16 		m_length = 0;
17 		m_data = nullptr;
18 	}
19
20 	Array(int length)
21 	{
22 		m_data = new T[length];
23 		m_length = length;
24 	}
25
26 	~Array()
27 	{
28 		delete[] m_data;
29 	}
30
31 	void Erase()
32 	{
33 		delete[] m_data;
34 		// Присваиваем значение nullptr для m_data, чтобы на выходе не получить висячий указатель!
35 		m_data = nullptr;
36 		m_length = 0;
37 	}
38
39
40 	T& operator[](int index)
41 	{
42 		assert(index >= 0 && index < m_length);
43 		return m_data[index];
44 	}
45
46 	// ,Длина массива всегда является целочисленным значением она не зависит от типа элементов массива
47 	int getLength(); // определяем метод и шаблон метода getLength() ниже
48 };
49
50 template <typename T> // метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
51 int Array<T>::getLength() { return m_length; } // обратите внимание, имя класса - Array<T>, а не просто Array
52
53 #endif

Как вы можете видеть, эта версия почти идентична версии ArrayInt, за исключением того, что мы добавили объявление
параметра шаблона класса и изменили тип данных c int на T.
Обратите внимание, мы определили функцию getLength() вне тела класса. Это необязательно, но новички обычно
спотыкаются на этом из-за синтаксиса. Каждый метод шаблона класса, объявленный вне тела класса, нуждается в
собственном объявлении шаблона. Также обратите внимание, что имя шаблона класса — Array<T> , а не Array(Array будет
указывать на не шаблонную версию класса Array).
Вот пример использования шаблона класса Array:

1 #include <iostream>
2 #include "Array.h"
3
4 int main()
5 {
6 	Array<int> intArray(10);
7 	Array<double> doubleArray(10);
8
9 	for (int count = 0; count < intArray.getLength(); ++count)
10 	{
11 		intArray[count] = count;
12 		doubleArray[count] = count + 0.5;
13 	}
14
15 	for (int count = intArray.getLength()-1; count >= 0; --count)
16 	std::cout << intArray[count] << "\t" << doubleArray[count] << '\n';
17
18 	return 0;
19 }

Результат:
9	9.5
8	8.5
7	7.5
6	6.5
5	5.5
4	4.5
3	3.5
2	2.5
1	1.5
0	0.5

Шаблоны классов работают точно также, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы
параметров шаблона класса на фактические (передаваемые) типы данных, аз атем компилирует эту копию. Если у вас есть
шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать.

Шаблоны классов идеально подходят для реализации контейнерных классов, так как очень часто таким классам
приходится работать с разными типами данных, а шаблоны позволяют это организовать в минимальном количестве кода.
Хотя синтаксис несколько уродлив, и сообщения об ошибках иногда могут быть «объемными», шаблоны классов
действительно являются одной из лучших и наиболее полезных конструкций языка C++.


Шаблоны классов в Стандартной библиотеке С++

Теперь вы уже поняли, чем на самом деле является std::vector<int>?
Правильно, std::vector — это шаблон класса, а int —это всего лишь передаваемый тип данных!
Стандартная библиотека С++ полна предопределенных шаблонов классов, доступных для вашего использования.


Шаблоны классов и Заголовочные файлы

Шаблон не является ни классом, ни функцией — это трафарет, используемый для создания классов или функций. Таким
образом, шаблоны работают не так, как обычные функции или классы. В большинстве случаев это не является проблемой,
но на практике случаются разные ситуации.

Работая с обычными классами мы помещаем определение класса в заголовочный файл, а определения методов этого
класса в отдельный файл .cpp с аналогичным именем. Таким образом, фактическое определение класса компилируется как
отдельный файл внутри проекта. Однако с шаблонами всё происходит несколько иначе (о том, почему следует помещать
определение методов класса в отдельный файл, читайте в материалах урока No 122). 
Рассмотрим следующее:

Array.h:
1 #ifndef ARRAY_H
2 #define ARRAY_H
3
4 #include <assert.h> // для assert()
5
6 template <class T>
7 class Array
8 {
9 private:
10 	int m_length;
11 	T *m_data;
12
13 public:
14 	Array()
15 	{
16 		m_length = 0;
17 		m_data = nullptr;
18 	}
19
20 	Array(int length)
21 	{
22 		m_data = new T[length];
23 		m_length = length;
24 	}
25
26 	~Array()
27 	{
28 		delete[] m_data;
29 	}
30
31 	void Erase()
32 	{
33 		delete[] m_data;
34 		// Присваиваем значение nullptr для m_data, чтобы на выходе не получить висячий указатель!
35 		m_data = nullptr;
36 		m_length = 0;
37 	}
38
39
40 	T& operator[](int index)
41 	{
42 		assert(index >= 0 && index < m_length);
43 		return m_data[index];
44 	}
45
46 	// Длина массива всегда является целочисленным значением, она не зависит от типа элементов массива
47 	int getLength();
48 };
49
50 #endif

Array.cpp:
1 #include "Array.h"
2
3 template <typename T>
4 int Array<T>::getLength() { return m_length; }

main.cpp:
1 #include "Array.h"
2
3 int main()
4 {
5 	Array<int> intArray(10);
6 	Array<double> doubleArray(10);
7
8 	for (int count = 0; count < intArray.getLength(); ++count)
9 	{
10 		intArray[count] = count;
11 		doubleArray[count] = count + 0.5;
12 	}
13
14 	for (int count = intArray.getLength()-1; count >= 0; --count)
15 	std::cout << intArray[count] << "\t" << doubleArray[count] << '\n';
16
17 	return 0;
18 }

Вышеприведенная программа скомпилируется, но вызовет следующую ошибку линкера:
unresolved external symbol "public: int __thiscall Array::getLength(void)" (?GetLength@?
$Array@H@@QAEHXZ)
Почему так? Сейчас разберемся.

Для использования шаблона компилятор должен видеть как определение шаблона (а не только объявление),так и тип
шаблона, применяемый для создания экземпляра шаблона. Помним, что язык C++ компилирует файлы по отдельности.
Когда заголовочный файл Array.h подключается в main.cpp, то определение шаблона класса копируется в этот файл.
В main.cpp компилятор видит, что нам нужны два экземпляра шаблона класса: Array<int> и Array<double> , он создаст их,
а затем скомпилирует весь этот код как часть файла main.cpp. 
Однако, когда дело дойдет до компиляции Array.cpp (отдельным файлом), компилятор забудет, что мы использовали 
Array<int> и Array<double> в main.cpp и не создаст экземпляр шаблона функции getLength(), который нам нужен для 
выполнения программы. Мы получим ошибку линкера, так как компилятор не сможет найти определение Array<int>::getLength() 
или Array<double>::getLength().

Эту проблемуможно решить несколькими способами.
Самый простой вариант — поместить код из Array.cpp в Array.h ниже класса. Таким образом, когда мы будем подключать
Array.h, весь код шаблона класса (полное объявление и определение как класса, так и его методов) будет находиться в
одном месте. 
Плюс этого способа — простота. 
Минус — если шаблон класса используется во многих местах, то мы получим много локальных копий шаблона класса,
чтоувеличит время компиляции и линкинга файлов (линкер должен будет удалить дублирование определений класса и методов, 
дабы исполняемый файл не был «слишком раздутым»). 

Рекомендуется использовать эторешение до тех пор, пока время компиляции или линкинга не является проблемой.

Если вы считаете, что размещение кода из Array.cpp в Array.h сделает Array.h слишком большим/беспорядочным, то
альтернативой будет переименование Array.cpp в Array.inl (.inl от англ. «inline» =«встроенный»), а затем подключение
Array.inl из нижней части файла Array.h. Это даст тот же результат, что и размещение всего кода в заголовочном файле, но
таким образом код получится немного чище.

Есть еще решение — подключение файлов.cpp, но этот вариант не рекомендуется использовать из-за нестандартного
применения директивы #include.

Еще один альтернативный вариант — использовать подход трех файлов:
 Определение шаблона класса хранится в заголовочномфайле
 Определения методов шаблона класса хранятся в отдельном файле .cpp.
 Затем добавляем третий файл, который содержит все необходимыенам экземпляры шаблона класса.

Например, templates.cpp:
1 // Таким образом, мы гарантируем, что компилятор увидит полное определение шаблона класса Array
2 #include "Array.h"
3 #include "Array.cpp" // мы нарушаем правила хорошего тона в программировании, но только в этом месте
4
5 // Здесь вы #include (включаете) другие файлы .h и .cpp с определениями шаблонов, которые вам нужны
6
7 template class Array<int>; // явно создаем экземпляр шаблона класса Array<int>
8 template class Array<double>; // явно создаем экземпляр шаблона класса Array<double>
9
10 // Здесь вы явно создаете другие экземпляры шаблонов, которые вам нужны

Часть template class заставит компилятор явно создать указанные экземпляры шаблона класса. В примере,
приведенном выше, компилятор создаст Array<int> и Array<double> внутри templates.cpp. Поскольку templates.cpp
находится внутри нашего проекта, то он скомпилируется и удачно свяжется с другими файлами (пройдет линкинг).
Этот метод более эффективен, но требует создания/поддержки третьего файла (templates.cpp) длякаждой из ваших
программ (проектов) отдельно.
