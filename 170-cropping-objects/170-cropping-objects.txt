Урок No170. Обрезка объектов

На этом уроке мы рассмотрим, что такое обрезка объектов в языке С++, как она используется и какие есть нюансы.

Оглавление:
1. Обрезка объектов
2. Обрезка объектов и функции
3. Обрезка векторов
4. Заключение


Обрезка объектов

Вернемся к примеру с классами Parent и Child:

1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		: m_value(value)
11 	{
12 	}
13
14 	virtual const char* getName() const { return "Parent"; }
15 	int getValue() const { return m_value; }
16 };
17
18 class Child: public Parent
19 {
20 public:
21 	Child(int value)
22 		: Parent(value)
23 	{
24 	}
25
26 	virtual const char* getName() const { return "Child"; }
27 };
28
29 int main()
30 {
31 	Child child(7);
32 	std::cout << "child is a " << child.getName() << " and has value " << child.getValue() << '\n';
33
34 	Parent &ref = child;
35 	std::cout << "ref is a " << ref.getName() << " and has value " << ref.getValue() << '\n';
36
37 	Parent *ptr = &child;
38 	std::cout << "ptr is a " << ptr->getName() << " and has value " << ptr->getValue() << '\n';
39
40 	return 0;
41 }

Здесь ссылка ref и указатель ptr ссылаются/указывают на объект child, который имеет как часть Parent, так и часть Child.
Поскольку ref и ptr являются типа Parent, то они могут видеть часть Parent объекта child. Часть Child объекта child
существует на протяжении всего времени жизни объекта, но доступ к ней для ref или ptr — закрыт. Однако, используя
виртуальные функции, мы получаем доступ к наиболее дочернему методу.

Следовательно, результат выполнения программы:
child is a Child and has value 7
ref is a Child and has value 7
ptr is a Child and has value 7

Но что бы произошло, если бы мы, вместо создания ссылки или указателя класса Parent на объект класса Child, просто
присвоили бы объект класса Child объекту класса Parent?

1 int main()
2 {
3 	Child child(7);
4 	Parent parent = child; // что произойдет здесь ?
5 	std::cout << "parent is a " << parent.getName() << " and has value " << parent.getValue() << '\n';
6
7 	return 0;
8 }

Помните,что child имеет как часть Parent, так и часть Child. Когда мы присваиваем объект класса Child объекту класса Parent,
то копируется только часть Parent, часть Child не копируется. В примере, приведенном выше, parent получает копию части
Parent объекта child , а часть Child объекта child «обрезается». Это называется обрезкой объектов (или просто «обрезкой»).
Посколькупеременная parent неимеет части Child, то parent.getName() вызывает Parent::getName().

Результат :
parent is a Parent and has value 7


Обрезка объектов и функции

Сейчас вы можете подумать, что выше приведенный пример нелепый. В конце концов, зачем нам присваиватьо бъект child
объекту parent таким образом? Повторять это, скорее всего, вы не будете. Однако обрезка объектов довольно-таки нередко
случается с функциями. Например:

1 void printName(const Parent parent) // примечание: Передача по значению
2 {
3 	std::cout << "I am a " << parent.getName() << '\n';
4 }

Это простая функция с константным объектом parent в качестве параметра, который передается по значению. Если мы
будем вызывать эту функцию следующим образом:

1 int main()
2 {
3 	Child ch(7);
4 	printName(ch); // упс, передача по значению
5
6 	return 0;
7 }

То получим:
I am a Parent

Вы, наверное, не заметили, что parent является параметром-значением, а не параметром-ссылкой. При выполнении
printName(ch), вы, наверное, ожидали, что parent.getName() вызовет переопределение getName(), которое выведет 
"I am a Child , но это не так. 
Вместо этого объект ch класса Child обрезается, и только часть Parent копируется в передаваемый
параметр parent. При выполнении parent.getName(), не смотря на то, что функция getName() является виртуальной, для нее
не существует части Child. Следовательно, получили то, что получили.
В этом случае всё довольно очевидно по тому, что выводится на экран. Но если у вас есть функции, которые ничего не выводят
на экран, то отследить такую ошибку будет уже проблематично.
Конечно, обрезки здесь можно было бы легко избежать, используя передачу по ссылке вместо передачи по значению (вот
еще одна причина, по которой передача классов по ссылке вместо передачи по значению является хорошей идеей):

1 void printName(const Parent &parent) // примечание: Передача по ссылке
2 {
3 	std::cout << "I am a " << parent.getName() << '\n';
4 }
5
6 int main()
7 {
8 	Child ch(7);
9 	printName(ch);
10
11 	return 0;
12 }

Результат:
I am a Child


Обрезка векторов

Еще одна ошибка, с которой сталкиваются новички при работе с обрезкой, заключается в попытке реализовать полиморфизм,
используя std::vector. Добавим к нашей программе следующий код:

1 #include <vector>
2
3 int main()
4 {
5 	std::vector<Parent> v;
6 	v.push_back(Parent(7)); // добавляем объект класса Parent в наш вектор
7 	v.push_back(Child(8)); // добавляем объект класса Child в наш вектор
8
9 	// Выводим все элементы нашего вектора
10 	for (int count = 0; count < v.size(); ++count)
11 		std::cout << "I am a " << v[count].getName() << " with value " << v[count].getValue() << "\n";
12
13 	return 0;
14 }

Результат выполненияпрограммы:
I am a Parent with value 7
I am a Parent with value 8

Поскольку std::vector былобъявлен как вектор класса Parent, то при добавлении к нему Child(8) выполнилась обрезка
объекта.
Исправить это немного сложнее. Новички пытаются сделать вектор с ссылками на объекты, например:
1 std::vector<Parent&> v;

К сожалению, это не сработает. Элементы std::vector должны быть объектами, которым можно переприсваивать значения,
тогда как ссылки могут быть инициализированы только раз и переприсваивать им значения нельзя.
Одним из способов решения этой проблемы является создание вектора с указателями на объекты:

1 #include <vector>
2
3 int main()
4 {
5 	std::vector<Parent*> v;
6 	v.push_back(new Parent(7)); // добавляем объект класса Parent в наш вектор
7 	v.push_back(new Child(8)); // добавляем объект класса Child в наш вектор
8
9 	// Выводим все элементы нашего вектора
10 	for (int count = 0; count < v.size(); ++count)
11 		std::cout << "I am a " << v[count]->getName() << " with value " << v[count]->getValue() << "\n";
12
13 	for (int count = 0; count < v.size(); ++count)
14 	delete v[count];
15
16 	return 0;
17 }

Результат выполненияпрограммы:
I am a Parent with value 7
I am a Child with value 8

Работает! Но это боль, так как теперь нам придется иметь дело с динамическим выделением памяти.
К счастью, есть еще один способ решения этой проблемы. Стандартная библиотека C++ предоставляет класс
std::reference_wrapper. По сути, std::reference_wrapper — это класс, который работает как ссылка, но позволяет выполнять
операции присваивания и копирования и совместим с std::vector.
Хорошая новость заключается в том, что вам не нужно знать, как он реализован для того, чтобы его использовать. Всё, что вам
нужно знать:
 std::reference_wrapper находится в заголовочном файле functional.
 При создании объекта класса std::reference_wrapper, этот объект не может быть анонимным (поскольку анонимные
объекты имеют область видимости выражения, что может привести к висячей ссылке).
 Для получения объекта из std::reference_wrapper используется метод get().

Перепишем наш код, добавив std::reference_wrapper:

1 #include <vector>
2 #include <functional> // для std::reference_wrapper
3
4 int main()
5 {
6 	std::vector<std::reference_wrapper<Parent> > v;
7 	Parent p(7); // p и ch не могут быть анонимными объектами
8 	Child ch(8);
9 	v.push_back(p); // добавляем объект класса Parent в наш вектор
10 	v.push_back(ch); // добавляем объект класса Child в наш вектор
11
12 	// Выводим все элементы нашего вектора
13 	for (int count = 0; count < v.size(); ++count)
14 		std::cout << "I am a " << v[count].get().getName() << " with value " << v[count].get().getValue() << "\n"; // используе
15
16
17 	return 0;
18 }

Результат выполненияпрограммы:
I am a Parent with value 7
I am a Child with value 8

Всё отлично, и нам не нужно заморачиваться с динамическим выделением памяти.


Заключение

Хотя язык C++ поддерживает присваивание объектов дочерних классов объектам родительского класса посредством обрезки
объектов, это приносит больше боли, нежели пользы, поэтому рекомендуется избегать случаев с выполнением обрезки
объектов. Когда дело доходит до работы с дочерними классами, всегда перепроверяйте параметры своих функций, чтобы ни в
коем случае не выполнялась передача по значению.
