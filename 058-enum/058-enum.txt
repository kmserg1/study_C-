Урок No 58. Перечисления


Язык C++ позволяет программистам создавать свои собственные (пользовательские) типы данных

Оглавление:
1. Перечисляемые типы
2. Имена перечислений
3. Значения перечислителей
4. Обработка перечислений
5. Вывод перечислителей
6. Выделение памяти для перечислений
7. Польза от перечислений
8. Тест


Перечисляемыетипы

Перечисление (или «перечисляемый тип») — это тип данных, в котором любое значение
(или «перечислитель») определяется как символьная константа.
Объявить перечисление можно с помощью ключевого слова enum. Например:

1 // Объявляем новое перечисление Colors
2 enum Colors
3 {
4 // Ниже находятся перечислители - все возможные значения этого типа данных.
5 // Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
6 COLOR_RED,
7 COLOR_BROWN,
8 COLOR_GRAY,
9 COLOR_WHITE,
10 COLOR_PINK,
11 COLOR_ORANGE,
12 COLOR_BLUE,
13 COLOR_PURPLE, // о конечной запятой читайте ниже
14 }; // однако сам enum должен заканчиваться точкой с запятой
15
16 // Определяем несколько переменных перечисляемого типаColors
17 Colors paint = COLOR_RED;
18 Colors house(COLOR_GRAY);

Объявление перечислений не требует выделения памяти. 
Только когда переменная перечисляемого типа определена (например, как переменная paint в примере,
приведенном выше), только тогда выделяется память дляэтой переменной.

Обратите внимание, каждый перечислитель отделяется запятой, а само перечисление заканчивается точкой с запятой.

Примечание: До C++11, конечная запятая после последнего перечислителя (как после COLOR_PURPLE в примере,
приведенном выше) не разрешается (хотя многие компиляторы её все равно принимают). Однако, начинаяс C++11
конечная запятая разрешена.


Имена перечислений

Идентификаторы перечислений часто начинаются с заглавной буквы, а имена перечислителей вообще состоят только из
заглавных букв. Поскольку перечислители вместе с перечислением находятся в едином пространстве имен, то имена
перечислителей не могут повторяться в разных перечислениях:

1 enumColors
2 {
3 YELLOW,
4 BLACK, // BLACK находится в глобальном пространстве имен
5 PINK
6 };
7
8 enum Feelings
9 {
10 SAD,
11 ANGRY,
12 BLACK // получим ошибку, так как BLACK уже используется в enumColors
13 };

Распространено добавление названия перечисленияв качестве префикса к перечислителям, например: ANIMAL_ или COLOR_,
как для предотвращения конфликтовимен, так и в целях комментирования кода.


Значения перечислителей

Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке
перечисления. По умолчанию, первому перечислителю присваивается целое число 0, а каждому следующему — на единицу
больше, чем предыдущему:

1 #include <iostream>
2
3 enum Colors
4 {
5 COLOR_YELLOW, 	// присваивается 0
6 COLOR_WHITE, 		// присваивается 1
7 COLOR_ORANGE, 	// присваивается 2
8 COLOR_GREEN, 		// присваивается 3
9 COLOR_RED, 		// присваивается 4
10 COLOR_GRAY, 		// присваивается 5
11 COLOR_PURPLE, 	// присваивается 6
12 COLOR_BROWN 		// присваивается 7
13 };
14
15 int main()
16 {
17 Colors paint(COLOR_RED)
18 std::cout << paint
19
20 return 0;
21 }

Результат выполнения программы:
4

Можно и самому определять значения перечислителей. Они могут быть как положительными, так и отрицательными, или
вообще иметь аналогичные другим перечислителям значения.
Любые, не определенные вами перечислители, будут иметь значения на единицу больше, чем значения предыдущих перечислителей.
Например:

1 // Определяемновый перечисляемый тип Animals
2 enum Animals
3 {
4  ANIMAL_PIG =-4,
5  ANIMAL_LION,		//присваивается-3
6  ANIMAL_CAT, 		// присваивается -2
7  ANIMAL_HORSE = 6,
8  ANIMAL_ZEBRA = 6, 	// имееттожезначение, что и ANIMAL_HORSE
9  ANIMAL_COW		// присваивается 7
10 };

Обратите внимание, ANIMAL_HORSE и ANIMAL_ZEBRA имеют одинаковые значения. Хотя C++ это не запрещает, 
присваивать одно значение нескольким перечислителям в одном перечислении не рекомендуется.

Совет: Не присваивайте свои значения перечислителям.

Правило: Неприсваивайте одинаковые значения двум перечислителям в одном перечислении, если на это нет
веской причины.


Обработка перечислений

Поскольку значениями перечислителей являются целые числа, то их можно присваивать целочисленным переменным, а также
выводить в консоль (как переменные типа int):

1 #include <iostream>
2
3 // Определяем новый перечисляемый тип Animals
4 enum Animals
5 {
6  ANIMAL_PIG =-4,
7  ANIMAL_LION,//присваивается-3
8  ANIMAL_CAT, // присваивается -2
9  ANIMAL_HORSE= 6,
10 ANIMAL_ZEBRA= 6, // имееттоже значение, что и ANIMAL_HORSE
11 ANIMAL_COW // присваивается 7
12 };
13
14 int main()
15 {
16 int mypet = ANIMAL_PIG;
17 std::cout << ANIMAL_HORSE; // конвертируется в int, а затем выводится на экран
18
19 return 0;
20 }

Результат выполнения программы:
6

Компилятор не будет неявно конвертировать целочисленное значение в значение перечислителя. Следующее вызовет
ошибку компиляции:
1 Animals animal= 7; // приведет к ошибке компиляции

Тем не менее, вы можете сделать подобное с помощью оператора static_cast:
1 Colors color = static_cast<Colors>(5); //  но делать так не рекомендуется

Компилятор также не позволит вам вводить перечислители через std::cin:

1 #include <iostream>
2
3 enum Colors
4 {
5 COLOR_PURPLE, // присваивается 0
6 COLOR_GRAY, // присваивается 1
7 COLOR_BLUE, // присваивается 2
8 COLOR_GREEN, // присваивается 3
9 COLOR_BROWN, // присваивается 4
10 COLOR_PINK, // присваивается 5
11 COLOR_YELLOW, // присваивается 6
12 COLOR_MAGENTA // присваивается 7
13 };
14
15 int main()
16 {
17 Colors color;
18 std::cin >> color; //приведет кошибке компиляции
19
20 return 0;
21 }

Однако, вы можете ввести целое число, а затем использовать оператор static_cast, чтобы поместить целочисленное значение в
перечисляемый тип:

1 int inputColor;
2 std::cin>>inputColor;
3
4 Colors color = static_cast<Colors>(inputColor);

Каждый перечисляемый тип считается отдельным типом. Следовательно, попытка присвоить перечислитель из одного
перечисления перечислителю из другого — вызовет ошибку компиляции:

1 Animals animal= COLOR_BLUE; // приведет к ошибке компиляции

Как и в случае с константами, перечисления отображаются в отладчике,что делает их еще более полезными.


Вывод перечислителей

Попытка вывести перечисляемое значение с помощью std::cout приведет к выводу целочисленного значения самого
перечислителя (т.е. его порядкового номера). Но как вывести значение перечислителя в виде текста?
Одиниз способов — написать функцию с использованием стейтментов if:

1 enum Colors
2 {
4 COLOR_GRAY, // присваивается 1
3 COLOR_PURPLE, // присваивается 0
5 COLOR_BLUE, // присваивается 2
6 COLOR_GREEN, // присваивается 3
7 COLOR_BROWN, // присваивается 4
8 COLOR_PINK, // присваивается 5
9 COLOR_YELLOW, // присваивается 6
10 COLOR_MAGENTA // присваивается 7
11 };
12
13 voidprintColor(Colorscolor)
14 {
15 if (color==COLOR_PURPLE)
16 	std::cout << "Purple";
17 else if (color == COLOR_GRAY)
18 	std::cout << "Gray"
19 else if (color == COLOR_BLUE)
20 	std::cout << "Blue"
21 else if (color == COLOR_GREEN)
22 	std::cout << "Green";
23 else if (color == COLOR_BROWN)
24 	std::cout << "Brown";
25 else if (color == COLOR_PINK)
26 	std::cout << "Pink"
27 else if (color == COLOR_YELLOW)
28 	std::cout << "Yellow";
29 else if (color == COLOR_MAGENTA)
30 	std::cout << "Magenta";
31 else
32 	std::cout << "Who knows!";
33 }


Выделение памяти для перечислений

Перечисляемые типы считаются частью семейства целочисленных типов, и компилятор сам определяет, сколько памяти
выделять для переменныхтипа enum. По стандарту C++ размер перечисления должен быть достаточно большим, чтобы иметь
возможность вместить все перечислители. Но чаще всего размеры переменных enum будут такими же, как и размеры обычных
переменных типа int.
Поскольку компилятору нужно знать, сколько памяти выделять для перечисления, то использовать предварительное
объявление с ним вы не сможете. Однако существует простой обходной путь. Поскольку определение перечисления само по
себе не требует выделения памятии, если перечисление необходимо использовать в нескольких файлах, его можно
определить в заголовочном файле и подключать этот файл везде, где необходимо использовать перечисление.


Польза от перечислений

Перечисляемые типы невероятно полезны для документации кода и улучшения читабельности.
Например, функции часто возвращают целые числа обратно в caller в качестве кодов ошибок, если что-топошло не так. 
Как правило, небольшие отрицательные числа используются для представления возможных кодов ошибок. 
Например:

1 int readFileContents()
2 {
3 if (!openFile())
4	 return -1;
5 if (!parseFile())
6	 return -2;
7 if (!readFile())
8	 return -3;
9
10 return 0; // если всё прошло успешно
11 }

Однако магические числа, как в вышеприведенном примере, не очень эффективное решение. 
Альтернатива — использовать перечисления:

1 enum ParseResult
2 {
3 SUCCESS = 0,
4 ERROR_OPENING_FILE = -1,
5 ERROR_PARSING_FILE = -2,
6 ERROR_READING_FILE = -3
7 };
8
9 ParseResult readFileContents()
10 {
11 if (!openFile())
12 return ERROR_OPENING_FILE;
13 if (!parseFile())
14 	return ERROR_PARSING_FILE;
15 if (!readfile())
16 	return ERROR_READING_FILE;
17
18 return SUCCESS; // если всё прошло успешно
19 }

Это и читать легче, и понять проще. Кроме того, функция, которая вызывает другую функцию,
может проверить возвращаемое значение на соответствующий перечислитель.
Это лучше, нежели самому сравнивать возвращаемый результат с конкретными
целочисленными значениями, чтобы понять какая именно ошибка произошла, не так ли? 
Например:
1 if(readFileContents() == SUCCESS)
2 	{
3 	// Делаем что-нибудь
4 	}
5 else
6 	{
7 	// Выводимсообщение об ошибке
8 	}

Перечисляемые типы лучше всего использовать при определении набора связанных идентификаторов.
Например, предположим, что вы пишете игру, в которой игрок может иметь один предмет, но этот 
предмет может быть нескольких разных типов:
1 #include <iostream>
2 #include <string>
3
4 enum ItemType
5 {
6 ITEMTYPE_GUN,
7 ITEMTYPE_ARBALET,
8 ITEMTYPE_SWORD
9 };
10
11 std::string getItemName(ItemType itemType)
12 {
13 if (itemType==ITEMTYPE_GUN)
14 return std::string("Gun");
15 if (itemType==ITEMTYPE_ARBALET)
16 return std::string("Arbalet");
17 if (itemType==ITEMTYPE_SWORD)
18 return std::string("Sword");
19 }
20
21 int main()
22 {
23 // ItemType - это перечисляемый тип, который мы объявили выше.
24 // itemType (с маленькой i) -это имя переменной, которую мы определяем ниже (типа ItemType).
26 ItemType itemType(ITEMTYPE_GUN);
25 // ITEMTYPE_GUN- это значение перечислителя, которое мы присваиваем переменной itemType
27
28 std::cout<<"You are carrying a " << getItemName(itemType) << "\n";
29
30 return 0;
31 }

Или, если вы пишете функцию для сортировки группы значений:

1 enum SortType
2 {
3 SORTTYPE_FORWARD,
4 SORTTYPE_BACKWARDS
5 };
6
7 void sortData(SortType type)
8 {
9 if (type == SORTTYPE_FORWARD)
10 	// Сортировка данных в одном порядке
11 else if (type == SORTTYPE_BACKWARDS)
12	 // Сортировка данных вобратномпорядке
13 }

Многие языки программирования используют перечисления для определения логических значений. 
По сути, логический тип данных — это простое перечисление всего лишь с двумя перечислителями: true и false!
Однаков языке C++ значения true и false определены как ключевые слова вместо перечислителей.

Тест

Задание No 1
Напишите перечисление со следующими перечислителями: ogre, goblin, skeleton, orc и troll
enum Item
	{
	ogre, 
	goblin, 
	skeleton, 
	orc,
	troll
	};
Нефатальная ошибка - перечисли желательно объявлять большими буквами и перед значениями указывать ИмяПеречисления_

Ответ No 1

enum MonsterType
{
    MONSTER_OGRE,
    MONSTER_GOBLIN,
    MONSTER_SKELETON,
    MONSTER_ORC,
    MONSTER_TROLL
};


Задание No 2

Объявите переменную перечисляемого типа, который вы определили в задании No 1, и присвойте ей значение ogre.
Item protivnik(ogre);

Ответ No2
MonsterType eMonsterType = MONSTER_OGRE;

Задание No 3
Ответьте Правда или ложь:

Перечислителям можно:
 присваивать целочисленные значения; - 
 не присваивать значения; +
 явно присваивать значениятипа с плавающей точкой; -
 присваивать значения предыдущих перечислителей (например, COLOR_BLUE = COLOR_GRAY). +

Перечислители могут быть:
 отрицательными; +
 неуникальными. +

Ответ No 3
Перечислителям можно:
   Правда.
   Правда. Перечислителю без значения будет неявно присвоено целочисленное значение предыдущего перечислителя +1. Если предыдущего перечислителя нет, то тогда присвоится значение 0.
   Ложь.
   Правда. Поскольку значениями перечислителей являются целые числа, а целые числа можно присвоить перечислителям, то одни перечислители могут быть присвоены другим перечислителям (хотя этого лучше избегать).

Перечислители могут быть:
   Правда.
   Правда.

