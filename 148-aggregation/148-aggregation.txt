Урок No148. Агрегация


На уроке о композиции мы говорили, что композиция объекта — это процесс создания сложных объектов из более простых.
Мы также говорили о подтипе композиции объектов — композиции. В отношениях внутри композиции целое (класс) несет
ответственность засуществование частей (членов).
Наэтомурокемы рассмотрим второй подтипкомпозиции объекта — агрегацию.

Оглавление:
1. Агрегация
2. Реализация агрегации
3. Выбирайте правильные отношения
4. Композиция и агрегация
5. Тест


Агрегация

Для реализации агрегации целое и его части должны соответствовать следующим отношениям:

 Часть (член) является частью целого (класса).
 Часть (член) может принадлежать более чем одному целому (классу) в моменте.
 Часть (член) существует, не управляемая целым (классом).
 Часть (член) не знает о существован ии целого (класса).

Как и в случае с подтипомк омпозиция, отношения в агрегации также являются отношениями части-целого и
однонаправленные. Однако, в отличие от композиции, части могут принадлежать более чем одному целому в моменте, и
целое не управляет существованием и продолжительностью жизни частей. При создании/уничтожении агрегации, целое не
несет ответственности за создание/уничтожение своих частей.

Например, рассмотрим отношения между человеком и его домашним адресом. У каждого человека есть свойадрес. Однако
этот адрес может принадлежать более чем одному человеку в моменте, например, вам и вашему соседу по комнате или
родственникам, которые живут вместе с вами. К тому же этот адрес не управляется человеком — адрес существовал до того,
как человек заселился и будет существовать после того, как человек выселится. Кроме того, человек знает, по какому адресу он
живет, но адрес, в свою очередь, не знает, что это за человек и вообще,сколько их там находится. Такие отношения и
являются агрегацией.

В качестве альтернативы рассмотрим автомобиль и двигатель. Двигатель является частью автомобиля. И хотя двигатель
принадлежит автомобилю, он может принадлежать и другим объектам, например, человеку, которому принадлежит
автомобиль. Автомобиль не несет ответственности за создание или уничтожение двигателя. И в то же время автомобиль
знает, что у него есть двигатель (ведь благодаряему он двигается), но сам двигатель не знает, что онявляется частью
автомобиля.

Когда дело доходит до моделирования физических объектов, использование термина «уничтожение» может быть немного
расплывчатым. Возникает вопрос: «Еслибы метеорит упал с неба и раздавил машину, то можно ли считать, что и все части
машины также были бы уничтожены?». Да, конечно. Но это вина метеорита, а не автомобиля. Важным моментом является то,
что автомобиль не несет ответственности за уничтожение своих частей (но есть и внешняя сила, которая может этому
поспособствовать).

Мы можем сказать, что типом отношений в агрегации является «имеет» (отдел «имеет» работников, автомобиль «имеет»
двигатель).
Подобно композиции, части агрегации могут быть сингулярными или мультипликативными.


Реализация агрегации

Поскольку агрегация подобна композиции, так как обе состоят из отношений части-целого, то они реализуются почти
одинаково, а разница между ними в основном семантическая. 
В композиции мы добавляем части к целому, используя обычные переменные-члены (или указатели, когда в классе происходит 
динамическое выделение/освобождение памяти).
В агрегации мы также добавляем части к целому, используя переменные-члены. Однако этими переменными-членами обычно
являются либо ссылки, либо указатели, которые указывают на объекты, созданные за пределами класса. Следовательно,
агрегация принимает части, на которые она будет указывать, в качестве параметров конструктора или, если параметров нет,
части добавляются позже через функции доступа или через перегруженные операторы.

Поскольку эти части существуют вне области видимости класса, то при уничтожении класса, переменные-члены в виде ссылок
или указателей также уничтожаются (но не удаляются значения, на которыеони указывают). Следовательно, сами части
продолжают существовать дальше.

Рассмотрим пример Работника и Отдела детально. Чтобы было проще, в Отделе работает только один Работник и он не знает,
Работником какого именно Отдела он является:

1 #include <iostream>
2 #include <string>
3
4 class Worker
5 {
6 private:
7 	std::string m_name;
8
9 public:
10 	Worker(std::string name)
11 		: m_name(name)
12 	{
13 	}
14
15 	std::string getName() { return m_name; }
16 };
17
18 class Department
19 {
20 private:
21 	Worker *m_worker; // чтобы было проще, в этом Отделе работает только один Работник, но их может быть и несколько
22
23 public:
24 	Department(Worker *worker = nullptr)
25 		: m_worker(worker)
26 	{
27 	}
28 };
29
30 int main()
31 {
32 	// СоздаемРаботника вне области видимости класса Department
33 	Worker *worker = new Worker("Anton"); //создаем Работника
34 	{
35 		// Создаем Отдел и передаем Работника в Отдел через параметр конструктора
36 		Department department(worker);
37
38 	} // department выходит из области видимости и уничтожается здесь
39
40 	// worker продолжает существовать дальше
41
42 	std::cout << worker->getName() << " still exists!";
43
44 	delete worker;
45
46 	return 0;
47 }

Здесь Работник создается независимо от Отдела, а затем переходит в параметр конструктора класса Отдела. Когда
department уничтожается, то указатель m_worker уничтожается также, но сам Работник то не удаляется, онп родолжает
существовать до тех пор, пока не будет уничтожен в функции main().


Выбирайте правильные отношения

Хотя в вышеприведенном примере может показаться немного глупым, что Работник не знает, в каком Отделе он работает, но
это совершенно нормально в контексте данной программы. Когда вы определяете тип отношений для реализации, внедряйте
самые простые и понятные отношения, которые соответствуют вашим потребностям, а не те, которые, как вам кажется,
подойдут лучше всего, но они сложнее и навороченнее.

Например, если вы создаете симулятор ремонта автомобилей, то вы можете захотеть реализовать автомобиль и двигатель
через агрегацию, чтобы двигатель можно было вынуть и отдельно в нем разобраться. Однако, если выпишете гоночный
симулятор, вы можете захотеть реализовать автомобиль и двигатель через композицию, поскольку в гонке двигателю
существовать отдельно от автомобиля никак нельзя.

Правило: Реализовывайте самые простые отношения, которые соответствуют потребностям вашей программы, а не
то, что, как вам кажется, будет лучше.


Композиция и агрегация

В композиции:
 Используются обычные переменные-члены.
 Используются указатели, если класс реализовывает собственное управление памятью (происходит динамическое
выделение/освобождение памяти).
 Класс ответственен за создание/уничтожение своих частей.

В агрегации:
 Используются указатели/ссылки, которые указывают/ссылаются на части вне класса.
 Класс не несет ответственности за создание/уничтожение своих частей.

Стоит отметить, что идеи композиции и агрегации не являются взаимоисключающими и могут свободно использоваться в
одном классе. Вполне возможно реализовать класс, которыйо твечает за создание/уничтожение только определенных частей.
Например, наш класс Department могбы иметь и Имя, и Работника. Имя было бы добавлено в класс через композицию и
создавалось/уничтожалось бы вместе с объектами класса Department. А Работник был бы добавлен в Department через
агрегацию и создавался/уничтожался бы независимо/отдельно.

Хотя агрегации могут быть чрезвычайно полезными, они также потенциально опасны. Поскольку в агрегации автоматически
не осуществляется освобождение памяти, которую могут заниматьчасти, то это должны контролировать вы сами. Если вы
забыли выполнить очистку (освободить память), думая, что это должен сделать класс, то тогда произойдет утечка памяти,
поэтому следуетбыть осторожным.

Примечание: По разным историческим и другим причинам, в отличие от композиции, определение агрегации не является
единственно правильным — вы можете увидеть, что другие ресурсы / сайты / учебники определяют агрегацию несколько
иначе, нежели изложено здесь. Это нормально, просто знайте об этом.


Тест

Задание No 1
Что бы вы использовали (агрегацию или композицию) для создания следующих объектов? 
Список создаваемых объектов:
 Красный шар. - Композиция
 Работодатель, который нанимает людей. - Агрегация
 Факультет в университете. - Композиция
 Ваш возраст.- Композиция
 Мешок с шариками. - Агрегация

Ответ No 1

    Композиция: Цвет является неотъемлемым свойством шара.
    Агрегация: Работодатель в начале не имеет никаких работников и, надеемся, не уничтожит всех своих сотрудников, когда обанкротится.
    Композиция: Факультеты не могут существовать отдельно от университета.
    Композиция: Ваш возраст является неотъемлемым Вашим свойством.
    Агрегация: Мешок и шарики внутри являются независимыми объектами и могут существовать отдельно.


Задание No 2
Обновите вышеприведенный пример с Работником/Отделом так, чтобы Отдел мог состоять из нескольких Работников.

Следующий код:
1 #include <iostream>
2
3 int main()
4 {
5 	// Создаем Работников вне области видимости класса Department
6 	Worker *w1= new Worker("Anton");
7 	Worker *w2= new Worker("Ivan");
8 	Worker *w3= new Worker("Max");
9
10 	{
11 		// Создаем Отдел и передаем Работников в качестве параметров конструктора
12 		Department department; // содаем пустой Отдел
13 		department.add(w1);
14 		department.add(w2);
15 		department.add(w3);
16
17 		std::cout << department;
18
19 	} // department выходит из области видимости и уничтожается здесь
20
21 	std::cout << w1->getName() << " still exists!\n";
22 	std::cout << w2->getName() << " still exists!\n";
23 	std::cout << w3->getName() << " still exists!\n";
24
25 	delete w1;
26 	delete w2;
27 	delete w3;
28
29 	return 0;
30 }

Должен выдавать следующий результат:

Department: Anton Ivan Max
Anton still exists!
Ivan still exists!
Max still exists!

Подсказки:
 Используйте std::vector для хранения Работников.
 Используйте std::vector::push_back() для добавления Работника
 Используйте std::vector::size() для получения длины std::vector

Ответ No2
