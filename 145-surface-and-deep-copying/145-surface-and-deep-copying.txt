Урок No 145. Поверхностное и глубокое копирование


На этом уроке мы рассмотрим поверхностное и глубокое копирование в языке C++.

Оглавление:
1. Поверхностное копирование
2. Глубокое копирование
3. Лучшее решение
4. Заключение


Поверхностное копирование

Поскольку язык C++ не может знать наперед всё о вашем классе, то конструктор копирования и оператор присваивания,
которые C++ предоставляет по умолчанию, используют почленный метод копирования — поверхностное копирование.
Это означает, что C++ выполняет копирование для каждого члена класса индивидуально (используяоператор
присваивания по умолчанию вместо перегрузки оператора присваивания и прямую инициализацию вместо
конструктора копирования). Когда классы простые (например, вних нет членов с динамически выделенной памятью), то
никаких проблем с этим не должно возникать.

Рассмотрим следующий класс Drob:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
19 };
20
21 std::ostream& operator<<(std::ostream& out, const Drob &d1)
22 {
23 	out << d1.m_numerator << "/" << d1.m_denominator;
24 	return out;
25 }

Конструктор копирования и оператор присваивания по умолчанию, предоставляемые компилятором автоматически,
выглядят примерно следующи мобразом:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &d) :
20 		m_numerator(d.m_numerator), m_denominator(d.m_denominator)
21 	{
22 	}
23
24 	Drob& operator= (const Drob &drob);
25
26 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
27 };
28
29 std::ostream& operator<<(std::ostream& out, const Drob &d1)
30 {
31 	out << d1.m_numerator << "/" << d1.m_denominator;
32 	return out;
33 }
34
35 // Перегрузка оператора присваивания
36 Drob& Drob::operator= (const Drob &drob)
37 {
38 	// Проверка на самоприсваивание
39 	if (this == &drob)
40 		return *this;
41
42 	// Выполняем копирование
43 	m_numerator = drob.m_numerator;
44 	m_denominator = drob.m_denominator;
45
46 	// Возвращаем текущий объект, чтобы иметь возможность выполнять цепочку операций присваивания
47 	return *this;
48 }

Поскольку эти конструктор копирования и оператор присваивания по умолчанию отлично подходят для выполнения
копирования с объектами этого класса, то действительно нет никакого смысла писать здесьсвои собственные версии
конструктора копирования и перегрузки оператора.

Однако при работе с классами, в которых динамически выделяется память, почленное (поверхностное) копирование может
вызывать проблемы! Это связано стем, что при поверхностном копировании указателя копируется только адрес
указателя — никаких действий по содержимому адреса указателя не предпринимается. Например:

1 #include <cstring> // для strlen()
2 #include <cassert> // для assert()
3
4 class SomeString
5 {
6 private:
7 	char *m_data;
8 	int m_length;
9
10 public:
11 	SomeString(const char *source="")
12 	{
13 		assert(source); // проверяем не является ли source нулевой строкой
14
15 		// Определяем длину source + еще один символ для нуль-терминатора (символ завершения строки)
16 		m_length = strlen(source) + 1;
17
18 		// Выделяем достаточно памяти для хранения копируемого значения в соответствии с длиной этого значения
19 		m_data = new char[m_length];
20
21 		// Копируем значение по символам в нашу выделенную память
22 		for (int i=0; i < m_length; ++i)
23 			m_data[i] = source[i];
24
25 		// Убеждаемся, что строка завершена
26 		m_data[m_length-1] = '\0';
27 	}
28
29 	~SomeString() // деструктор
30 	{
31 		// Освобождаем память, выделенную для нашей строки
32 		delete[] m_data;
33 	}
34
35 	char* getString() { return m_data; }
36 	int getLength() { return m_length; }
37 };

Вышеприведенный класс — это обычный строковый класс, в котором выделяется память для хранения передаваемой
строки. Здесь мы не определяли конструктор копирования или перегрузку оператора присваивания. Следовательно, язык
C++ предоставит конструктор копирования и оператор присваивания по умолчанию, которые будут выполнять
поверхностное копирование. Конструктор копирования выглядит примерно следующим образом:

1 SomeString::SomeString(constSomeString &source) :
2 	m_length(source.m_length), m_data(source.m_data)
3 {
4 }

Здесь m_data — это всего лишь поверхностная копия указателя source.m_data, поэтому теперьони оба указывают на
один и тот же адрес памяти. Теперь рассмотрим следующий фрагмент кода:

1 int main()
2 {
3 	SomeString hello("Hello, world!");
4 	{
5 		SomeString copy = hello; // используется конструктор копирования по умолчанию
6 	} // объект copy является локальной переменной, которая уничтожается здесь. Деструктор удаляет значение - строку объекта
7
8 	std::cout << hello.getString() << '\n'; // здесь неопределенные результаты
9
10 	return 0;
11 }

Хотя этот код выглядит достаточно безвредным, но он имеет в себе коварную проблему, которая приведет к сбою
программы! Можете найти эту проблему? Если нет,то ничего страшного.

Разберем этот код по строкам:
1 SomeString hello("Hello, world!");

Строка кода, приведенная выше, безвредна. Здесь вызывается конструктор класса SomeString, который выделяет память,
заставляет hello.m_data указыватьна эту память, а затем копирует вв ыделенный адрес памяти значение — строку
Hello, world!.

1 SomeString copy = hello; // используется конструктор копирования по умолчанию

Эта строка также кажется достаточно безвредной, но именно она и является источником нашей коварной проблемы!
При обработке этой строки C++ будет использовать конструктор копирования по умолчанию (так как мы не предоставили
своего). Выполнится поверхностное копирование, результатом чего будет инициализация copy.m_data адресом, на
который указывает hello.m_data . И теперь copy.m_data и hello.m_data оба указывают на одну и ту же часть памяти!

1 } // объект copy уничтожается здесь

Когда объект-копия выходит из области видимости, то вызывается деструктор SomeString для этой копии. Деструктор
удаляет динамически выделенную память, на которую указывают как copy.m_data, так и hello.m_data! Следовательно,
удаляя копию, мы также (случайно) удаляем и данные hello. Объект copy затем уничтожается, но hello.m_data остается
указывать на удаленную память!

1 std::cout << hello.getString() << '\n'; // здесь неопределенные результаты

Теперь вы поняли, почему эта программа работает не совсем так, как нужно. Мы удалили значение-строку, на которую
указывал hello, а сейчас пытаемся вывести это значение.

Корнем этой проблемы является поверхностное копирование, выполняемое конструктором копирования по умолчанию.
Такое копирование почти всегда приводит к проблемам.


Глубокое копирование

Одним из решений этой проблемыяв ляется выполнение глубокого копирования. При глубоком копировании память
сначала выделяется для копирования адреса, который содержит исходный указатель, а затем для копирования
фактического значения. Таким образом копия находится в отдельной, от исходного значения, памятии они никак не
влияют друг на друга. Дляв ыполнения глубокого копированиян ам необходимо написать свой собственный конструктор
копирования и перегрузку оператора присваивания.

Рассмотрим это на примере с классом SomeString:

1 // Конструктор копирования
2 SomeString::SomeString(const SomeString& source)
3 {
4 	// Поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
5 	m_length = source.m_length;
6
7 	// m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии, что этот указатель не явл
8 	if (source.m_data)
9 	{
10 		// Выделяем память для нашей копии
11 		m_data = new char[m_length];
12
13 		// Выполняем копирование
14 		for (int i=0; i < m_length; ++i)
15 			m_data[i] = source.m_data[i];
16 	}
17 	else
18 		m_data = 0;
19 }

Как вы видите, реализация здесь более углубленная, нежели при поверхностном копировании! Во-первых, мы должны
проверить, имеет ли исходный объект ненулевое значение вообще (строка No 8). Если имеет, то мы выделяем достаточно
памяти для хранения копии этого значения (строка No 11). Наконец, копируем значение-строку (строки No 14-15).

Теперь рассмотрим перегрузку оператора присваивания:

1 // Оператор присваивания
2 SomeString& SomeString::operator=(const SomeString & source)
3 {
4 	// Проверка на самоприсваивание
5 	if (this == &source)
6 		return *this;
7
8 	// Сначала нам нужно очистить предыдущее значение m_data (члена неявного объекта)
9 	delete[] m_data;
10
11 	// Поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
12 	m_length = source.m_length;
13
14 	// m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии, что этот указатель не является нулевым
15 	if (source.m_data)
16 	{
17 		// Выделяем память длянашей копии
18 		m_data = new char[m_length];
19
20 		// Выполняем копирование
21 		for (int i=0; i < m_length; ++i)
22 			m_data[i] = source.m_data[i];
23 	}
24 	else
25 		m_data = 0;
26
27 	return *this;
28 }

Заметили, что код перегрузки очень похож на код конструктора копирования? Но здесь есть 3 основных отличия:

 Мы добавили проверку на самоприсваивание.
 Мы возвращаем текущий объект (с помощью указателя *this), чтобы иметь возможность выполнить цепочку операций присваивания.
 Мы явно удаляем любое значение, которое объект уже хранит (чтобы не произошло утечки памяти).

При вызове перегруженного оператора присваивания, объект, которому присваивается другой объект, может содержать
предыдущее значение, которое нам необходимо очистить/удалить, прежде чем мы выделим память для нового значения. 
С не динамически выделенными переменными (которые имеют фиксированный размер) нам не нужно беспокоиться,
поскольку новое значение просто перезапишет старое. Однако с динамически выделенными переменными нам нужно
явно освободить любую старую память до того, как мы выделим любую новую память. Если мы этого не сделаем, сбоя не
будет, но произойдет утечка памяти, которая будет съедать нашу свободную память каждый раз, когда мы будем выполнять
операцию присваивания!


Лучшее решение

В Стандартной библиотеке C++ классы,к оторые работают с динамически выделенной памятью, такие как std::string и
std::vector, имеют свое собственное управление памятью и свои конструкторы копирования и перегрузку операторов
присваивания, которые выполняют корректное глубокое копирование. Поэтому, вместо написания своих собственных
конструкторов копирования и перегрузки оператора присваивания, вы можете выполнять инициализацию или
присваивание строк, или векторов, как обычных переменных фундаментальных типов данных! Это гораздо проще, менее
подвержено ошибкам, и вам не нужно тратить время на написание лишнего кода!

Заключение
 Конструктор копирования и оператор присваивания, предоставляемые по умолчанию языком C++, выполняют
поверхностное копирование, что отлично подходит для классов без динамически выделенных членов.
 Классы с динамически выделенными членами должны иметь конструктор копирования и перегрузку оператора
присваивания, которые выполняют глубокое копирование.
 Используйте функциональность классов из Стандартной библиотеки C++, нежели самостоятельно выполняйте/
реализовывайте управление памятью.
