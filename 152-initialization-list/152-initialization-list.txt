Урок No 152. Список инициализации std::initializer_list

На этом уроке мы рассмотрим список инициализации std::initializer_list, его использование и нюансы в языке С++.

Оглавление:
1. Списки инициализации
2. Инициализация классов через std::initializer_list
3. Присваивание значенийи std::initializer_list
4. Заключение
5. Тест


Списки инициализации
Рассмотрим фиксированный массив целых чисел в языке C++:
1 int array[7];

Для инициализации этого массива мы можем использовать список инициализации:
1 #include <iostream>
2
3 int main()
4 {
5 	int array[7] { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
6 	for (int count=0; count < 7; ++count)
7 		std::cout << array[count] << ' ';
8
9 	return 0;
10 }

Результат:
7 6 5 4 3 2 1

Это также работает и с динамически выделенными массивами:

1 #include <iostream>
2
3 int main()
4 {
5 	int *array = new int[7] { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
6 	for (int count = 0; count < 7; ++count)
7 		std::cout << array[count] << ' ';
8 	delete[] array;
9
10 	return 0;
11 }

На предыдущем уроке мы рассматривали контейнерные классы на примере класса-массива целых чисел ArrayInt:

1 #include <cassert> // для assert()
2
3 class ArrayInt
4 {
5 private:
6 	int m_length;
7 	int *m_data;
8
9 public:
10 	ArrayInt():
11 		m_length(0), m_data(nullptr)
12 	{
13 	}
14
15 	ArrayInt(int length):
16 	m_length(length)
17 	{
18 		m_data = new int[length];
19 	}
20
21 	~ArrayInt()
22 	{
23 		delete[] m_data;
24 		// Нам не нужно здесь присваивать значение null для m_data или выполнять m_length = 0, так как объект будет уничтожен с
25 	}
26
27 	int& operator[](int index)
28 	{
29 		assert(index >= 0 && index < m_length);
30 		return m_data[index];
31 	}
32
33 	int getLength() { return m_length; }
34 };

Что произойдет, если мы попытаемся использовать список инициализации с этим контейнерным классом?

1 int main()
2 {
3 	ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // эта строка вызовет ошибку компиляции
4 	for (int count=0; count < 7; ++count)
5 		std::cout << array[count] << ' ';
6
7 	return 0;
8 }

Этот код не скомпилируется, так как класс ArrayInt не имеет конструктора, который бы знал, что делать со списком
инициализации, поэтому каждый элемент нужно инициализировать в индивидуальном порядке:

1 int main()
2 {
3 ArrayInt array(7);
4 array[0] = 7;
5 array[1] = 6;
6 array[2] = 5;
7 array[3] = 4;
8 array[4] = 3;
9 array[5] = 2;
10 array[6] = 1;
11
12 for (int count=0; count < 7; ++count)
13 	std::cout << array[count] << ' ';
14
15 return 0;
16 }

Как-то не очень, правда?
До C++11 списки инициализации могли использоваться только со статическими или динамически выделенными массивами.
Однако в C++11 появилось решение этой проблемы.


Инициализация классов через std::initializer_list

Когда компилятор C++11 видит списокин ициализации, то он автоматически конвертирует его в объект типа std::initializer_list.
Поэтому, если мы создадим конструктор, который принимает в качестве параметра std::initializer_list, мы сможем создавать
объекты, используя список инициализации в качестве входных данных.

std::initializer_list находится в заголовочном файле initializer_list.

Есть несколько вещей, которые нужнознать о std::initializer_list. 

Также,как и с std::array и std::vector, вы должны указать в угловых скобках std::initializer_list какой тип данных будет 
использоваться. По этой причине вы никогда не увидите пустой std::initializer_list. Вместо этого вы увидите что-то вроде 
std::initializer_list<int> или std::initializer_list<std::string> .

Во-вторых, std::initializer_list имеет функцию size(), которая возвращает количество элементо всписка. Это полезно, когда нам
нужно знать длину получаемого списка.

Обновим наш класс-массив ArrayInt, добавив конструктор, который принимает std::initializer_list:
1 #include <iostream>
2 #include <cassert> // для assert()
3 #include <initializer_list> // для std::initializer_list
4
5 class ArrayInt
6 {
7 private:
8 	int m_length;
9 	int *m_data;
10
11 public:
12 	ArrayInt() :
13 		m_length(0), m_data(nullptr)
14 	{
15 	}
16
17 	ArrayInt(int length) :
18 		m_length(length)
19 	{
20 		m_data = new int[length];
21 	}
22
23 	ArrayInt(const std::initializer_list<int> &list): // позволяем инициализацию ArrayInt через список инициализации
24 		ArrayInt(list.size()) // используем концепцию делегирования конструкторов для создания начального массива, в который будет выполняться копирование элементов
25 	{
26 		// Инициализация нашего начального массива значениями из списка инициализации
27 		int count = 0;
28 		for (auto &element : list)
29 		{
30 			m_data[count] = element;
31 			++count;
32 		}
33 	}
34
35 	~ArrayInt()
36 	{
37 		delete[] m_data;
38 		// Нам не нужно здесь присваивать значение null для m_data или выполнять m_length = 0, так как объект будет уничтожен сразу же после выполнения этой функци
39 	}
40
41 	int& operator[](int index)
42 	{
43 		assert(index >= 0 && index < m_length);
44 		return m_data[index];
45 	}
46
47 	int getLength() { return m_length; }
48 };
49
50 int main()
51 {
52 	ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
53 	for (int count = 0; count < array.getLength(); ++count)
54 		std::cout << array[count] << ' ';
55
56 	return 0;
57 }

Результатвыполнения программы:
7 6 5 4 3 2 1

Работает! Теперь рассмотрим это всё детально.

Вот наш конструктор, который принимает std::initializer_list<int>:

1 ArrayInt(const std::initializer_list<int> &list): // позволяем инициализацию ArrayInt через список инициализации
2 	ArrayInt(list.size()) // используем концепцию делегирования конструкторов для создания начального массива, в который будет выполняться копирование элементов
3 {
4 	// Инициализируем наш начальный массив значениями из списка инициализации
5 	int count = 0;
6 	for (auto &element : list)
7 	{
8 		m_data[count] = element;
9 		++count;
10 	}
11 }

Строка No 1: Как мы ужеговорили, обязательно нужно указывать используемый тип данных в угловых скобках std::initializer_list.
В этом случае, поскольку это ArrayInt, то ожидается, что список будет заполнен значениями типа int. Обратите внимание, мы
передаем список по константной ссылке, дабы избежать его копирования при передаче в конструктор.

Строка No 2: Мы делегируем выделение памяти для начального объекта ArrayInt, в который будем выполнять копирование
элементов, другому конструктору, используя концепцию делегирующих конструкторов, чтобы сократить лишний код. Этот
другой конструктор должен знать длину выделяемого объекта, поэтому мы передаем ему list.size() , который указывает на
количество элементов списка.

В теле нашего конструктора мы выполняем копирование элементов из списка инициализации в класс ArrayInt. По каким-то
необъяснимым причинам std::initializer_list не предоставляет доступ к своим элементам через оператор индексации [] . Об
этом много говорили, но официального решения так и не предоставили.
Тем не менее, есть способы, чтобы это обойти. Самый простой — использовать цикл foreach. Цикл foreach перебирает каждый
элемент списка, и мы, таким образом, копируем каждый элемент в наш внутренний массив.


Присваивание значений и std::initializer_list

Вы также можете использовать std::initializer_list для присваивания новых значений классу, перегрузив оператор
присваивания для получения std::initializer_list в качестве параметра. Пример того, как это делается, будетв тестовом задании
ниже.
Обратите внимание, если вы создаете конструктор, который принимает std::initializer_list, то вы должны проследить,чтобы хоть
одно из следующих действий было выполнено:

 Перегрузка оператора присваивания.
 Корректное глубокое копирование для оператора присваивания.
 Наличие явного конструктора (с ключевым словом explicit),чтобы он не могиспользоваться для неявных
преобразований.

Почему? Рассмотрим вышеприведенный класс (который не имеет перегрузки оператора присваивания или копирующего
присваивания) со следующим стейтментом:

1 array = { 1, 3, 5, 7, 9, 11 }; // перезаписываем значения array значениями из списка инициализации

Во-первых, компилятор видит, что функции присваивания, которая принимает std::initializer_list в качестве параметра, не
существует. Затем он ищет другие функции, которые он мог бы использовать, и находит неявно предоставленный копирующий
оператор присваивания. Однако эта функция может использоваться, только если она сможет преобразовать список
инициализациив ArrayInt, а поскольку у нас естьконструктор, которыйпринимает std::initializer_list, и он не помечен как
explicit, то компилятор будет использовать этот конструктор для преобразования списка инициализации во временный
ArrayInt. Затем вызовется неявный оператор присваивания, который используется в конструкторе и который будет выполнять
поверхностное копирование временного объекта ArrayInt в наш объект array.

И тогда m_data временного объектаArrayInt, и m_data объекта array будут указывать на один и тотже адрес (из-за
поверхностного копирования). Вы уже можете догадаться, к чему это приведет.
В конце стейтмента присваивания временный ArrayInt уничтожается. Вызывается деструктор, который удаляет временный
m_data классаArrayInt. Это оставляет наш объект array с висячим указателем m_data . Когда мы попытаемся использовать
m_data объекта array для любых целей (в том числе, когда массив будет выходить из области видимости и деструктору
нужно будет уничтожить m_data), то мы получим неопределенные результаты (или сбой).

Заключение
Реализация конструктора, который принимает std::initializer_list в качестве параметра (используется передача по ссылке для
предотвращения копирования), позволяет нам использовать список инициализации с нашими пользовательскими классами.
Мы также можем использовать std::initializer_list для реализации других функций, которым необходим список инициализации
(например, для перегрузки оператора присваивания)

Тест
Используя вышеприведенный класс ArrayInt, реализуйте перегрузку оператора присваивания, который будет принимать
список инициализации. Следующий код:

1 int main()
2 {
3 	ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
4 	for (int count = 0; count < array.getLength(); ++count)
5 		std::cout << array[count] << ' ';
6
7 		std::cout << '\n';
8
9 	array = { 1, 4, 9, 12, 15, 17, 19, 21 };
10
11 	for (int count = 0; count < array.getLength(); ++count)
12 		std::cout << array[count] << ' ';
13
14 	return 0;
15 }

Должен выдавать следующий результат:
7 6 5 4 3 2 1
1 4 9 12 15 17 19 21

Ответ