Урок No 135. Перегрузка унарных операторов +, − и логического НЕ


Рассмотрим унарные операторы плюс (+), минус ( - ) и логическое НЕ (!), которые работают с одним операндом.
Так как они применяются только к одному объекту, то их перегрузку следует выполнять через методы класса.
Например, перегрузим унарный оператор минус ( - ) для класса Dollars:

1 #include <iostream>
2
3 class Dollars
4 {
5 private:
6 	int m_dollars;
7
8 public:
9 	Dollars(int dollars) { m_dollars = dollars; }
10
11 	// Выполняем -Dollars через метод класса
12 	Dollars operator-() const;
13
14 	int getDollars() const { return m_dollars; }
15 };
16
17 // Эта функция является методом класса!
18 Dollars Dollars::operator-() const
19 {
20 	return Dollars(-m_dollars);
21 }
22
23 int main()
24 {
25 	const Dollars dollars1(7);
26 	std::cout << "My debt is " << (-dollars1).getDollars() << " dollars.\n";
27
28 	return 0;
29 }

Примечание: Определение метода можно записать и внутри класса. Здесь мы определили его вне тела класса для
лучшей наглядности.
Всё довольно-таки просто. Перегрузка отрицательного унарного оператора минус (-) осуществляется через метод класса,
так как явные параметры в функции перегрузки отсутствуют (только неявный объект, накоторый указывает скрытый
указатель *this). Оператор - возвращает объект Dollars с отрицательным значением m_dollars. Поскольку этот
оператор не изменяет объект класса Dollars, то мы можем (и должны) сделать функцию перегрузки константной (чтобы
иметь возможность использовать этот оператор и с константными объектами класса Dollars).

Обратите внимание, путаницы между отрицательным унарным оператором минус (-) и бинарным оператором минус ( - )
нет,так как они имеют разное количество параметров.

Вот еще один пример: оператор ! является логическим оператором НЕ, который возвращает true, если результатом
выражения является false и возвращает false, если результатом выражения является true . Обычно это применяется 
к переменным типа bool, чтобы проверить, являютсяли они true или нет:

1 if (!isHappy)
2 	std::cout << "I am not happy!\n";
3 else
4 	std::cout << "I am so happy!\n";

В языке С++ значение 0 обозначает false, а любое другое ненулевое значение обозначает true, поэтому, если
логический оператор ! применять к целочисленным значениям, то он будет возвращать true, если значением
переменной является 0 , в противном случае — false.
Следовательно, при работе с классами, оператор ! будет возвращать true, если значением объекта класса является
false, 0 или любое другое значение, заданное как дефолтное (по умолчанию) при инициализации, в противном случае —
оператор ! будет возвращать false.

В следующем примеремы рассмотрим перегрузку унарного оператора минус ( − ) и оператора логического НЕ ( ! ) для
класса Something:

1 #include <iostream>
2
3 class Something
4 {
5 private:
6 	double m_a, m_b, m_c;
7
8 public:
9 	Something(double a = 0.0, double b = 0.0, double c = 0.0) :
10 		m_a(a), m_b(b), m_c(c)
11 	{
12 	}
13
14 	// Конвертируем объект класса Something в отрицательный
15 	Something operator- () const
16 	{
17 		return Something(-m_a, -m_b, -m_c);
18 	}
19
20 	// Возвращаем true, если используются значения по умолчанию, в противном случае - false
21 	bool operator! () const
22 	{
23 		return (m_a == 0.0 && m_b == 0.0 && m_c == 0.0);
24 	}
25
26 	double getA() { return m_a; }
27 	double getB() { return m_b; }
28 	double getC() { return m_c; }
29 };
30
31
32
33 int main()
34 {
35 	Something something; // используем конструктор по умолчанию со значениями 0.0, 0.0, 0.0
36
37 	if (!something)
38 		std::cout << "Something is null.\n";
39 	else
40 		std::cout << "Something is not null.\n";
41
42 	return 0;
43 }

Здесь перегруженный оператор НЕ( ! ) возвращает true, если в Something используются значения 
по умолчанию (0.0 , 0.0 , 0.0).

Результат выполненияпрограммы:
Something is null.

Еслиже задать любые ненулевые значения для объекта класса Something:

1 Something something(23.11, 37.1, 20.12);

То результатом будет:
Something is not null.


Тест

Реализуйте перегрузку унарного оператора плюс( + ) для класса Something.
Унарный оператор плюс ( + ) делает значение положительным.

---------------

#include <iostream>

class Something
{
private:
	double m_a, m_b, m_c;

public:
	Something(double a = 0.0, double b = 0.0, double c = 0.0) :
 		m_a(a), m_b(b), m_c(c)
 	{
 	}

 	// Конвертируем объект класса Something в отрицательный
 	Something operator- () const
 	{
 		return Something(-m_a, -m_b, -m_c);
 	}

 	// Конвертируем объект класса Something в положительный
 	Something operator+ () const
 	{
 		return Something(+m_a, +m_b, +m_c);
 	}

 	// Возвращаем true, если используются значения по умолчанию, в противном случае - false
 	bool operator! () const
 	{
 		return (m_a == 0.0 && m_b == 0.0 && m_c == 0.0);
 	}

 	double getA() { return m_a; }
 	double getB() { return m_b; }
 	double getC() { return m_c; }
};



int main()
{
	Something something; // используем конструктор по умолчанию со значениями 0.0, 0.0, 0.0

	if (!something)
		std::cout << "Something is null.\n";
	else
		std::cout << "Something is not null.\n";

	return 0;
}





Ответ

Есть два решения.

Решение №1:

Something Something::operator+ () const
{
    return Something(m_a, m_b, m_c);
}
Решение №2:

Something Something::operator+ () const
{
    return *this;
}
Это работает, так как Something, который мы возвращаем, является текущим объектом.
