Урок No176. Параметр non-type в шаблоне


На предыдущих уроках мы узнали, как использовать параметр типа в шаблоне для создания функций и классов, которые не
зависят от определенного типа данных. Однако параметр типа не является единственным параметром, который может иметь
шаблон. 
Шаблоны классов и шаблоны функций могут иметь еще один параметр, известный как параметр non-type.


Параметр non-type

Параметр non-type в шаблоне — это специальный параметр шаблона, который заменяется не типом данных, а конкретным
значением. Этим значением может быть:
 целочисленное значение или перечисление;
 указатель или ссылка на объект класса;
 указатель или ссылка на функцию;
 указатель или ссылка на метод класса;
 std::nullptr_t.

В следующем примере мы создадим шаблон класса StaticArray, который использует как параметр типа, так и параметр non-
type. Параметр типа отвечает за тип данных элементов статического массива, а параметр non-type отвечает за размер
выделяемого массива:

1 #include <iostream>
2
3 template <class T, int size> // size является параметром non-type в шаблоне класса
4 class StaticArray
5 {
6 private:
7 	// Параметр non-type в шаблоне класса отвечает за размер выделяемого массива
8 	T m_array[size];
9
10 public:
11 	T* getArray();
12
13 	T& operator[](int index)
14 	{
15 		return m_array[index];
16 	}
17 };
18
19 // Синтаксис определения шаблона метода и самого метода вне тела класса с параметром non-type
20 template <class T, int size>
21 T* StaticArray<T, size>::getArray()
22 {
23 	return m_array;
24 }
25
26 int main()
27 {
28 	// Объявляем целочисленный массив из 10 элементов
29 	StaticArray<int, 10> intArray;
30
31 	// Заполняем массив значениями
32 	for (int count=0; count < 10; ++count)
33 		intArray[count] = count;
34
35 	// Выводим элементы массива в обратном порядке
36 	for (int count=9; count >= 0; --count)
37 		std::cout << intArray[count] << " ";
38 	std::cout << '\n';
39
40 	// Объявляем массив типа double из 5 элементов
41 	StaticArray<double, 5> doubleArray;
42
43 	// Заполняем массив значениями
44 	for (int count=0; count < 5; ++count)
45 		doubleArray[count] = 5.5 + 0.1*count;
46
47 	// Выводим элементы массива
48 	for (int count=0; count < 5; ++count)
49 		std::cout << doubleArray[count] << ' ';
50
51 	return 0;
52 }

Результат выполнения программы:
9 8 7 6 5 4 3 2 1 0
5.5 5.6 5.7 5.8 5.9

Примечательно то, что нам не пришлось динамически выделять переменную-член m_array! Это связано с тем, что для
любого созданного объекта класса StaticArray его размер является конкретно заданным значением (можно сказать константой),
которое передает пользователь. Например, если мы создадим экземпляр StaticArray<int, 10> , то компилятор заменит
переменную размера массива ( size ) на 10. Таким образом, мы получим m_array типа int[10] , который можно выделить
статическим образом.

Эту особенность использует уже известный нам класс из Стандартной библиотеки С++ — std::array. Когда мы выделяем
std::array<int, 5> , то int является параметром типа, а 5 — параметром non-type в шаблоне класса!
