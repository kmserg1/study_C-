Урок No 142. Копирующая инициализация


Рассмотрим следующую строку кода:
1 int a = 7;

Здесь используется копирующая инициализация для инициализации целочисленной переменной a значением 7 . С
обычными переменными всё просто. Однако с классами дела обстоят несколько сложнее, поскольку в их инициализации
используются конструкторы. На этом уроке мы рассмотрим использование копирующей инициализации с классами.


Использование копирующей инициализации с классами

Рассмотрим следующую программу:
1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
19 };
20
21 std::ostream& operator<<(std::ostream& out, const Drob &d1)
22 {
23 	out << d1.m_numerator << "/" << d1.m_denominator;
24 	return out;
25 }
26
27 int main()
28 {
29 	Drob seven = Drob(7);
30 	std::cout << seven;
31 	return 0;
32 }

Результатвыполнения программы:
7/1

Форма копирующей инициализации в языке C++ в вышеприведенном примере обрабатывается точно так же, как и
следующая:
1 Drob seven(Drob(7));

А, как мы уже знаем из предыдущего урока, это может привести к вызову как Drob(int, int), так и конструктора
копирования Drob (который может быть проигнорирован). Однако, поскольку гарантии на 100% игнорирования
конструктора копирования не предоставляется, то лучше избегать использования копирующей инициализации при работе
с классами и вместо нее использовать прямую инициализацию или uniform-инициализацию, так как в случае с
использованием конструктора копирования у вас может получиться следующий результат: 7
вместо необходимого: 7/1

Так как в конструкторе копирования (который язык C++ предоставит автоматически) значения по умолчанию для
m_denominator не будет.

Правило: Избегайте использования копирующейинициализации при работе с классами, вместо нее используйте
uniform-инициализацию.

Другие применения копирующей инициализации
Когда вы передаете или возвращаете объект класса по значению, то в этом процессе используется копирующая
инициализация. Рассмотрим следующую программу:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &copy) :
20 		m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)
21 	{
22 		// Нет необходимости выполнять проверку denominator здесь, так как она осуществляется в конструкторе по умолчанию
23 		std::cout << "Copy constructor worked here!\n"; // просто чтобы показать, что это работает
24 	}
25
26 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
27 	int getNumerator() { return m_numerator; }
28 	void setNumerator(int numerator) { m_numerator = numerator; }
29 };
30
31 std::ostream& operator<<(std::ostream& out, const Drob &d1)
32 {
33 	out << d1.m_numerator << "/" << d1.m_denominator;
34 	return out;
35 }
36
37 Drob makeNegative(Drob d) // правильно было бы здесь использовать константную ссылку
38 {
39 	d.setNumerator(-d.getNumerator());
40 	return d;
41 }
42
43 int main()
44 {
45 	Drob sixSeven(6, 7);
46 	std::cout << makeNegative(sixSeven);
47
48 	return 0;
49 }

Здесь функция makeNegative() принимает объект класса Drob по значению и возвращает его так же по значению. Результат
выполнения программы:
Copy constructor worked here!
Copy constructor worked here!
-6/7

Первый вызов конструктора копирования выполнится при передаче sixSeven в качестве аргумента в параметр d
функции makeNegative(). 
Второй вызов выполнится при возврате объекта из функции makeNegative() обратно в функцию main(). 
Таким образом, объект sixSeven копируется дважды.

В примере, приведенном выше, компилятор не может проигнорировать использование конструктора копирования как в
передаче аргумента по значению, так и в его возврате. Однако в некоторых случаях, если аргумент или возвращаемое
значение соответствуют определенным критериям, компилятор может проигнорировать использование конструктора
копирования.Например:

1 #include <iostream>
2
3 class Something
4 {
5 };
6
7 Something boo()
8 {
9 	Something x;
10 	return x;
11 }
12
13 int main()
14 {
15 	Something x = boo();
16 	return 0;
17 }

В этом случае компилятор, скорее всего, проигнорирует использование конструктора копирования, хоть объект x и
возвращается по значению.

