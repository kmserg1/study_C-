УрокNo71.Генерацияслучайных чисел

Возможность генерировать случайные числа очень полезна в некоторых видах программ, в частности, в играх,
программах научного или статистического моделирования. 
Возьмем, к примеру, игры без рандомных (или «случайных») событий —
монстры всегда будут атаковать вас одинаково, вы всегда будете находить одни и те же предметы/артефакты, макеты
темниц и подземелий никогда не будут меняться и т.д. В общем, сюжет такой игры не очень интересен и врядли вы будете
в нее долго играть.

Оглавление:
1. Генератор псевдослучайных чисел
2. Функции srand() и rand()
3. Стартовое число и последовательности в ГПСЧ
4. Генерация случайных чисел в заданном диапазоне
5. Какой ГПСЧ является хорошим?
6. Почему rand() является посредственным ГПСЧ?
7. Отладка программ, использующих случайные числа
8. Рандомные числа в C++11


Генератор псевдослучайных чисел

Так как же генерировать случайные числа? В реальной жизни мы часто бросаем монетку (орел/решка), кости или
перетасовываем карты. Эти события включают в себя так много физических переменных (например, сила тяжести, трение,
сопротивление воздуха и т.д.), что они становятся почти невозможными для прогнозирования / контроля и выдают
результаты, которые во всех смыслах являются случайными
Однако компьютеры не предназначены для использования физических переменных — они не могут подбросить монетку,
бросить кости или перетасовать реальные карты. Компьютеры живут в контролируемом электрическом мире, где есть
только два значения (true и false), чего-то среднего между ними нет. По своей природе компьютеры предназначены для
получения прогнозируемых результатов. Когда мы говорим компьютеру посчитать, сколько будет 2 + 2, мы всегда хотим,
чтобы ответом было 4 (не 3 и не 5).
Следовательно, компьютеры не способны генерировать случайные числа. Вместо этого они могут имитировать
случайность, что достигается с помощью генераторов псевдослучайных чисел.
Генератор псевдослучайных чисел (сокр. «ГПСЧ») — это программа, которая принимает стартовое / начальное значение и
выполняет с ним определенные математические операции, чтобы конвертировать его в другое число, которое совсем не
связано со стартовым. Затем программа использует новое сгенерированное значение и выполняет с ним те же
математические операции, что и с начальным числом, чтобы конвертировать его в еще одно новое число — третье,
которое не связано ни с первым, ни со вторым. Применяя этот алгоритм к последнему сгенерированному значению,
программа может генерировать целый ряд новых чисел, которые будут казаться случайными (при условии, что алгоритм 
будет достаточно сложным).

Насамом деле, написатьпростой ГПСЧ не так уж и сложно. Вот небольшая программа, которая генерирует 100 рандомных
чисел:

#include <iostream>
 
unsigned int PRNG()
{
    // Наше стартовое число - 4 541
    static unsigned int seed = 4541;
 
    // Берем стартовое число и, с его помощью, генерируем новое значение.
    // Из-за использования очень больших чисел (и переполнения) угадать следующее число исходя из предыдущего - очень сложно
    seed = (8253729 * seed + 2396403);
 
    // Берем стартовое число и возвращаем значение в диапазоне от 0 до 32767
    return seed % 32768;
}
 
int main()
{
    // Выводим 100 случайных чисел
    for (int count=0; count < 100; ++count)
    {
        std::cout << PRNG() << "\t";
 
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count+1) % 5 == 0)
            std::cout << "\n";
	}
}

Результат выполнения программы:

18256   4675    32406   6217    27484
975     28066   13525   25960   2907
12974   26465   13684   10471   19898
12269   23424   23667   16070   3705
22412   9727    1490    773     10648
1419    8926    3473    20900   31511
5610    11805   20400   1699    24310
25769   9148    10287   32258   12597
19912   24507   29454   5057    19924
11591   15898   3149    9184    4307
24358   6873    20460   2655    22066
16229   20984   6635    9022    31217
10756   16247   17994   19069   22544
31491   16214   12553   23580   19599
3682    11669   13864   13339   13166
16417   26164   12711   11898   26797
27712   17715   32646   10041   18508
28351   9874    31685   31320   11851
9118    26193   612     983     30378
26333   24688   28515   8118    32105

Каждое число кажется случайным по отношению к предыдущему. Главный недостаток этого алгоритма — его
примитивность.


Функции srand() и rand()

Языки Cи и C++ имеют свои собственные встроенные генераторы случайных чисел. Они реализованы в двух отдельных
функциях, которые находятся в заголовочном файле cstdlib:

 Функция srand() устанавливает передаваемое пользователем значение в качестве стартового. 
srand() следует вызывать только одинраз — в начале программы (обычно в верхней части функции main()).

 Функция rand()генерирует следующее случайное число в последовательности. Оно будет находиться в диапазоне от
0 до RAND_MAX (константа в cstdlib, значением которой является 32767).

Вот пример программы, в которой используются обе эти функции:

1 #include <iostream>
2 #include <cstdlib> // для функций rand() и srand()
3
4 int main()
5 {
6 	srand(4541); // устанавливаем стартовое значение - 4 541
7
8 	// Выводим 100 случайных чисел
9 	for (int count=0; count<100; ++count)
10 	{
11 		std::cout << rand() << "\t";
12
13 		// Если вывели 5 чисел, то вставляем символ новой строки
14 		if((count+1) % 5 ==0)
15 			std::cout <<"\n";
16 	}
17 }

Результат выполнения программы:

14867   24680   8872    25432   21865
17285   18997   10570   16397   30572
22339   31508   1553    124     779
6687    23563   5754    25989   16527
19808   10702   13777   28696   8131
18671   27093   8979    4088    31260
31016   5073    19422   23885   18222
3631    19884   10857   30853   32618
31867   24505   14240   14389   13829
13469   11442   5385    9644    9341
11470   189     3262    9731    25676
1366    24567   25223   110     24352
24135   459     7236    17918   1238
24041   29900   24830   1094    13193
10334   6192    6968    8791    1351
14521   31249   4533    11189   7971
5118    19884   1747    23543   309
28713   24884   1678    22142   27238
6261    12836   5618    17062   13342
14638   7427    23077   25546   21229


Стартовое число и последовательности в ГПСЧ

Если вы запустите вышеприведенную программу (генерация случайных чисел) несколько раз, то заметите, что в
результатах всегда находятся одни и те же числа! Это означает, что,хотя каждое число в последовательности кажется
случайным относительно предыдущего, вся последовательность не является случайной вообще! А это, в свою очередь,
означает, что наша программа полностью предсказуема (одни и те же значения ввода приводят к одним и тем же
значениям вывода). Бывают случаи, когда это может быть полезно или даже желательно (например, если вы хотите, чтобы
научнаяс имуляция повторялась, или вы пытаетесь исправить причины сбоя вашего генератора случайных подземелий в
игре).
Но в большинстве случаев это не совсем то, что нам нужно. Если вы пишете игру типа Hi-Lo (гдеу пользователя есть 10
попыток угадать число, а компьютер говорит ему, насколько его предположения близки или далеки от реального числа),
вы бы не хотели,ч тобы программа выбирала одни и те же числа каждый раз. Поэтому давайте более подробно рассмотрим,
почему это происходит и как это можно исправить.
Помните, что каждое новое число в последовательности ГПСЧ генерируется исходя из предыдущего определенным
способом. Таким образом, при постоянном начальном числе ГПСЧ всегда будет генерировать одну и ту же
последовательность! В программе,п риведенной выше, последовательность чисел всегда одинакова, так как стартовое
число всегда равно 4541.
Чтобы это исправить нам нужен способ выбрать стартовое число, которое не будет фиксированным значением. Первое,
что приходит на ум — использовать рандомное число! Это хорошая мысль, но если нам нужно случайное число для
генерации случайных чисел, то это какой-то замкнутый круг, вам не кажется? Оказывается, нам не обязательно
использовать случайное стартовое число — нам просто нужно выбрать что-то, что будет меняться каждый раз при новом
запуске программы. Затем мы сможем использовать наш ГПСЧ для генерации уникальной последовательности рандомных
чисел исходя из уникального стартового числа.
Общепринятым решением является использование системных часов. Каждый раз,при запуске программы, время будет
другое. Если мы будем использовать значение времени в качестве стартового числа, то наша программа всегда будет
генерировать разную последовательность чисел при каждом новом запуске!
В языке Cи есть функция time(), которая возвращает в качестве времени общее количество секунд, прошедшее от
полуночи 1 января 1970 года. Чтобы использовать эту функцию, нам просто нужно подключить заголовочный файл ctime, а
затемин ициализировать функцию srand() вызовом функции time(0).
Вот вышеприведенная программа, но уже с использованием функции time() в качестве стартового числа:

1 #include <iostream>
2 #include <cstdlib> // для функций rand() и srand()
3 #include <ctime> // для функции time()
4
5 int main()
6 {
7 	srand(static_cast<unsigned int>(time(0))); // устанавливаем значение системных часов в качестве стартового числа
8
9 	for (intcount=0; count<100; ++count)
10 	{
11 		std::cout <<rand()<< "\t";
13 		// Если вывели 5 чисел, то вставляем символ новой строки
12
14 		if((count+1) % 5 ==0)
15 			std::cout <<"\n";
16 	}
17 }

Теперь наша программа будет генерировать разные последовательности случайных чисел! Попробуйте сами.


Генерация случайных чисел в заданном диапазоне

В большинстве случаев нам не нужны рандомныечисла между 0 и RAND_MAX — нам нужны числа междудвумя другими
значениями: min и max. Например, если нам нужно сымитировать бросок кубика, то диапазонзначений будет невелик: от
1 до 6 .
Вот небольшая функция, которая конвертирует результат функции rand() вн ужный нам диапазон значений:

1 // Генерируем рандомное число между значениями min и max
2 // Предполагается, что функцию srand() уже вызывали
3 int getRandomNumber(int min,int max)
4 {
5  	static const double fraction=1.0/(static_cast<double>(RAND_MAX) + 1.0);
6  	// Равномерно распределяем рандомное число в нашем диапазоне
7 	return static_cast<int>(rand() * fraction * (max-min+1) + min)
8 }

Чтобы сымитировать бросок кубика, вызываем функцию getRandomNumber(1, 6).


Какой ГПСЧ является хорошим?

Как мыуже говорили, генератор случайных чисел, который мы написали выше, не является очень хорошим. Сейчас
рассмотрим почему.
Хороший ГПСЧ должен иметь ряд свойств:

Свойство No 1: ГПСЧ должен генерировать каждое новое число с примерно одинаковойв ероятностью. Это
называется равномерностью распределения. Если некоторые числа генерируются чаще, чем другие, то результат
программы, использующей ГПСЧ, будет предсказуем! Например, предположим, вы пытаетесь написать генератор
случайных предметов для игры. Вы выбираете случайное числоот 1 до 10, и, если результатом будет 10, игрок получит
крутой предмет вместо среднего. Шансы должны быть 1 к 10. Но, если ваш ГПСЧ неравномерно генерирует числа,
например, десятки генерируются чаще, чем должны,то ваши игроки будут получать более редкиепредметы чаще, чем
предполагалось, и сложность, и интерес к такой игре автоматически уменьшаются.
Создать ГПСЧ, который бы генерировал равномерные результаты — сложно, и это одна из главных причин, по которым
ГПСЧ, который мы написали в начале этого урока, не является очень хорошим.

Свойство No 2: Метод, с помощью которого генерируется следующее число в последовательности, не долженбыть
очевиден или предсказуем. Например, рассмотрим следующий алгоритм ГПСЧ: num = num +1. У него есть
равномерность распределения рандомных чисел, но этоне спасает его от примитивности и предсказуемости!

Свойство No 3: ГПСЧ должен иметь хорошее диапазонное распределение чисел. Эт оозначает, что маленькие, средние
и большие числа должны возвращаться случайным образом. ГПСЧ, который возвращает все маленькие числа, а затем все
большие — предсказуем и приведет к предсказуемым результатам.

Свойство No4: Период циклического повторения значений ГПСЧ долженбыть максимально большим. Все ГПСЧ
являются циклическими, т.е. в какой-то момент последовательность генерируемых чисел начнет повторяться. Как
упоминалось ранее, ГПСЧ являются детерминированными, и с одним значением ввода мы получим одно и тоже значение
вывода. Подумайте, что произойдет, когда ГПСЧ сгенерирует число, которое уже ранее было сгенерировано. С этого
момента начнется дублирование последовательности чисел между первым и последующим появлением этого числа. Длина
этой последовательности называется периодом.
Например, вот представлены первые 100 чисел, сгенерированные ГПСЧ с плохой периодичностью:
112   9      130    97    64
31    152    119    86    53
20    141    108    75    42
9     130    97     64    31
152   119    86     53    20
141   108    75     42     9
130   97     64     31   152
119   86     53     20   141
108   75     42      9   130
97    64     31    152   119
86    53     20    141   108
75    42      9    130    97
64    31    152    119    86
53    20    141    108    75
42     9    130     97    64
31   152    119     86    53
20   141    108     75    42
9    130     97     64    31
152  119     86     53    20
141  108     75     42     9

Заметили, что он сгенерировал 9, как второе число, а затем как шестнадцатое? ГПСЧ застревает, генерируя
последовательность между этими двумя 9-ми: 9-130-97-64-31-152-119-86-53-20-141-108-75-42- (повтор).
Хороший ГПСЧ должен иметь длинный период длявсех стартовых чисел.
Разработка алгоритма, соответствующего этому требованию, может быть чрезвычайно сложной — большинство ГПСЧ
имеют длинные периоды для одних начальных чисел и короткие для других.
Если пользователь выбрал начальное число, которое имеет короткий период, то ирезультаты будут соответствующие.

Несмотря на сложность разработки алгоритмов, отвечающих всем этим критериям, в этойобласти было проведено
большое количество исследований, так как разные ГПСЧ активно используются в важных отраслях науки.


Почему rand() является посредственным ГПСЧ?

Алгоритм, используемый для реализации rand(), можетв арьироваться в разныхко мпиляторах, и, соответственно,
результаты также могут быть разными. В большинстве реализаций rand() используется Линейный Конгруэнтный Метод
(сокр. «ЛКМ»). Если вы посмотрите на первый пример в этом уроке, то заметите, что там, на самом деле, используется ЛКМ,
хоть и с намеренно подобранными плохими константами.
Однимиз основных недостатков функции rand() является то, что RAND_MAX обычно устанавливается как 32767 (15-битное
значение). Это означает, что если выз ахотите сгенерировать числа в более широком диапазоне (например,32-битные
целые числа), то функция rand() не подойдет.
Кроме того, она не подойдет, еслив ы захотите сгенерировать случайные числа типа с плавающей запятой (например, между
0.0 и 1.0), что часто используется в статистическом моделировании. Наконец, функция rand() имеет относительно короткий
период по сравнению с другими алгоритмами.

Тем не менее, этот алгоритм отлично подходит для изучения программирования и для программ, в которых
высококлассный ГПСЧ не является необходимостью.

Для приложений, где требуется высококлассный ГПСЧ, рекомендуется использовать алгоритм Вихрь Мерсенна (англ.
«Mersenne Twister»), который генерирует отличные результаты и относительно прост в использовании.


Отладка программ, использующих случайные числа

Программы, которые используют случайные числа, трудно отлаживать, так как при каждом запуске такой программымы
будем получать разные результаты. Ач тобыу спешно проводить отладку программ, нужно удостовериться, что наша
программа выполняется одинаково при каждом её запуске. Таким образом, мы сможем быстро узнать расположение
ошибки и изолировать этот участок кода.
Поэтому, проводя отладкуп рограммы,пол езно использовать в качестве стартово гочисла (с использованием функции
srand()) определенное значение (например,0), которое вызовет ошибочное поведение программы. Это будет гарантией
того, что нашап рограмма каждый раз генерирует одни и те же результаты (что значительно облегчит процесс отладки).
После того, как мы найдем и исправимо шибку, мы сможем снова использовать системные часы длягенерации рандомных
результатов.


Рандомныеч исла в C++11

В C++11 добавили тонну нового функционала для генерации случайных чисел,в ключая алгоритм Вихрь Мерсенна, а также
разные виды генераторов случайных чисел (например, равномерные,генератор Poisson и пр.). Доступ к ним
осуществляется через подключение заголовочного файла random. Вот пример генерации случайных чисел в C++11 с
использованием Вихря Мерсенна:

1 #include <iostream>
2 // #include <ctime> // раскомментируйте, если используете Code::Block
3 #include <random> // для std::random_device и std::mt19934
5 int main()
6 {
7 	std::random_device rd;
8 	std::mt19937 mersenne(rd()); //инициализируем Вихрь Мерсенна случайным стартовым числом
9
10 	// Примечание: Из-за одного бага в компиляторе Code::Blocks (если вы используете Code::Blocks в Windows) - удалите две строки кода выше и раскомментируйте следующую строку:
11 	// std::mt19937 mersenne(static_cast<unsigned int>(time(0))); // инициализируем Вихрь Мерсенна случайным стартовым числом
12
13 	// Выводим несколько случайных чисел
14 	for (intcount=0; count<48;++count)
15 	{
16 		std::cout <<mersenne()<< "\t";
17
18 		//Если вывели 5 чисел,то вставляем символ новой строки
19 		if((count+1) % 5 == 0)
20 			std::cout <<"\n";
21 	}
22 }

Вихрь Мерсенна генерирует случайные 32-битные целые числа unsigned (а не 15-битные целые числа, как в случае с
rand()), что позволяет использовать гораздо больший диапазон значений. Существует также версия (std::mt19937_64 ) для
генерации 64-битных целых чисел unsigned!

Примечание для пользователей Visual Studio:
	Реализация функции rand() в Visual Studio имеетодин существенный недостаток — первое генерируемое случайное число
	не сильно отличается от стартового. Это означает, что, при использовании time() для генерации начального числа, первое
	число не будет сильно отличаться/изменяться от стартового и при последующих запусках. Есть простое решение: вызовите 
	функцию rand() один раз и сбросьте (игнорируйте) этот результат. Затемвы сможете использовать rand(), как обычно в вашей программе.

