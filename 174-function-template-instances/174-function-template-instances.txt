Урок No 174. Экземпляры шаблонов функций

Язык C++ не компилирует шаблоны функций напрямую. Вместо этого, когда компилятор встречает вызов шаблона
функции, он копирует шаблон функции и заменяет типы параметров шаблона функции фактическими (передаваемыми)
типами данных. Функция с фактическими типами данных называется экземпляром шаблона функции (или «объектом
шаблона функции»).

Рассмотрим это напрактике. Во-первых, создадим шаблон функции:

1 template <typename T> // объявление параметра шаблона функции
2 const T& max(const T& a, const T& b)
3 {
4 	return (a > b) ? a : b;
5 }

Затем сделаем вызов шаблона функции:

1 int i = max(4, 8); // вызывается max(int, int)

Компилятор видит, чтооба числа являются целочисленными, поэтомуон копирует шаблон функциии создает экземпляр
шаблона max(int, int) :
1 const int& max(const int &a, const int &b)
2 {
3 	return (a > b) ? a : b;
4 }

Это теперь уже «обычная функция». Допустим, что нам нужно снова вызвать функцию max(), но уже с другим типом данных:

1 double d = max(7.58, 19.378); // вызывается max(double, double)

Язык C++ автоматически создает экземпляр шаблона max(double, double):
1 const double& max(const double &a, const double &b)
2 {
3 	return (a > b) ? a : b;
4 }

И затем компилирует его. Также стоит отметить, что, если вы создадите шаблон функции, но не вызовете его, экземпляры
этого шаблона созданы не будут.


Операторы, вызовы функций и шаблоны функций

Шаблоны функций работают как с фундаментальными типами данных (char,int,double и т.д.), так и с классами 
(но есть нюанс). 
Экземпляр шаблона компилируется как обычная функция. В обычной функции любые операторы или вызовы
других функций, которые используются в этой функции, должныбыть определены/перегружены, или выполучите ошибку
компиляции. Аналогично, любые операторы или вызовы других функций, которые присутствуют в шаблоне функции,
должны быть определены/перегружены для работы с фактическими (передаваемыми) типами данных. Рассмотрим это на
практике.

Во-первых, создадим простой класс:
1 class Dollars
2 {
3 private:
4 	int m_dollars;
5 public:
6 	Dollars(int dollars)
7 		: m_dollars(dollars)
8 	{
9 	}
10 };

Теперь посмотрим, что произойдет при попытке вызова функции max() с объектами класса Dollars:

1 template <typename T> // объявление параметра шаблона функции
2 const T& max(const T& a, const T& b)
3 {
4 	return (a > b) ? a : b;
5 }
6
7 class Dollars
8 {
9 private:
10 	int m_dollars;
11 public:
12 	Dollars(int dollars)
13 		: m_dollars(dollars)
14 	{
15 	}
16 };
17
18 int main()
19 {
20 	Dollars seven(7);
21 	Dollars twelve(12);
22
23 	Dollars bigger = max(seven, twelve);
24
25 	return 0;
26 }

Язык C++ создаст следующий экземпляр шаблона функции max():

1 const Dollars& max(const Dollars &a, const Dollars &b)
2 {
3 	return (a > b) ? a : b;
4 }

А затем компилятор попытается скомпилировать эту функцию, но ничего не получится, так как C++ не имеет понятия, как
обрабатывать выражение a > b ! Следовательно, это приведет к ошибке:
Ошибка C2676 бинарный ">": "const T" не определяет этот оператор или преобразование к типу приемлемо к
встроенному оператору

Сообщение об ошибке указываетна тот факт, что мы не перегрузили оператор > для класса Dollars. 
Давайте перегрузим:

1 class Dollars
2 {
3 private:
4 	int m_dollars;
5 public:
6 	Dollars(int dollars)
7 		: m_dollars(dollars)
8 	{
9 	}
10
11 	friend bool operator>(const Dollars &d1, const Dollars &d2)
12	{
13 		return (d1.m_dollars > d2.m_dollars);
14 	}
15 };

Теперь C++ знает, как обрабатывать выражение a > b, когда в качестве переменных используются объекты класса Dollars

Еще один пример
Создадим шаблон функции, которая вычисляет среднее арифметическое элементов массива:

1 template <class T>
2 T average(T *array, int length)
3 {
4 	T sum = 0;
5 	for (int count=0; count < length; ++count)
6 		sum += array[count];
7
8 	sum /= length;
9 	return sum;
10 }

Протестируем:

1 #include <iostream>
2
3 template <class T>
4 T average(T *array, int length)
5 {
6 	T sum = 0;
7 	for (int count=0; count < length; ++count)
8 		sum += array[count];
9
10 	sum /= length;
11 	return sum;
12 }
13
14 int main()
15 {
16 	int array1[] = { 6, 4, 1, 3, 7 };
17 	std::cout << average(array1, 5) << '\n';
18
19 	double array2[] = { 4.25, 5.37, 8.44, 9.25 };
20 	std::cout << average(array2, 4) << '\n';
21
22 	return 0;
23 }

Результат:
4
6.8275

Как вывидите, всё отлично работает с фундаментальными типами данных!
Поскольку тип возврата шаблона функции тот же, что и тип передаваемых элементов массива в функцию, то вычисление
среднего арифметического целочисленных значений приведет к целочисленному результату (с отбрасыванием любой
дробной части), как и вычисление значений типа double приведет к результату типа double. Этоможет быть не очевидным,
поэтому хорошим тоном будет указать на это в комментариях.

Теперь посмотрим, что произойдет при вызове функции average() с объектами класса Dollars:

1 #include <iostream>
2
3 class Dollars
4 {
5 private:
6 	int m_dollars;
7 public:
8 	Dollars(int dollars)
9 		: m_dollars(dollars)
10 	{
11 	}
12
13 	friend bool operator>(const Dollars &d1, const Dollars &d2)
14 	{
15 		return (d1.m_dollars > d2.m_dollars);
16 	}
17 };
18
19 template <class T>
20 T average(T *array, int length)
21 {
22 	T sum = 0;
23 	for (int count=0; count < length; ++count)
24 		sum += array[count];
25
26 	sum /= length;
27 	return sum;
28 }
29
30 int main()
31 {
32 	Dollars array3[] = { Dollars(7), Dollars(12), Dollars(18), Dollars(15) };
33 	std::cout << average(array3, 4) << '\n';
34
35 	return 0;
36 }

Результат:
1>c:\users\kicli\source\repos\consoleapplication10\consoleapplication10\consoleapplication10.cpp(37):
error C2679: бинарный "<<": не найден оператор, принимающий правый операнд типа "T" (или приемлемое
преобразование отсутствует) 1> with
1> [
1> T=Dollars
1> ]
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(508): note: может быть
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(std::basic_streambuf<char,std::char_traits> *)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(480): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator <<(const
void *)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(460): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator <<(long
double)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(440): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(double)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(420): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(float)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(400): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(unsigned __int64)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(380): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(__int64)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(360): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(unsigned long)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(340): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator <<(long)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(320): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(unsigned int)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(295): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator <<(int)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(275): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(unsigned short)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(241): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(short)" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(221): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator <<(bool)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(215): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(std::ios_base &(__cdecl *)(std::ios_base &))" 1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(209): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(std::basic_ios<char,std::char_traits> &(__cdecl *)(std::basic_ios<char,std::char_traits> &))"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(204): note: или
"std::basic_ostream<char,std::char_traits> &std::basic_ostream<char,std::char_traits>::operator
<<(std::basic_ostream<char,std::char_traits> &(__cdecl *)(std::basic_ostream<char,std::char_traits> &))"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(702): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<char,std::char_traits>
(std::basic_ostream<char,std::char_traits> &,const char *)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(749): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<char,std::char_traits>
(std::basic_ostream<char,std::char_traits> &,char)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(787): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,const char *)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(834): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,char)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(960): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,const signed char *)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(967): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,signed char)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(974): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,const unsigned char *)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(981): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<std::char_traits>
(std::basic_ostream<char,std::char_traits> &,unsigned char)"
1>c:\program files (x86)\microsoft visual
studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream(1047): note: или
"std::basic_ostream<char,std::char_traits> &std::operator <<<char,std::char_traits>
(std::basic_ostream<char,std::char_traits> &,const std::error_code &)"
1>c:\users\kicli\source\repos\consoleapplication10\consoleapplication10\consoleapplication10.cpp(37):
note: при попытке сопоставить список аргументов "(std::ostream, T)"
1> with
1> [
1> T=Dollars
1> ]

Компилятор сошел сума. Мы говорили о таких ошибках на предыдущем уроке. Несмотря на столь объемный «результат»,
здесь всё довольно просто. В первых строках сообщается, что компилятор не смог найти перегрузку оператора << для
класса Dollars. Далее указываются функции с типами данных, которые вызывались для сравнения, но так и не подошли. 
И в конце указываются параметр шаблона и заменяемый (фактический) тип параметра.

VisualStudio бережет наши нервы и предоставляет нам альтернативный вывод ошибок:
Ошибка E0349 отсутствует оператор "<<", соответствующий этим операндам
Ошибка C2679 бинарный "<<": не найден оператор, принимающий правый операнд типа "T" (или приемлемое
преобразование отсутствует)

Помните, что average() возвращает объект класса Dollars, а мы пытаемся этот объект вывести с помощью оператора вывода
<< и std::cout. Однако, мы не перегрузилиоператор << для класса Dollars. Давайте исправим это:

1 class Dollars
2 {
3 private:
4 	int m_dollars;
5 public:
6 	Dollars(int dollars)
7 		: m_dollars(dollars)
8 	{
9 	}
10
11 	friend bool operator>(const Dollars &d1, const Dollars &d2)
12 	{
13 		return (d1.m_dollars > d2.m_dollars);
14 	}
15
16 	friend std::ostream& operator<< (std::ostream &out, const Dollars &dollars)
17 	{
18 		out << dollars.m_dollars << " dollars ";
19 		return out;
20 	}
21 };

Если же теперь запустить программу, то получим следующее:

Ошибка C2676 бинарный "+=": "T" не определяет этот оператор или преобразование к типу приемлемо к
встроенному оператору
Ошибка C2676 бинарный "/=": "T" не определяет этот оператор или преобразование к типу приемлемо к
встроенному оператору

Эти ошибки были вызваны экземпляром шаблона функции, созданным при вызове average(Dollars*, int). Помните,
что при вызове шаблона функции, компилятор копирует шаблон функции с типами параметров, а затем заменяет типы
параметров шаблона на фактические (передаваемые) типы данных. Вот экземпляр шаблона функции average(), где T
является классом Dollars:

1 template <class Dollars>
2 Dollars average(Dollars *array, int length)
3 {
4 	Dollars sum = 0;
5 	for (int count=0; count < length; ++count)
6 		sum += array[count];
7
8 	sum /= length;
9 	return sum;
10 }

Причина, по которой мы получили сообщение об ошибке ,кроется в следующей строке:

1 sum += array[count];

В этом случае sum является объектом класса Dollars. А чтобы всё заработало, нам нужно перегрузить 
операторы += и /= для класса Dollars:

1 class Dollars
2 {
3 private:
4 int m_dollars;
5 public:
6 Dollars(int dollars)
7 : m_dollars(dollars)
8 {
9 }
10
11 friend bool operator>(const Dollars &d1, const Dollars &d2)
12 {
13 return (d1.m_dollars > d2.m_dollars);
14 }
15
16 friend std::ostream& operator<< (std::ostream &out, const Dollars &dollars)
17 {
18 out << dollars.m_dollars<< " dollars ";
19 return out;
20 }
21
22 Dollars& operator+=(Dollars dollars)
23 {
24 m_dollars += dollars.m_dollars;
25 return *this;
26 }
27
28 Dollars& operator/=(int value)
29
 {
30
 m_dollars /= value;
31
 return *this;
32
 }
33 };
Наконец,наш кодскомпилируется,ирезультат:
13 dollars
Хотя проделанная работаможетпоказаться оченьбольшой, но это толькоиз-за того, что наш класс Dollarsс самого начала
был«кожа да кости». Ключевой моментздесьвтом, чтонам не нужно модифицировать average(), чтобы онработалс
объектамиклассаDollars (илиc любым другим типом данных). Вся работабыла проделана толькос классом Dollars, а обо
всемостальном компилятор позаботился самостоятельно!