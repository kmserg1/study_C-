Урок No 157. Наследование и cпецификатор доступа protected

На предыдущих уроках мы говорили о том, как работает наследование в языке C++. Во всех наших примерах мы
использовали открытое наследование.
На этом уроке мы рассмотрим детально этот тип наследования, а также двадругих типа: private и protected. Также поговорим о
том, как эти типы наследований взаимодействуют со спецификаторами доступа для разрешения или ограничения доступа к
членам.

Оглавление:
1. Спецификатор доступа protected
2. Когда следует использовать спецификатор доступа protected?
3. Типы наследований. Доступ к членам
	- Наследование типа public
	- Наследование типа private
	- Наследование типа protected
4. Финальный пример
5. Заключение


Спецификатор доступа protected

Мы уже рассматривали спецификаторы доступа private и public, которые определяют, кто может иметь доступ к членам
класса. В качестве напоминания: доступ к public-членам открыт для всех, к private-членам доступ имеют только члены того же
класса, в котором находится private-член. Это означает, что дочерние классы не могут напрямую обращаться к private-членам
родительского класса!

1 class Parent
2 {
3 private:
4 	int m_private; // доступ к этому члену есть только у других членов класса Parent и у дружественных классов/функций (но не у дочерних классов)
5 public:
6 	int m_public; // доступ к этому члену открыт для всех объектов
7 };

Всё просто.

Примечание: public=«открытый», private = «закрытый», protected = «защищенный».

В языке C++ есть третий спецификатор доступа, о котором мы еще не говорили, так как он полезен только в контексте
наследования. Спецификатор доступа protected открывает доступ к членам класса дружественным и дочерним
классам. Доступ к protected-члену вне тела класса закрыт.

1 class Parent
2 {
3 public:
4 	int m_public; // доступ к этому члену открыт для всех объектов
5 private:
6 	int m_private; // доступ к этому члену открыт только для других членов класса Parent и для дружественных классов/функций (но не для дочерних классов)
7 protected:
8 	int m_protected; // доступ к этому члену открыт для других членов класса Parent, дружественных классов/функций, дочерних классов
9 };
10
11 class Child: public Parent
12 {
13 public:
14 	Child()
15 	{
16 		m_public = 1; // разрешено: доступ к открытым членам родительского класса из дочернего класса
17 		m_private = 2; // запрещено: доступ к закрытым членам родительского класса из дочернего класса
18 		m_protected = 3; // разрешено: доступ к защищенным членам родительского класса из дочернего класса
19 	}
20 };
21
22 int main()
23 {
24 	Parent parent;
25 	parent.m_public = 1; // разрешено: доступ к открытым членам класса извне
26 	parent.m_private = 2; // запрещено: доступ к закрытым членам класса извне
27 	parent.m_protected = 3; // запрещено: доступ к защищенным членам класса извне
28 }

В примере, приведенном выше, вы можете видеть,что член m_protected класса Parent напрямую доступен дочернему классу
Child, но доступ к нему для членов извне — закрыт.


Когда следует использовать спецификатор доступа protected?

К protected-членам родительского класса доступ открыт для членов дочернего класса, а это означает, что если вы позже
измените что-либо в protected-члене (тип данных, значение и т.д.), то вам придется внести изменения как в родительский, так
и во все дочерние классы. Поэтому использование спецификатора доступа protected наиболее полезно, когда вы будете
наследовать только свои же классы и количество дочерних классов будет небольшое. Таким образом, если вы внесете
изменения в реализацию родительского класса, и вам понадобится обновить все дочерние классы, то вы сможете сделать эти
обновления сами и это не займет много времени (так как дочерних классов будет немного).

Создание private-членов предоставляет лучшую инкапсуляцию и изолирует родительские классы от изменений, вызванных
дочерними классами. Но цена этому — дополнительное создание открытого или защищенного интерфейса (способа
взаимодействия других объектов с классами и их членами, т.е. геттеры и сеттеры). Это дополнительная работа, которая не
стоит того, если вы сами работаете со своими же классами (чужие классы не обращаются к вашему классу) и количество
дочерних классов небольшое.                                                                             


Типы наследований. Доступ к членам

Существует три типа наследований классов:
 public;
 private;
 protected.

Для определения типа наследования нужно просто указать нужное ключевое слово возле наследуемого класса:

1 // Открытое наследование
2 class Pub: public Parent
3 {
4 };
5
6 // Закрытое наследование
7 class Pri: private Parent
8 {
9 };
10
11 // Защищенное наследование
12 class Pro: protected Parent
13 {
14 };
15
16 class Def: Parent // по умолчанию язык C++ устанавливает закрытое наследование
17 {
18 };

Если вы сами не определили тип наследования, то в языке C++ по умолчанию будет выбран тип наследования private
(аналогично и для членов класса, которые по умолчанию являются private, если не указано иначе).

Это дает нам 9 комбинаций: 3 спецификатора доступа (public, private и protected) и 3 типа наследования (public, private и
protected).
Так в чем же разница между ними? Если вкратце, то при наследовании спецификатор доступа члена родительского класса
может быть изменен в дочернем классе (в зависимости от типа наследования). Другими словами, члены, которые были public-
или protected- в родительском классе, могут стать private - в дочернем классе.
Это может показаться немного запутанным, но всё не так уж плохо. Мы сейчас совсем этим разберемся, но перед этим
вспомним следующие правила:

 Класс всегда имеет доступ к своим (ненаследуемым) членам.
 Доступк члену класса основывается на его спецификаторе доступа.
 Дочерний классимеет доступ к унаследованным членам родительского класса на основе спецификатора доступа этих
членов в родительском классе.


Наследование типа public

Открытое наследование является одним из наиболее используемых типов наследования. Очень редко вы увидите или будете
использовать другие типы, поэтому основной упор следует сделать на понимание именно этого типа наследования. К счастью,
открытое наследование является самым легкими простым из всех типов. Когда вы открыто наследуете родительский класс, то
унаследованные public-члены остаются public, унаследованные protected-члены остаются protected, а унаследованные private-
члены остаются недоступными для дочернего класса. Ничего неменяется.

Спецификатор доступа в 			Спецификатор доступа принаследовании 
родительском классе			типа public в дочернем классе
-----------------------------------------------------------------------------------
public					public
private					Недоступен
protected				protected
-----------------------------------------------------------------------------------

Например:
1 class Parent
2 {
3 public:
4 	int m_public;
5 private:
6 	int m_private;
7 protected:
8 	int m_protected;
9 };
10
11 class Pub: public Parent // открытое наследование
12 {
13 	// Открытое наследование означает, что:
14 	// - public-члены остаются public в дочернем классе;
15 	// - protected-члены остаются protected в дочернем классе;
16 	// - private-члены остаются недоступными в дочернем классе.
17 public:
18 	Pub()
19 	{
20 		m_public = 1; // разрешено: доступ к m_public открыт
21 		m_private = 2; // запрещено: доступ к m_private в дочернем классе из родительского класса закрыт
22 		m_protected = 3; // разрешено: доступ к m_protected в дочернем классе из родительского класса открыт
23 	}
24 };
25
26 int main()
27 {
28 	Parent parent;
29 	parent.m_public = 1; // разрешено: m_public доступен извне через родительский класс
30 	parent.m_private = 2; // запрещено: m_private недоступен извне через родительский класс
31 	parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс
32
33 	Pub pub;
34 	pub.m_public = 1; // разрешено: m_public доступен извне через дочерний класс
35 	pub.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
36 	pub.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
37 }

Правило: Используйте открытое наследование, если у вас нет веских причин делать иначе.


Наследование типа private

При закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что private-члены
остаются недоступными, а protected- и public- члены становятся private в дочернем классе.
Обратите внимание, это не влияет на то, как дочерний класс получает доступ к членам родительского класса!
Этовлияет только на то, как другими объектами осуществляется доступ к этим членам через дочерний класс:

1 class Parent
2 {
3 public:
4 	int m_public;
5 private:
6 	int m_private;
7 protected:
8 	int m_protected;
9 };
10
11 class Priv: private Parent // закрытое наследование
12 {
13 	// Закрытое наследование означает, что:
14 	// - public-члены становятся private (m_public теперь private) в дочернем классе;
15 	// - protected-члены становятся private (m_protected теперь private) в дочернем классе;
16 	// - private-члены остаются недоступными (m_private недоступен) в дочернем классе.
17 public:
18 	Priv()
19 	{
20 		m_public = 1; // разрешено: m_public теперь private в Priv
21 		m_private = 2; // запрещено: дочерние классы не имеют доступ к закрытым членам родительского класса
22 		m_protected = 3; // разрешено: m_protected теперь private в Priv
23 	}
24 };
25
26 int main()
27 {
28 	Parent parent;
29 	parent.m_public = 1; // разрешено: m_public доступен извне через родительский класс
30 	parent.m_private = 2; // запрещено: m_private недоступен извне через родительский класс
31 	parent.m_protected = 3; // запрещено: m_protected недоступен извне через родительский класс
32
33 	Priv priv;
34 	priv.m_public = 1; // запрещено: m_public недоступен извне через дочерний класс
35 	priv.m_private = 2; // запрещено: m_private недоступен извне через дочерний класс
36 	priv.m_protected = 3; // запрещено: m_protected недоступен извне через дочерний класс
37 }

Итого:
----------------------------------------------------------------------------
Спецификатор доступа в		Спецификатор доступа при
родительском классе		наследовании типа private в дочернем классе
----------------------------------------------------------------------------
public				private
private				Недоступен
protected			private
----------------------------------------------------------------------------

Закрытое наследование может быть полезно, когда дочерний класс не имеет очевидной связи с родительским классом, но
использует его в своей реализации. В таком случае мы не хотим, чтобы открытый интерфейс родительского класса был
доступен через объекты дочернего класса (как это было, когда мы использовали открытый тип наследования).
На практике наследование типа private используется редко.


Наследование типа protected

Этот тип наследования почти никогдане используется, за исключением особых случаев. С защищенным наследованием,
public- и protected- члены становятся protected, а private-члены остаются недоступными.
Поскольку этот тип наследования очень редко используется, то мы пропустим пример на практике и сразу перейдем к таблице:

----------------------------------------------------------------------------
Спецификатор доступа 		Спецификатор доступа при наследовании 
в родительском классе		типа protected в дочернем  классе
----------------------------------------------------------------------------
public				protected
private				Недоступен
protected 			protected
----------------------------------------------------------------------------

Финальный пример
1 class Parent
2 {
3 public:
4 	int m_public;
5 private:
6 	int m_private;
7 protected:
8 	int m_protected;
9 };

Класс Parent может обращаться к своим членам беспрепятственно. Доступ к m_public открыт для всех. Дочерние классы могут
обращаться как к m_public , так и к m_protected:

1 class D2 : private Parent  // закрытое наследование
2 {
3 	// Закрытое наследование означает, что:
4 	// - public-члены становятся private в дочернем классе;
5 	// - protected-члены становятся private в дочернем классе;
6 	// - private-члены недоступны для дочернего класса.
7 public:
8 	int m_public2;
9 private:
10 	int m_private2;
11 protected:
12 	int m_protected2;
13 };

Класс D2 может беспрепятственно обращаться к своим членам. D2 имеет доступ к членам m_public и m_protected класса
Parent, но не к m_private . Поскольку D2 наследует класс Parent закрыто, то m_public и m_protected теперь становятся
закрытыми при доступе через D2. Это означает, что другие объекты не смогут получить доступ к этим членам через
использование объекта D2,а также любые другие классы, которые будут дочерними классу D2, не будут иметь доступ к этим
членам:

1 class D3 : public D2
2 {
3 	// Открытое наследование означает, что:
4 	// - унаследованные public-члены остаются public в дочернем классе;
5 	// - унаследованные protected-члены остаются protected в дочернем классе;
6 	// - унаследованные private-члены остаются недоступными в дочернем классе.
7 public:
8 	int m_public3;
9 private:
10 	int m_private3;
11 protected:
12 	int m_protected3;
13 };

Класс D3 может беспрепятственно обращаться к своим членам. D3 имеетдоступ к членам m_public2 и m_protected2 класса
D2, но не к m_private2 . Поскольку D3 наследует D2 открыто, то m_public2 и m_protected2 сохраняют свои спецификаторы
доступа и остаются public и protected при доступе через D3. D3 не имеет доступ к m_private класса Parent. Он также не имеет
доступ к m_protected или m_public класса Parent, оба из которых стали закрытыми, когда D2 унаследовал их.


Заключение

Способ взаимодействия спецификаторов доступа, типов наследования и дочерних классов может вызывать путаницу. Чтобы
это устранить, проясним всё еще раз:

 Во-первых, класс всегда имеет доступ к своим собственным не унаследованным членам (и дружественные ему
классы также имеютдоступ). Спецификаторы доступа влияют только на то, могут ли объекты вне класса и дочерние классы
обращаться к этим членам.
 Во-вторых, когда дочерние классы наследуют члены родительских классов,то члены родительского класса могут
изменять свои спецификаторы доступа в дочернем классе. Это никак не влияет на собственные (не наследуемые) члены
дочерних классов (которые определены в дочернем классе и имеют свои собственные спецификаторы доступа). Это влияет
только на то, могут ли объекты извне и классы, дочерние нашим дочерним классам, получить доступ к унаследованным
членам родительского класса.

Общая таблица спецификаторов доступа и типов наследования:
--------------------------------------------------------------------------------------------------------------------
Спецификатор		 Спецификатор доступа при	 Спецификатор доступа при	 Спецификатор доступа при
доступа в		 наследовании типа public в	 наследовании типа private в	 наследовании типа protected
родительском классе	 дочернем классе		 дочернем классе		 в дочернем классе
--------------------------------------------------------------------------------------------------------------------
public 			 public				 private			 protected
private			 Недоступен			 Недоступен			 Недоступен
protected		 protected			 private			 protected
--------------------------------------------------------------------------------------------------------------------

Хотя в вышеприведенных примерах мы рассматривали использование переменных-членов, эти правила выполняются для всех
членов классов (и для методов, и для типов, объявленных внутри класса).
