Урок No 80. Указатели


Науроке No 10 мы узнали,что переменная — это название кусочка памяти, который содержит значение.

Оглавление:
1. Оператор адреса &
2. Оператор разыменования*
3. Указатели
4. Присваивание значений указателю
5. Оператор адреса возвращает указатель
6. Разыменование указателей
7. Разыменование некорректных указателей
8. Размер указателей
9. В чём польза указателей?
10. Заключение
11. Тест


Оператор адреса &

При выполнени и инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение,
которое мы присваиваем переменной, сохраняется по этому адресу в памяти. Например:

1 int b = 8;

При выполнении этого стейтмента процессором, выделяется часть оперативной памяти. В качестве примера предположим,
что переменной b присваивается ячейка памяти под номером 150. Всякий раз, когда программа встречает переменную b в
выражении или в стейтменте, она понимает, что для того, чтобы получить значение — ей нужно заглянуть в ячейку памяти под
номером 150.
Хорошая новость — нам не нужно беспокоиться о том, какие конкретно адреса памяти выделены для определенных
переменных. Мы просто ссылаемся на переменную через присвоенный ей идентификатор, а компилятор конвертирует это имя
в соответствующий адрес памяти. Однако этот подход имеет некоторые ограничения, которые мы обсудим на этом и
следующих уроках.

Оператор адреса & позволяет узнать, какой адрес памяти присвоен определенной переменной. Всё довольно просто:

1 #include<iostream>
2
3 int main()
4 {
5 int a = 7;
6 std::cout << a << '\n'; //выводим значение переменной a
7 std::cout << &a<< '\n'; // выводим адрес памяти переменной a
8
9 return 0;
10 }

Результат на моем компьютере:
7
0046FCF0

Примечание: Хотя оператор адреса выглядит также, как оператор побитового И, отличить их можно потому, что
оператор адреса является унарным оператором, а оператор побитового И — бинарным оператором.


Оператор разыменования *

Оператор разыменования * позволяет получить значение по указанному адресу:

#include <iostream>
 
int main()
{
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес переменной a
    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a
 
    return 0;
}
Результат на моем компьютере:

7
0046FCF0
7

Примечание: Хотя оператор разыменования выглядит так же, как и оператор умножения, отличить их можно по тому, 
что оператор разыменования — унарный, а оператор умножения — бинарный.


Указатели

Теперь, когда мы уже знаем об операторах адреса и разыменования, мы можем поговорить об указателях.
Указатель — это переменная, значением которойявляется адресячейки памяти. Указатели объявляются точно так же, как и
обычные переменные, только со звёздочкой между типом данных и идентификатором:

1 int *iPtr; // указатель назначение типа int
2 double *dPtr; // указательна значение типа double
3
4 int*iPtr3; // корректный синтаксис (допустимый, но не желательный)
5 int * iPtr4; //корректныйсинтаксис (не делайте так)
6
7 int *iPtr5, *iPtr6; // объявляем двауказателя для переменных типа int

Синтаксически язык C++ принимает объявление указателя, когда звёздочка находится рядом с типом данных, с
идентификатором или даже посередине. Обратите внимание, эта звёздочкане является оператором разыменования. Это всего
лишь часть синтаксиса объявления указателя.
Однако, при объявлении нескольких указателей, звёздочка должнанаходиться возле каждого идентификатора. Это легко
забыть, если вы привыкли указывать звёздочку возле типа данных, а не возле имени переменной. Например:

1 int* iPtr3, iPtr4; // iPtr3 - это указатель на значение типа int, а iPtr4 -это обычная переменная типа int!

По этой причине, при объявлении указателя, рекомендуется указывать звёздочку возле имени переменной. Как и обычные
переменные, указатели не инициализируются при объявлении. Содержимым неинициализированного указателя является
обычный мусор.


Присваивание значений указателю

Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть
адресом. Для получения адреса переменной используется оператор адреса:

1 int value= 5;
2 int *ptr = &value; // инициализируем ptr адресом значения переменной

Приведенное выше можно проиллюстрировать следующим образом:

  ptr        value
0012FF7C ---> 5

Вот почему указатели имеют такое имя: ptr содержит адрес значения переменной value, и, можно сказать, ptr указывает
на это значение.
Еще очень часто можно увидеть следующее:

1 #include <iostream>
2
3 int main()
4 {
5 int value = 5;
6 int *ptr = &value; //инициализируем ptr адресом значения переменной
7
8 std::cout << &value << '\n'; // выводим адрес значения переменной value
9 std::cout << ptr << '\n'; // выводим адрес, который хранит ptr
10
11 return 0;
12 }

Результат на моем компьютере:
003AFCD4
003AFCD4

Тип указателя должен соответствовать типу переменной, на которую он указывает:

1 int iValue = 7;
2 double dValue = 9.0;
3                  
4 int *iPtr= &iValue; // ок
5 double *dPtr = &dValue; //ок
6 iPtr= &dValue; // неправильно: указатель типа int не может указывать на адрес переменной типа double
7 dPtr= &iValue;// неправильно: указатель типа double не может указывать на адрес переменной типа int

Следующее не является допустимым:

1 int *ptr = 7;

Это связано с тем, что указатели могутсодержать только адреса, а целочисленный литерал 7 не имеет адреса памяти. Если
вы все же сделаете это,то компилятор сообщит вам, что он не может преобразовать целочисленное значение в
целочисленный указатель.
Язык C++ также не позволит вам напрямую присваивать адреса памяти указателю:

1 double *dPtr = 0x0012FF7C; // не ок: рассматривается как присваивание целочисленного литерала


Оператор адреса возвращает указатель

Стоит отметить, что оператор адреса & не возвращает адрес своего операнда в качестве литерала. Вместо этого он
возвращает указатель, содержащий адрес операнда, тип которого получен из аргумента (например, адрес переменной типа int
передается как адрес указателя на значениетипа int):

1 #include<iostream>
2 #include<typeinfo>
3
4 int main()
5 {
6 int x(4);
7 std::cout << typeid(&x).name();
8
9 return 0;
10 }

Результат выполнения программы:
int *


Разыменование указателей

Как только у нас есть указатель, указывающий на что-либо, мы можем его разыменовать, чтобы получить значение, на которое 
он указывает. Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает:

#include <iostream>
 
int main()
{
	int value = 5;
	std::cout << &value << std::endl; // выводим адрес value
	std::cout << value << std::endl; // выводим содержимое value
 
	int *ptr = &value; // ptr указывает на value
	std::cout << ptr << std::endl; // выводим адрес, который хранится в ptr, т.е. &value
	std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)
 
	return 0;
}
Результат:

0034FD90
5
0034FD90
5

Вот почему указатели должны иметь тип данных. Без типа указатель не знал бы, как интерпретировать содержимое, 
на которое он указывает (при разыменовании). Также, поэтому и должны совпадать тип указателя с типом переменной. 
Если они не совпадают, то указатель при разыменовании может неправильно интерпретировать биты (например, 
вместо типа double использовать тип int).

Одному указателю можно присваивать разные значения:

int value1 = 5;
int value2 = 7;
 
int *ptr;
 
ptr = &value1; // ptr указывает на value1
std::cout << *ptr; // выведется 5
 
ptr = &value2; // ptr теперь указывает на value2
std::cout << *ptr; // выведется 7

Когда адрес значения переменной присвоен указателю, то выполняется следующее:

    ptr — это то же самое, что и &value;
   *ptr обрабатывается так же, как и value.

Поскольку *ptr обрабатывается так же, как и value, то мы можем присваивать ему значения так, как 
если бы это была обычная переменная. Например:

int value = 5;
int *ptr = &value; // ptr указывает на value
 
*ptr = 7; // *ptr - это то же самое, что и value, которому мы присвоили значение 7
std::cout << value; // выведется 7


Разыменование некорректных указателей

Указатели в языке C++ по своей природе являются небезопасными, а их неправильное использование — один 
из лучших способов получить сбой программы.

При разыменовании указателя, программа пытается перейти в ячейку памяти, которая хранится в указателе и 
извлечь содержимое этой ячейки. По соображениям безопасности современные операционные системы (ОС) запускают
программы в песочнице для предотвращения их неправильного взаимодействия с другими программами и для защиты 
стабильности самой операционной системы. Если программа попытается получить доступ к ячейке памяти, не 
выделенной для нее операционной системой, то ОС сразу завершит выполнение этой программы.

Следующая программа хорошо иллюстрирует вышесказанное. При запуске выполучите сбой (попробуйте, ничего страшного 
с вашим компьютером непроизойдет):

1 #include <iostream>
2
3  void foo(int *&p)
4  {
5  }
6
7 int main()
8 {
9 	int *p; //создаем неинициализированный указатель (содержимым которогоявляется мусор)
10 	foo(p); //вводим компилятор в заблуждение, будто бы собираемся присвоить указателю корректное значение
11
12 std::cout << *p; // разыменовываем указатель с мусором
13
14 return 0;
15 }


Размер указателей

Размер указателя зависит от архитектуры, на которой скомпилирован исполняемый файл: 32-битный исполняемый файл
использует 32-битные адреса памяти. Следовательно, указатель на 32-битном устройстве занимает 32 бита(4  байта). 
С 64-битным исполняемым файлом указатель будет занимать 64 бита (8 байт). И это вне зависимости от того, на что указывает
указатель:

1 char *chPtr; // тип char занимает 1 байт
2 int *iPtr; // тип int занимает 4 байта
3
4 struct Something
5 {
6 	int nX, nY, nZ;
7 };
8
9 Something *somethingPtr;
10
11 std::cout << sizeof(chPtr) << '\n'; // выведется 4
12 std::cout << sizeof(iPtr)<< '\n'; // выведется 4
13 std::cout << sizeof(somethingPtr) << '\n'; // выведется 4

Как вы можете видеть, размер указателя всегда один и тот же. Это связано с тем, что указатель — это всего лишь
адрес памяти, аколичество бит, необходимое для доступа к адресу памяти на определенном устройстве, — всегда постоянное.


В чём польза указателей?

Сейчас вы можете подумать, что указатели являются непрактичными и вообще ненужными. Зачем использовать указатель,
если мы можем использовать исходную переменную?

Однако, оказывается, указатели полезны вследующих случаях:
 Случай No 1: Массивы реализованы с помощью указателей. Указатели могут использоваться для итерации по массиву.
 Случай No 2: Они являются единственным способом динамического выделения памяти в C++. Это, безусловно,
               самый распространенный вариант использования указателей.
 Случай No 3: Они могут использоваться для передачи большого количества данных в функцию без копирования
               этих данных.
 Случай No 4: Они могут использоваться для передачи одной функции в качестве параметра другой функции.
 Случай No 5: Они используются для достижения полиморфизма при работе с наследованием.
 Случай No 6: Они могут использоваться для представления одной структуры/класса в другой структуре/классе,
               формируя, таким образом, целые цепочки.

Указатели применяются во многих случаях. Не волнуйтесь, если вы многого не понимаете из вышесказанного. Теперь, когда
мы разобрались с указателями на базовом уровне, мы можем начать углубляться в отдельные случаи, в которых они полезны,
что мы и сделаем на последующих уроках.

Заключение
Указатели — это переменные, которые содержат адреса памяти. Их можно разыменовать с помощью оператора
разыменования * для извлечения значений, хранимых по адресу памяти. Разыменование указателя, значением которого
является мусор, приведетк  сбою в вашей программе.

Совет: При объявлении указателя указывайте звёздочку возле имени переменной.

 	
Тест

Задание No 1

Какие значения мы получим в результате выполнения следующей программы (предположим, что тип short занимает 2 байта):

1 short value = 7; //&value = 0012FF60
2 short otherValue = 3; // &otherValue = 0012FF54
3
4 short *ptr = &value;
5
6 std::cout << &value << '\n';  	0012FF60
7 std::cout << value << '\n';		7
8 std::cout << ptr <<'\n';		0012FF60
9 std::cout << *ptr << '\n';		7
10 std::cout << '\n';
11
12 *ptr = 9;
13
14 std::cout << &value<< '\n';		0012FF60
15 std::cout << value << '\n';		9
16 std::cout << ptr <<'\n';             0012FF60
17 std::cout << *ptr << '\n';		9
18 std::cout << '\n';
19
20 ptr= &otherValue;
21
22 std::cout << &otherValue << '\n';    0012FF54
23 std::cout << otherValue << '\n';	3
24 std::cout << ptr <<'\n';             0012FF54
25 std::cout << *ptr << '\n';		3
26 std::cout << '\n';
27
28 std::cout << sizeof(ptr) << '\n';     4
29 std::cout << sizeof(*ptr)<< '\n';     2




ОтветNo1

Значения:

0012FF60
7
0012FF60
7

0012FF60
9
0012FF60
9

0012FF54
3
0012FF54
3

4
2

Краткое объяснение по поводу последней пары: 4 и 2. 32-битное устройство означает, что размер указателя составляет 
32 бита, но оператор sizeof всегда выводит размер в байтах: 32 бита = 4 байта. Таким образом, sizeof(ptr) равен 4. 
Поскольку ptr является указателем на значение типа short, то *ptr является типа short. Размер short в этом примере 
составляет 2 байта. Таким образом, sizeof(*ptr) равен 2.



Задание No2

Что не так со следующим фрагментом кода:

1 int value= 45;
2 int *ptr = &value; // объявляемуказатель и инициализируемего адресом переменной value
3 *ptr= &value; // присваиваем адрес value для ptr

&value занимает 4 байта и не поместится в value, которое занимает 2 байта.

Ответ No 2

Последняя строка не скомпилируется. Рассмотрим эту программу детально.

В первой строке находится стандартное определение переменной вместе с инициализируемым значением. Здесь ничего особенного.

Во второй строке мы определяем новый указатель с именем ptr и присваиваем ему адрес переменной value. 
Помним, что в этом контексте звёздочка является частью синтаксиса объявления указателя, а не оператором разыменования. 
Так что и в этой строке всё нормально.

В третьей строке звёздочка уже является оператором разыменования, и используется для вытаскивания значения, на которое 
указывает указатель. Таким образом, эта строка говорит: «Вытаскиваем значение, на которое указывает ptr (целочисленное значение), 
и переписываем его на адрес этого же значения». А это уже какая-то чепуха — вы не можете присвоить адрес целочисленному значению!

Третья строка должна быть:

ptr = &value;

В вышеприведенной строке мы корректно присваиваем указателю адрес значения переменной.