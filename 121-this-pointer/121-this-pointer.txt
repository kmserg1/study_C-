Урок No 121. Скрытый указатель *this


Один из частых вопросов, которые новички задают по поводу классов: «При вызове метода класса, как C++ отслеживает то,
какой объект его вызвал?». Ответ заключается в том, что C++ для этих целей использует скрытый указатель *this!

Оглавление:
1. Скрытый указатель*this
2. Указатель *thisвсегда указывает на текущий объект
3. Явное указание указателя*this
4. Цепочки методов класса
5. Заключение


Скрытый указатель *this

Ниже приведен простой класс, который содержит целочисленное значение и имеет конструктор и функции доступа.
Обратите внимание, деструктор здесь не нужен, таккак язык C++ может очистить память после переменной-члена
самостоятельно:

1 #include <iostream>
2
3 class Another
4 {
5 private:
6 	int m_number;
7
8 public:
9 	Another(int number)
10 	{
11 		setNumber(number);
12 	}
13
14 	void setNumber(int number) { m_number = number; }
15 	int getNumber() { return m_number; }
16 };
17
18 int main()
19 {
20 	Another another(3);
21 	another.setNumber(4);
22 	std::cout << another.getNumber() << '\n';
23
24 	return 0;
25 }

Результат выполнения программы:
4

При вызове another.setNumber(4); C++ понимает,что функция setNumber() работает с объектом another , а m_number
— это фактически another.m_number. Рассмотрим детально, как это всё работает.

Возьмем, к примеру, следующую строку:
1 another.setNumber(4);

Хотя на первый взгляд кажется, что унас здесь только один аргумент, но на самом делеу нас их два! Во время компиляции
строка another.setNumber(4); конвертируется компилятором в следующее:

1 setNumber(&another, 4); // объект another конвертировался из объекта, который находился перед точкой, в аргумент функции

Теперь это всего лишь стандартный вызов функции, а объект another (который ранее был отдельным объектом и
находился перед точкой) теперь передается по адресу в качестве аргумента функции.
Но это только половина дела. Поскольку в вызове функции теперь есть два аргумента, то и метод нужно изменить
соответствующим образом (чтобы он принимал два аргумента). Следовательно, следующий метод:

1 void setNumber(int number) { m_number = number; }

Конвертируется компилятором в:
1 void setNumber(Another* const this, int number) { this->m_number = number; }

При компиляции обычного метода, компилятор неявно добавляет кнему параметр *this. Указатель *this — это скрытый
константный указатель, содержащий адрес объекта, который вызывает метод класса.

Есть еще одна деталь. Внутри метода также необходимо обновить все члены класса (функции и переменные), чтобы они
ссылались на объект, который вызывает этот метод. Это легко сделать, добавив префикс this-> к каждому из них. Таким
образом, в теле функции setNumber(), m_number (переменная-член класса) будет конвертирована в this->m_number . И
когда *this указывает на адрес another, то this->m_number будет указывать на another.m_number.

Соединяем всё вместе:

 При вызове another.setNumber(4) компилятор фактически вызывает setNumber(&another, 4) .
 Внутри setNumber() указатель *this содержит адрес объекта another .
 К любым переменным-членам внутри setNumber() добавляется префикс this->. Поэтому, когда мы говорим
m_number = number , компилятор фактически выполняет this->m_number = number , который, в этом случае, обновляет
another.m_number на number .

Хорошей новостью является то, что это всё происходит скрыто от нас (программистов), и не имеет значения, помните ли
вы, как это работает или нет. Всё, что вамнужно запомнить — все обычные методы класса имеют указатель *this, который
указывает на объект, связанный с вызовом метода класса.

Указатель *this всегда указывает на текущий объект
