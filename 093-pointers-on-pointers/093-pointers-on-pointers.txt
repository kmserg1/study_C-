Урок No 93.Указатели на указатели


Указатель на указатель — это именно то, что вы подумали: указатель, который содержит адрес другого указателя.
Оглавление:
1. Указатели на указатели
2. Массивы указателей
3. Двумерные динамически выделенные массивы
4. Указатель на указатель на указатель на указатель и т.д.
5. Заключение


Указатели на указатели

Обычный указатель типа int объявляется с использование модной звёздочки:

1 int *ptr; // указатель типа int, одна звёздочка

Указатель на указатель типа int объявляется с использованием двух звёздочек:

1 int **ptrptr; // указательнауказатель типаint (двезвёздочки)

Указатель на указатель работает подобнообычному указателю: выможете его разыменовать для получения значения, на
которое он указывает. И, поскольку этим значением является другой указатель, для получения исходного значения вам
потребуется выполнить разыменование еще раз. Их следует выполнять последовательно:
1 #include <iostream>
2
3 int main()
4 {
5 int value= 7;
6
7 int *ptr = &value;
8 std::cout<<*ptr << std::endl; // разыменовываем указатель, чтобы получить значение типа int
9
10 int **ptrptr= &ptr;
11 std::cout << **ptrptr << std::endl;
12
13 return 0;
14 }

Результат выполнения программы:
7
7

Обратите внимание, вы не можете инициализировать указатель на указатель напрямую значением:

1 int value =7;
2 int **ptrptr =&&value;//нельзя

Это связано с тем, что оператор адреса(&) требует l-value, но &value — это r-value.
Однако указателю на указатель можно задать значение null:

1 int **ptrptr =nullptr; //используйте 0, если не поддерживается C++11


Массивы указателей

Указатели на указатели имеют несколько применений.
Наиболее используемым является динамическое выделение массива указателей:

1 int **array= newint*[20]; // выделяем массив из 20 указателейтипа int

Это тотже обычный динамически выделенный массив, за исключением того, что элементами являются указатели 
на тип int, а не значения типа int.


Двумерные динамически выделенные массивы

Другим распространенным применением указателей на указатели является динамическое выделение многомерных
массивов. В отличие от двумерного фиксированного массива, который можно легко объявить следующим образом:

1 int array[15][7];

динамическое выделение двумерного массива немного отличается. У вас может возникнуть соблазн написать 
что-то вроде следующего:

1 int **array= newint[15][7]; // не будет работать!

Здесь вы получите ошибку. Есть двавозможных решения. Если правый индексявляется константойтипа compile-time,
то выможете сделать следующее:

1 int (*array)[7] = new int[15][7];

Скобки здесь потребуются для соблюдения приоритета. В C++11 хорошей идеей будет использовать ключевое слово
auto для автоматического определения типа данных:

1 auto array = new int[15][7]; // намного проще!

К сожалению, это относительно простое решение не работает, если правый индекс не является константой типа
compile-time. В таком случае всё немного усложняется. Сначала мы выделяем массив указателей (как в примере, 
приведенном выше), а затем перебираем каждый элемент массива указателей и выделяем динамический массив для 
каждого элемента этогомассива. Итого, наш динамический двумерный массив — этодинамический одномерный массив
динамических одномерных массивов!

1 int **array= new int*[15]; // выделяем массив из 15 указателейтипа int — этонаши строки
2 for (int count= 0; count < 15; ++count)
3 	array[count] = new int[7]; // а это наши столбцы

Доступ к элементам массива выполняется как обычно:

1 array[8][3]= 4; // это то же самое, что и (array[8])[3] = 4;

Этим методом, поскольку каждый столбец массива динамически выделяется независимо, можно сделать динамически
выделенные двумерные массивы, которые не являются прямоугольными. Например, мы можем создать массив
треугольной формы:

1 int **array= newint*[15]; // выделяем массив из 15 указателейтипа int— этонаши строки
2 for (intcount= 0; count < 15; ++count)
3 	array[count] = new int[count+1]; // аэто наши столбцы

В примере, приведенном выше, array[0] — этомассив длиной 1, а array[1] — массив длиной 2 и т.д.
Для освобождения памяти динамически выделенного двумерного массива (который создавался с помощью этого способа)
также потребуется цикл:

1 for (intcount= 0; count < 15; ++count)
2 	delete[] array[count];
3 delete[] array; // это следует выполнять в конце

Обратите внимание, мыудаляем массив в порядке, противоположном его созданию. Еслимы удалим массив перед
удалением элементов массива, то нам придется получать доступ к освобожденной памяти для удаления элементов массива.
А это,в свою очередь, приведет к неожиданным результатам.

Поскольку процесс выделения и освобождения двумерных массивов является несколько запутанным (можно легко
наделать ошибок), то часто проще «сплющить» двумерныймассив в одномерный массив:

1 //Вместо следующего:                                                   
2 int **array= newint*[15]; // выделяем массив из 15 указателейтипа int — этонаши строки
3 for (intcount= 0; count < 15; ++count)
4 	array[count] = new int[7]; // аэто наши столбцы
5
6 //Делаем следующее:
7 int *array = new int[105]; // двумерный массив 15x7 "сплющенный" в одномерный массив

Простая математика используется для конвертации индексов строки и столбца прямоугольного двумерного массива
в один индекс одномерного массива:

1 int getSingleIndex(int row, int col, int numberOfColumnsInArray)
2 {
3   return(row * numberOfColumnsInArray) + col;
4 }
5
6 //Присваиваем array[9,4] значение 3, используянаш "сплющенный" массив
7 array[getSingleIndex(9,4,5)] = 3;


Указатель на указатель на указатель на указатель и т.д.

Также можно объявить указатель на указатель на указатель:

1 int ***ptrx3;

Они могут использоваться для динамического выделения трехмерного массива. Тем не менее, для этого потребуется цикл
внутри цикла и чрезвычайная аккуратность и осторожность, чтобы не наделать ошибок. Вы даже можете объявить
указатель на указатель на указатель на указатель:
1 int ****ptrx4;

Или сделать еще большую вложенность, если захотите. Однако на практике такие указатели редко используются.

Заключение

Рекомендуется применять указатели на указатели только в самых крайних случаях, так как они сложны в использовании
и потенциально опасны. Достаточно легко разыменовать нулевой или «висячий» указатель в ситуациях с использованием
обычных указателей, вдвое легче это сделать в ситуациях с указателем на указатель, поскольку для получения исходного
значения потребуется выполнить двойное разыменование!

