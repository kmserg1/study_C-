Урок No 48. Локальныепеременные, область видимости и продолжительность жизни

Этотматериалявляется продолжением урока No15.
Оглавление:
1. Область видимостии продолжительность жизни
2. Сокрытие имен
3. Область видимости переменных
4. Параметры функций
5. Заключение
6. Тест


Область видимости и продолжительность жизни

Прежде чем мы начнем, нам нужно сначала разобраться с двумя терминами: область видимости и
продолжительность жизни.
Область видимости определяет, где можно использовать переменную. Продолжительность 
жизни (или«времяжизни») определяет, где переменная создается и где уничтожается.
Эти две концепции связаны между собой.
Переменные, определенные внутри блока, называются локальными переменными. Локальные
переменные имеют автоматическую продолжительность жизни: они создаются (и инициализируются,
если необходимо) в точке определения и уничтожаются при выходе из блока.
Локальные переменные имеют локальную область видимости (или «блочную»), т.е.они входят
в область видимости с точки объявления и выходят в самом конце блока, в котором определены.
Например, рассмотрим следующую программу:

1 #include <iostream>
2
3 int main()
4 {
5 int x(4); // переменная x создается и инициализируется здесь
6 double y(5.0); // переменная y создается и инициализируется здесь
7
8 return 0;
9
10 } // x и y выходят из области видимости и уничтожаются здесь

Поскольку переменные x и y определены внутри блока, который является главной функцией, то
они обе уничтожаются, когда main() завершает свое выполнение.
Переменные, определенные внутри вложенных блоков, уничтожаются, как только заканчивается
вложенный блок:

1 #include <iostream>
2
3 int main() // внешний блок
4 {
5 int m(4); // переменная m создается и инициализируется здесь
6
7 { // начало вложенного блока
8 	double k(5.0); // переменная k создается и инициализируется здесь
9 } // k выходит из области видимости и уничтожается здесь
10
11 // Переменная k неможет быть использована здесь, так как она уже уничтожена!
12
13 return 0;
14 }// переменная m выходит из области видимости и уничтожается здесь

Такие переменные можно использовать только внутри блоков, в которых они определены.
Поскольку каждая функция имеет свойсобственный блок, то переменные из одной функции никак
не соприкасаются и не влияют на переменные из другой функции:

1 #include <iostream>
2
4 {
3 void someFunction()
5 int value(5); // value определяется здесь
6
7 // value можно использовать здесь
8
9 } // value выходит из области видимости и уничтожается здесь
10
11 int main()
12 {
13 // value нельзя использовать внутри этой функции
14
15 someFunction();
16
17 // value здесь также нельзя использовать
18
19 return 0;
20 }
 
В разных функциях могут находиться переменные или параметры с одинаковыми именами.
Это хорошо, потому что не нужно беспокоиться о возможности возникновения конфликтов имен
между двумя независимыми функциями. В примере, приведенном ниже, в обеих функциях есть
переменные x и y. Они даже не подозревают о существовании друг друга:

1 #include <iostream>
2
3 // Параметр x можноиспользовать только внутри функции add()
4 int add(int x, int y) // параметр x функции add() создается здесь
5 {
6 return x+y;
7 } // параметр x функции add() уничтожается здесь
9 // Переменную x функции main() можно использовать только внутрифункции main()
8
10 int main()
11 {
12 int x = 5; //переменная x функции main() создается здесь
13 int y = 6;
14 std::cout << add(x, y)<< std::endl; // значение x функции main() копируется в переменную x функции add()
15 return 0;
16 } // переменнаяx функции main() уничтожается здесь

Вложенные блоки считаются частью внешнего блока, в котором они определены. Следовательно,
переменные, определенные во внешнем блоке, могут быть видны и внутри вложенного блока:
1 #include <iostream>
2
3 int main()
4 { // начало внешнего блока
5
6 int x(5);
7
8 	{ // начало вложенного блока
9	 int y(7);
10	 / /Мы можем использовать x и y здесь
11	 std::cout << x << " + "<< y << " = "<< x +y;
12 	} // переменная y уничтожается здесь
13
14 // Переменную y здесь нельзя использовать, посколькуона уже уничтожена!
15
16 return 0;
17 }// переменная x уничтожается здесь


Сокрытие имен

Переменная внутри вложенного блокаможет иметьто же имя, что и переменная внутри
внешнего блока. Когда подобное случается, то переменная во вложенном (внутреннем) блоке
«скрывает» внешнюю переменную. Это называется сокрытием имен:

1 #include <iostream>
2
3 int main()
4 { // внешнийблок
6
5 int oranges(5); // внешняя переменная oranges
7 if (oranges>= 5) //относится к внешней oranges
8 	{ //вложенный блок
9	 int oranges; // скрывается внешняяпеременная oranges
10
11 	 // Идентификатор oranges теперь относится к вложенной переменной oranges.
12	 //Внешняя переменная oranges временно скрыт
13
14	 oranges=10; //здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней
15
16	 std::cout << oranges << std::endl; //выводим значение вложенной переменной oranges
17	 } //вложенная переменная oranges уничтожается
18
19 // Идентификатор oranges опять относится к внешней переменной oranges
20
21 std::cout << oranges << std::endl; // выводим значение внешней переменной oranges
22
23 return 0;
24 } // внешняя переменная oranges уничтожается

Результат выполненияпрограммы:
10
5

Здесь мы сначала объявляем переменную oranges во внешнем блоке. Затем объявляем вторую
переменную oranges, но уже во вложенном (внутреннем) блоке. Когда мы присваиваем oranges
значение 10, то оно относится к переменной во вложенном блоке. После вывода этого значения
(и окончания внутреннего блока), внутренняя переменная oranges уничтожается, оставляя
внешнюю oranges с исходным значением ( 5 ), которое затем выводится. Результат выполнения
программы был бы тот же, даже если бы мы назвали вложенную переменную по-другому
(например, nbOranges).

Обратите внимание, если бы мы не определили вложенную переменную oranges, то
идентификатор oranges относился бы к внешней переменной и значение 10 было бы
присвоено внешней переменной:

1 #include <iostream>
2
3 int main()
4 { // внешний блок
5 int oranges(5);//внешняя переменная oranges
6 
7 if (oranges>= 5) //относится к внешней переменной oranges
8	 {//вложенный блок
9	 //Никакогоопределениявнутреннейпеременной orangesздесь нет
10
11	 oranges=10; //этоприменяетсяквнешней переменнойoranges,хотьмы инаходимся во вло
12
13	 std::cout<< oranges<<std::endl;//выводим значение внешнейпеременной oranges
14	 }//значением переменной oranges будет 10 даже после того,как мывыйдемизвложенногоблока
15
16 std::cout << oranges<< std::endl;// выводимзначение переменной oranges
17
18 return 0;
19 } // переменнаяoranges уничтожается

Результат выполнения программы:
10
10

В обоих примерах на внешнюю переменную oranges никак не влияет то, что происходит с
вложенной переменной oranges. Единственное различие между двумя программами — это то, 
к чему применяется выражение oranges=10.

Сокрытие имен — это то, чего, как правило, следует избегать, поскольку оно может быть
довольно запутанным!

Правило: Избегайте использования вложенных переменных с именами, идентичными
именам внешних переменных.


Область видимости переменных.

Переменные должны определяться в максимально ограниченной области видимости.
Например, если переменная используется только внутри вложенного блока, то она и должна быть
определена в нем:
1 #include< iostream>
2
3 int main()
4 {
5 // Не определяйте x здесь
6
7 	{
8 	// Переменная x используется только внутри этого блока, поэтому определяем её здесь
9 	int x(7);
10 	std::cout << x;
11 	}
12
13 // В противном случае, переменная x может быть использована и здесь
14
15 return 0;
16 }

Ограничивая область видимости, мы уменьшаем сложность программы, поскольку число
активных переменных уменьшается. Таким образом, легче увидеть, где какие переменные
используются. Переменная, определенная внутри блока, может использоваться только внутри
этого же блока (или вложенных в него подблоков). Этим мы упрощаем понимание и логику
программы.
Если во внешнем блоке нужна переменная, то её необходимо объявлять во внешнем блоке:

1 #include <iostream>
2
3 int main()
4 {
5 int y(5); // мы объявляем переменную y здесь, потому что она нам будет нужна как во внутреннем блоке, так и во внешнем
6
7 	{
8	 int x;
9	 std::cin >>x;
10	 // Если бы мы объявили y здесь, непосредственно перед её первым фактическим использованием
11	 if(x == 4)
12		 y =4;
13	 } // то она бы уничтожилась здесь
14
15 std::cout << y; // а переменная y нам нужна еще здесь
16
17 return 0;
18 }

Это один из тех редких случаев, когда вам может понадобиться объявить переменную до её
первого использования.

Правило: Определяйте переменные в наиболее ограниченной области видимости.


Параметры функций

Хотя параметры функций не определяются внутри основного блока(тела) функции, в
большинстве случаев они имеют локальную область видимости:
1 int max(intx, inty) // x и y определяются здесь
2{
3 // Присваиваем большее из значений (x или y) переменной max
4 int max=(x>y)?x:y; // max определяется здесь
5 return max;
6} //x, y и max уничтожаются здесь

Заключение

Переменные, определенные внутри блоков, называются локальными переменными. Они
доступны только внутри блока, в котором определены (включая вложенные блоки) и
уничтожаются при завершении этого же блока.
Определяйте переменные в наиболее ограниченной области видимости. Если переменная
используется только внутри вложенного блока, то и определять её следует внутри этого же
вложенного блока.

Тест

Задание No1
Напишите программу, которая просит пользователя ввести два целых числа: второе должно быть
больше первого. 
Если пользователь введет второе число меньше первого, то используйте блок и
временную переменную, чтобы поменять местами пользовательские числа. Затем выведите
значения этих переменных. Добавьте в свой код комментарии, объясняющие, где и какая
переменная уничтожается.

Результат выполнения программы должен быть примерно следующим:

Введите число: 4
Введите большее число: 2
Меняем значения местами
Меньшее число: 2
Большее число: 4

Подсказка: Чтобы использовать кириллицу, добавьте следующую строчку кода в самое
началофункции main():
1 setlocale(LC_ALL,"rus");

Ответ No1


Задание No2
В чём разница междуо бластью видимости и продолжительностью жизни переменной? Какую
область видимости и продолжительность жизни по умолчанию имеют локальные переменные (и
что это значит)?

Ответ No2

