Урок No122. Классы и заголовочные файлы


На этом урокемы рассмотрим работу классов с заголовочными файлами в языке С++.

Оглавление:
1. Отделение объявления от реализации
2. Классы и заголовочные файлы
3. Параметры по умолчанию
4. Библиотеки
5. Заключение


Отделение объявления от реализации

Все классы, которые мы использовали до сих пор, были достаточно простыми, поэтому мы записывали методы
непосредственно внутри тела классов, например:

1 class Date
2 {
3 private:
4 	int m_day;
5 	int m_month;
6 	int m_year;
7
8 public:
9 	Date(int day, int month, int year)
10 	{
11 		setDate(day, month, year);
12 	}
13
14 	void setDate(int day, int month, int year)
15 	{
16 		m_day = day;
17 		m_month = month;
18 		m_year = year;
19 	}
20
21 	int getDay() { return m_day; }
22 	int getMonth() { return m_month; }
23 	int getYear() { return m_year; }
24 };

Однако, как только классы становятся больше и сложнее, наличие всех методов внутри тела класса может затруднить его
управление и работус ним. Использование уже написанного класса требует понимания только его открытого
интерфейса, а не того, как он реализован «под капотом».

К счастью, язык C++ предоставляет способ отделить «объявление» от «реализации». Это делается путем определения
методов вне тела самого класса. Для этого просто определите методы класса, как если бы они были обычными функциями,
но в качестве префикса добавьте к имени функции имякласса с оператором разрешения области видимости ( :: ).
Вот наш класс Date с конструктором Date() и методом setDate(), определенными вне тела класса. Обратите внимание,
прототипы этих функций все еще находятся внутри тела класса, но их фактическая реализациян аходится за его
пределами:

1 class Date
2 {
3 private:
4 	int m_day;
5 	int m_month;
6 	int m_year;
7
8 public:
9 	Date(int day, int month, int year);
10
11 	void SetDate(int day, int month, int year);
12
13 	int getDay() { return m_day; }
14 	int getMonth() { return m_month; }
15 	int getYear() { return m_year; }
16 };
17
18 // Конструктор класса Date
19 Date::Date(int day, int month, int year)
20 {
21 	SetDate(day, month, year);
22 }
23
24 // Метод класса Date
25 void Date::SetDate(int day, int month, int year)
26 {
27 	m_day = day;
28 	m_month = month;
29 	m_year = year;
30 }

Просто, не так ли? Поскольку во многих случаях функции доступа могут состоять всего из одной строки кода, то их обычно
оставляют в теле класса, хотя переместить их за пределы класса можно всегда.
Вот еще один пример класса с конструктором, определенным извне, со списком инициализации членов:

1 class Mathem
2 {
3 private:
4 int m_value = 0;
5
6 public:
7 Mathem(int value=0): m_value(value) {}
8
9 Mathem& add(int value) { m_value+= value; return *this; }
10 Mathem& sub(int value) { m_value -= value; return *this; }
11 Mathem& divide(int value) { m_value /= value; return *this; }
12
13 int getValue() { return m_value ; }
14 };

Конвертируем в:

1 class Mathem
2 {
3 private:
4 	int m_value = 0;
5
6 public:
7 	Mathem(int value=0);
8
9 	Mathem& add(int value);
10 	Mathem& sub(int value);
11 	Mathem& divide(int value);
12
13 	int getValue() { return m_value; }
14 };
15
16 Mathem::Mathem(int value): m_value(value)
17 {
18 }
19
20 Mathem& Mathem::add(int value)
21 {
22 	m_value += value;
23 	return *this;
24 }
25
26 Mathem& Mathem::sub(int value)
27 {
28 	m_value -= value;
29 	return *this;
30 }
31
32 Mathem& Mathem::divide(int value)
33 {
34 	m_value /= value;
35 	return *this;
36 }


Классы и заголовочные файлы

На уроке о заголовочных файлах в языке С++ мы узнали, что объявления функций можно поместить в заголовочные
файлы, чтобы затем иметь возможность использовать эти функции в нескольких файлах или даже в нескольких проектах.
Классы в этом плане ничем не отличаются от функций. Определения классов могут быть помещены в заголовочные файлы
для облегчения их повторного использования в нескольких файлах или проектах. Обычно, определение класса
помещается в заголовочный файл с тем жеименем, что у класса, а методы, определенные вне тела класса, помещаются в
файл .cpp стем же именем, что у класса.

Вот наш класс Date, но уже разбитый на файлы .cpp и .h:

Date.h:
1 #ifndef DATE_H
2 #define DATE_H
3
4 class Date
5 {
6 private:
7 	int m_day;
8 	int m_month;
9 	int m_year;
10
11 public:
12 	Date(int day, int month, int year);
13
14 void SetDate(int day, int month, int year);
15
16 	int getDay() { return m_day; }
17 	int getMonth() { return m_month; }
18 	int getYear() { return m_year; }
19 };
20
21 #endif

Date.cpp:
1 #include "Date.h"
2
3 // Конструктор класса Date
4 Date::Date(int day, int month, int year)
5 {
6 	SetDate(day, month, year);
7 }
8
9 // Метод класса Date
10 void Date::SetDate(int day, int month, int year)
11 {
12 	m_day = day;
13 	m_month = month;
14 	m_year = year;
15 }

Теперь любой другой файл .h или .cpp, который захочет использовать класс Date, сможет просто подключить заголовочный
файл: #include "Date.h". Обратите внимание, Date.cpp также необходимо добавить до компиляции в проект, который
использует Date.h, чтобы линкер смог разобраться с реализацией класса Date.

Вопрос No 1: «Разве определение класса в заголовочном файле не нарушает правило одного определения?».

Нет. Классы — это пользовательские типы данных, которые освобождаются от определения только в одном месте. Поэтому
класс, определенный в заголовочном файле, можно свободно подключатьв другие файлы.

Вопрос No 2: «Разве определения методов класса в заголовочном файле не нарушает правило одного
определения?».

Методы, определенные внутри тела класса, считаются неявно встроенными. Встроенные функции освобождаются от
правила одного определения. А это означает, что проблем с определением простых методов (таких как функции доступа)
внутри самого класса возникать не должно.
Методы, определенные вне тела класса, рассматриваются, как обычные функции, и подчиняются правилу одного
определения, поэтому эти функции должны быть определены в файле .cpp, а не внутри.h. Единственным исключением
являются шаблоны функций (но об этом чуть позже).


Параметры по умолчанию

Параметры по умолчанию для методов должны быть объявлены в теле класса (в заголовочном файле), где они будут
видны всем, кто подключает этотзаголовочный файл с классом.


Библиотеки

Разделение объявления класса и его реализации очень распространено в библиотеках, которые используются для
расширения возможностей вашей программы. Вы также подключали такие заголовочные файлы из Стандартной
библиотеки С++, как iostream, string, vector, array и другие. Обратите внимание, вы не добавляли iostream.cpp, string.cpp,
vector.cpp или array.cpp в ваши проекты. Ваша программа нуждается только в объявлениях из заголовочных файлов, чтобы
компилятор смог проверить корректность вашего кода в соответствии с правилами синтаксиса языка C++. Однако
реализации классов, находящихся в Стандартной библиотеке С++, содержатся в предварительно скомпилированном файле,
который добавляется на этапе линкинга. Вы нигде не встречаете этот код.
Вне программ с открытым исходным кодом (где предоставляются оба файла:.h и .cpp), большинство сторонних библиотек
предоставляют только заголовочные файлы вместе с предварительно скомпилированным файлом библиотеки. На этоесть
несколько причин:

 На этапе линкинга быстрее будет подключить предварительно скомпилированную библиотеку, чем выполнять
перекомпиляцию каждый раз, когда она нужна.
 Защита интеллектуальной собственности (создатели не хотят, чтобы другие просто «воровали» их код).
Наличие собственных файлов, разделенных на объявление (файлы .h) и реализацию (файлы .cpp), является не только
хорошей формой содержания кода, но и упрощает создание собственных пользовательских библиотек.


Заключение

Возможно, у вас возникнет соблазн поместить все определения методов класса в заголовочный файл внутри тела класса.
Хотя это скомпилируется, но здесь есть несколько нюансов:

 Во-первых, как упоминалось выше, это приведет к загромождению определения вашего класса.

 Во-вторых, функции, определенные внутри класса, являются неявно встроенными. Большие функции, которые
вызываются из многих файлов, могут способствовать, таким образом, «раздуванию» вашего кода.

 В-третьих,если вы изменитечто-либо в заголовочном файле, то вам нужно будет перекомпилировать каждый файл,
содержащий этот заголовок. Это может иметь «эффект бабочки», когда одно незначительное изменение заставит
перекомпилировать всю программу (что можетбыть достаточно медленно и долго). Если же вы изменили код в файле
.cpp, то вам необходимо перекомпилировать только этот файл.cpp!

Поэтому рекомендуется следующее:
 Классы, используемые только в одном файле, и которые повторно не используются, определяйте непосредственно в
файле.cpp, где они используются.
 Классы, используемые в нескольких файлах или предназначенные для повторного использования, определяйте в
заголовочном файле с тем же именем, что у класса.
 Тривиальные методы (обычные конструкторы или деструкторы, функции доступа и т.д.) определяйте внутри тела
класса.
 Нетривиальные методы определяйте в файле .cpp с тем же именем, что у класса.

На следующих уроках большинство наших классов будут определены в файле .cpp со всеми методами, реализованными
непосредственно в теле класса. Это делается для удобства и лаконичности примеров. В реальных проектах лучше, когда
классы помещаютсяв отдельные файлы .cpp и .h.