Урок No 104. Указатели на функции

На уроке No 80 мы узнали, чтоуказатель — это переменная, которая содержит адрес другой переменной.
Указатели на функции аналогичны, заисключением того, что вместо обычных переменных, они указывают на функции!

Оглавление:
1.Указатели на функции
2.Присваивание функции указателю на функцию
3.Вызов функции через указатель на функцию
4.Передача функций в качестве аргументов другим функциям
5.Параметры по умолчанию в функциях
6.Указатели на функции и псевдонимы типов
7.Использование std::function в C++11
8.Заключение
9.Тест


Указатели на функции

Рассмотрим следующий фрагмент кода:

1 int boo()
2 {
3 return 7;
4 }

Идентификатор boo — это имя функции. Но какой её тип? Функции имеют свой собственный l-value тип. 
В нашем случае это тип функции, который возвращает целочисленное значениеи не принимает никаких параметров.
Подобно переменным, функции также имеют свой адрес в памяти.

Когда функция вызывается (с помощью оператора ()), точка выполнения переходит к адресу вызываемой функции:

1 int boo() // допустим, код функции boo() находится в ячейке памяти 002B1050
2 {
3 return7;
4 }
5
6 int main()
7 {
8 boo(); // переходим к адресу 002B1050
9
10 return 0;
11 }

Одной из распространенных ошибок новичков является:

1 #include <iostream>
2
3 int boo() //код функции boo() находится в ячейке памяти 002B1050
4 {
5 return 7;
6 }
7
8 int main()
9 {
10 std::cout << boo; // мы хотим вызвать boo(), но вместо этого мы просто выводим boo!
12 return 0;
11
13 }

Вместо вызова функции boo() и вывода возвращаемого значения мы, совершенно случайно, отправили указатель на
функцию boo() непосредственно в std::cout. Что произойдет в этом случае?

Результат на моем компьютере:
002B1050

У вас может быть и другое значение, в зависимости от того, в какой тип данных ваш компилятор решит конвертировать
указатель на функцию. Если ваш компьютер не вывел адрес функции, то вы можете заставить его это сделать, конвертируя
boo в указатель типа void и отправляя его на вывод:

1 #include<iostream>
2
3 int boo() //код функции boo() находится в ячейке памяти 002B1050
4 {
5 return 7;
6 }
7
8 int main()
9 {
10 std::cout << reinterpret_cast<void*>(boo); // указываем C++ конвертировать функцию boo() в указатель типа void
11
12 return 0;
13 }

Так же, как можно объявить неконстантный указатель на обычную переменную, можно объявить и неконстантный
указатель на функцию. Синтаксис создания неконстантного указателя на функцию, пожалуй, один изсамых «уродливых» в
языке C++:

1 // fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
2 int (*fcnPtr)();

В примере, приведенном выше, fcnPtr — это указатель на функцию, которая не имеет параметров и возвращает
целочисленное значение. fcnPtr может указывать на любую другую функцию, соответствующую этому типу.
Скобки вокруг *fcnPtr необходимы для соблюдения приоритета операций; в противном случае int *fcnPtr() будет
интерпретироваться как предварительное объявление функции fcnPtr, которая не имеет параметров и возвращает
указатель на целочисленное значение.

Для создания константного указателя на функцию используйте const после звёздочки:

1 int (*const fcnPtr)();

Если вы поместите const перед int, это будет означать, что функция, на которую указывает указатель, возвращает const int.


Присваивание функции указателю на функцию

Указатель на функцию может быть инициализирован функцией (и неконстантному указателю на функцию тоже можно
присвоить функцию):

1 int boo()
2 {
3 return 7;
4 }
5
6 int doo()
7 {
8 return 8;
9 }
10
11 int main()
12 {
13 int (*fcnPtr)()=boo; // fcnPtr указывает на функцию boo()
14 fcnPtr=doo; // fcnPtr теперь указывает на функцию doo()
15
16 return 0;
17 }

Одна из распространенных ошибок, которую совершают новички:
1 fcnPtr = doo();

Здесь мы фактически присваиваем возвращаемое значение из вызова функции doo() указателю fcnPtr , чего мы не хотим
делать. Мы хотим, чтобы fcnPtr содержал адрес функции doo(), а не возвращаемое значение из doo(). Поэтому скобки
здесь не нужны.
Обратите внимание, у указателя на функцию и самой функции должны совпадать тип, параметры и тип возвращаемого
значения. Например:

1 // Прототипы функций
2 int boo();
3 double doo();
4 int moo(int a);
5
6 // Присваивание значений указателям на функции
7 int(*fcnPtr1)() = boo; // ок
8 int(*fcnPtr2)() = doo; // не ок: тип указателя и тип возврата функции не совпадают!
9 double(*fcnPtr4)()=doo; // ок
10 fcnPtr1 = moo;//не ок: fcnPtr1 не имеет параметров, но moo() имеет
11 int(*fcnPtr3)(int)=moo; // ок

В отличие от фундаментальных типов данных, язык C++ неявно конвертирует функцию в указатель на функцию, если это
необходимо (поэтому вам не нужно использовать оператор адреса & для получения адреса функции).
Однако, язык C++ не будет неявно конвертировать указатель на функцию в указатель типа void или наоборот.


Вызов функции через указатель на функцию

Вы также можете использовать указатель на функцию для вызова самой функции. Есть два способа сделать это. Первый —
через явное разыменование:

1 int boo(int a)
2 {
3 return a;
4 }
5
6 int main()
7 {
8 int (*fcnPtr)(int) = boo; //присваиваем функциюboo() указателю fcnPtr
9 (*fcnPtr)(7); // вызываем функциюboo(7), используя fcnPtr
10
11 return 0;
12 }

Второй — через неявное разыменование:
1 int boo(int a)
2 {
3 return a;
4 }
5
6 int main()
7 {
8 int (*fcnPtr)(int) = boo; //присваиваем функцию boo() указателю fcnPtr
9 fcnPtr(7); //вызываемфункциюboo(7), используяfcnPtr
10
11 return 0;
12 }

Как вы можете видеть, способ неявного разыменования выглядит так же, как и обычный вызов функции, так как обычные
имена функций являются указателями на функции!

Примечание: Параметры по умолчанию не будут работать с функциями, вызванными через указатели на функции.

Параметры по умолчанию обрабатываются вовремя компиляции (т.е. вам нужно предоставить аргумент для
параметра по умолчанию во время компиляции). Однако указатели на функции обрабатываются во время
выполнения. Следовательно, параметры по умолчанию не могут обрабатываться при вызове функции через указатель
на функцию. 
В этом случае вам нужно будет явно передать значения для параметров по умолчанию.


Передача функций в качестве аргументов другим функциям

Одна из самых полезных вещей, которую вы можете сделать с указателями на функции — это передать функцию в качестве
аргумента другой функции. Функции, используемые в качестве аргументов для других функций, называются функциями
обратного вызова.

Предположим, что вы пишете функцию для выполнения определенного задания (например, сортировки массива), но вы
хотите,чтобы пользователь мог определить, каким образом выполнять эту сортировку (например,по возрастанию или по
убыванию). Рассмотрим более подробно этот случай.

Все алгоритмы сортировки работают по одинаковой схеме: алгоритм выполняет итерацию по списку чисел, сравнивает
пары чисел и меняет их местами, исходя из результатов этих сравнений. Следовательно, изменяя алгоритм сравнения
чисел, мы можем изменить способ сортировки, не затрагивая остальные части кода.
Вот наша сортировка методом выбора, рассмотренная на соответствующем уроке:

1 #include<algorithm> //для std::swap()(используйте<utility>, если поддерживается C++11)
2
3 void SelectionSort(int *array,intsize)
4 {
5 	// Перебираем каждый элемент массива
6 	for (int startIndex=0; startIndex<size; ++startIndex)
7 		{
8 		//smallestIndex -это индекс наименьшего элемента, который мы обнаружили до этого момента
9 		int smallestIndex = startIndex;
10
11 		// Ищем наименьший элемент среди оставшихся в массиве (начинаем со startIndex+1)
12 		for (int currentIndex = startIndex + 1; currentIndex < size; ++currentIndex)
13 			{
14 			// Еслитекущий элементменьше нашего предыдущегонайденногонаименьшего элемента,
15 			if(array[smallestIndex] > array[currentIndex]) // СРАВНЕНИЕВЫПОЛНЯЕТСЯ ЗДЕСЬ
16 				// то это наш новый наименьший элемент в этой итерации
17 				smallestIndex = currentIndex;
18 			}
19
20 		// Меняем местами наш стартовый элемент с найденным наименьшим элементом
21 		std::swap(array[startIndex], array[smallestIndex]);
22 		}
23 }

Давайте заменим сравнение чисел на функцию сравнения. Поскольку наша функция сравнения будет сравнивать два
целых числа и возвращать логическое значение для указания того, следует ли выполнять замену, то она будет выглядеть
следующим образом:

1 bool ascending(inta, int b)
2 {
3 return a > b; //условие,прикотором меняются местамиэлементы массива
4 }

А вот уже сортировка методом выбора с функцией ascending() для сравнения чисел:

1 #include <algorithm> // для std::swap() (используйте <utility>, если поддерживается C++11)
2
3 void SelectionSort(int *array, intsize)
4  {
5 	// Перебираем каждый элемент массива
6 	for (int startIndex = 0; startIndex < size; ++startIndex)
7  		{
8   		//smallestIndex -этоиндекснаименьшего элемента,которыймыобнаружилидо этогомомента
9   		int smallestIndex = startIndex;
10
11  		// Ищем наименьший элемент среди оставшихся в массиве (начинаем со startIndex+1)
12  		for (int currentIndex = startIndex + 1; currentIndex < size;++currentIndex)
13    			{
14    			// Если текущий элемент меньше нашего предыдущего найденного наименьшего элемента,
15    			if(ascending(array[smallestIndex], array[currentIndex])) // СРАВНЕНИЕ ВЫПОЛНЯЕТСЯ ЗДЕСЬ
16      			// тоэто наш новый наименьший элемент в этой итерации
17      			smallestIndex = currentIndex;
18    			}
19
20   		//Меняем местами наш стартовый элемент с найденным наименьшим элементом
21   		std::swap(array[startIndex], array[smallestIndex]);
22   		}
23 }

Теперь, чтобы позволить caller-у решить, каким образом будет выполняться сортировка, вместо использования нашей
функции сравнения, мы разрешим caller-у предоставить свою собственную функцию сравнения! 
Это делается с помощью указателя на функцию.

Поскольку функция сравнения caller-а будет сравнивать два целых числа и возвращать логическое значение, то указатель
на эту функцию будет выглядеть следующимоб разом:

1 bool(*comparisonFcn)(int,int);

Мы разрешаем caller-у передавать способ сортировки массива с помощью указателя на функцию в качестве третьего
параметра в нашу функцию сортировки.

Вот готовый код сортировки методом выбора с выбором способа сортировки в caller-е (т.е.вфункцииmain()):

1 #include <iostream>
2 #include <algorithm> // для std::swap() (используйте <utility>, если поддерживается C++11)
3
4 // Обратите внимание, третьим параметром является пользовательский выбор выполнения сортировки
5 void selectionSort(int *array, intsize, bool(*comparisonFcn)(int,int))
6 {
7 	// Перебираем каждый элемент массива
8 	for (intstartIndex=0;startIndex<size; ++startIndex)
9 	{
10 		// bestIndex - это индекс наименьшего/наибольшего элемента, который мы обнаружили до этого момента
11 		int bestIndex=startIndex;
12
13 		// Ищем наименьший/наибольший элемент среди оставшихся в массиве (начинаем со startIndex+1)
14 		for (int currentIndex = startIndex + 1; currentIndex < size;++currentIndex)
15 		{
16 			// Если текущий элемент меньше/больше нашего предыдущего найденного наименьшего/наибольшего элемента,
17 			if(comparisonFcn(array[bestIndex], array[currentIndex])) //СРАВНЕНИЕ ВЫПОЛНЯЕТСЯЗДЕСЬ
18 			// то это наш новый наименьший/наибольший элемент в этой итерации
19 			bestIndex= currentIndex;
20 		}
21
22 		// Меняем местами наш стартовый элемент с найденным наименьшим/наибольшим элементом
23 		std::swap(array[startIndex], array[bestIndex]);
24 	}
25 }
26
27 // Вот функция сравнения, которая выполняет сортировку в порядке возрастания (обратите внимание, это та же функция ascending)
28 bool ascending(int a, int b)
29 {
30  return a>b; // меняем местами, если первый элемент больше второго
31 }
32
33 // Вот функция сравнения, которая выполняет сортировку в порядке убывания
34 bool descending(int a, int b)
35 {
36 return a<b; // меняем местами, если второй элемент больше первого
37 }
38
39 // Эта функция выводит значения массива
40 void printArray(int*array, int size)
41 {
42 	for (intindex=0;index < size; ++index)
43 	std::cout<< array[index] << " ";
44 	std::cout << '\n';
45 }
46
47 int main()
48 {
49 	int array[8] = { 4,8,5, 6,2, 3, 1,7};
50
51 	// Сортируем массив в порядке убывания, используя функцию descending()
52 	selectionSort(array, 8, descending);
53 	printArray(array,8);
54
55 	// Сортируем масси в впорядке возрастания, используя функцию ascending()
56 	selectionSort(array, 8, ascending);
57	printArray(array,8);
58
59 	return 0;
60 }

Результат выполнения программы:
8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 8

Прикольно, правда? Мы предоставили caller-у возможность контролировать процесс сортировки чисел (caller может
определить любыедругие функции сравнения):

1 bool evensFirst(int a, int b)
2 {
3 	// Если a - чётное число, а b - нечётное число, то a идет первым (никакого обмена местами не требуется)
4 	if( (a%2==0) && !(b % 2 ==0) )
5 	return false;
6
7 	// Если a - нечётное число, а b-чётное число, то b идет первым (здесь уже требуется обмен местами)
8 	if( !(a % 2== 0) && (b % 2 ==0) )
9 	return true;
10
11 	//В противном случае, сортируем в порядке возрастания
12 	return ascending(a,b);
13 }
14 
15 int main()
16 {
17 	int array[8] = { 4, 8, 6, 3, 1, 2, 5, 7};
18
19 	selectionSort(array, 8, evensFirst);
20 	printArray(array,8);
21
22 	return 0;
23 }
Результатвыполненияпрограммы:
2 4 6 8 1 3 5 7

Как вы можете видеть, использование указателя на функцию позволяет caller-у «подключить» свой собственный
функционал к чему-то, что мы писали и тестировали ранее, что способствует повторному использованию кода! Раньше,
если выхотели отсортировать один массив в порядкеубывания, а другой — в порядке возрастания, вам понадобилось бы
написать несколько версий сортировки массива. Теперь же, у вас может быть одна версия, которая будет выполнять
сортировку любым способом, каким вы только захотите!


Параметры по умолчанию в функциях

Если выпозволите caller-у передавать функцию в качестве параметра, то полезным будет предоставить и некоторые
стандартные функции для удобства caller-а. Например, в вышеприведенном примере с сортировкой методом выбора, было
бы проще установить дефолтный (по умолчанию) способ сравнения чисел. Например:

1 // Сортировка поумолчанию выполняется в порядке возрастания
2 void selectionSort(int*array, int size,bool (*comparisonFcn)(int, int) = ascending);

В этом случае, до тех пор, пока пользователь вызывает selectionSort() обычно (а не через указатель на функцию), параметр
comparisonFcn будет по умолчанию соответствовать функции ascending().


Указатели на функции и псевдонимы типов

Посмотрим правде в глаза — синтаксис указателей на функции уродлив. Тем не менее, с помощью typedefs мы можем
исправить эту ситуацию:

1 typedef bool (*validateFcn)(int, int);

Здесь мы определили псевдоним типа под названием validateFcn, который является указателем на функцию, которая
принимает два значения типа int и возвращает значение типа bool.

Теперь вместо написания следующего:

1 bool validate(int a,intb,bool (*fcnPtr)(int,int)); //фу, какой синтаксис

Мы можем написать следующее:

1 boolvalidate(int a, int b, validateFcn pfcn) // вот это другое дело

Так гораздо лучше, не правда ли? Однако синтаксис определения самого typedef можетбыть несколько трудным для
запоминания. В C++11 вместо typedef вы можете использовать type alias для создания псевдонима типа указателя на
функцию:

1 using validateFcn = bool(*)(int, int); // typealias

Это уже читабельнее, чем с typedef, так как имя псевдонима и его определение расположены на противоположных
сторонах от оператора =.

Использование type alias идентично использованию typedef:

1 bool validate(int a,intb,validateFcn pfcn) // круто, не так ли?


Использование std::function в C++11

В C++11 ввели альтернативный способ определения и хранения указателей на функции, который выполняется с
использованием std::function. std::function является частью заголовочного файла functional Cтандартной библиотеки C++.
Для определения указателя на функцию с помощью этого способа вам нужно объявить объект std::function следующим образом:

1 #include <functional>
2
3 bool validate(int a,int b, std::function<bool(int,int)>fcn); // указываем указатель на функцию с помощью std::function, которая возвращает bool и принимает два int-а

Как вы можете видеть, тип возврата и параметры находятся в угловых скобках, а параметры ещеи внутри круглых скобок.
Если параметров нет, то внутренние скобки можно оставить пустыми. Здесь уже более понятно, какой тип возвращаемого
значения и какие ожидаемые параметры функции.

Обновим наш предыдущий пример из раздела «Присваивание функции указателю на функцию» текущего урока, но уже с
использованием std::function:

1 #include <iostream>
2 #include <functional>
3
4 int boo()
5 {
6 return 7;
7 }
8
9 int doo()
10 {
11 return 8;
12 }
13
14 int main()
15 {
16   std::function<int()> fcnPtr; // объявляем указатель на функцию, которая возвращает int и не принимает никаких параметров
17   fcnPtr=doo; // fcnPtr теперьуказывает на функцию doo()
18   std::cout << fcnPtr(); // вызываем функцию как обычно
19
20   return 0;
21 }


Заключение

Указатели на функции полезны, прежде всего, когда вы хотите хранить функции в массиве (или в структуре) или когда вам
нужно передать одну функцию в качестве аргумента другой функции. Поскольку синтаксис объявления указателей на
функции является несколько уродливым и подвержен ошибкам, то рекомендуется использовать typealias (или std::function
в C++11).


Тест

Задание No 1

В этот раз мы попытаемся написать версию базового калькулятора с помощью указателей на функции.

a) Напишите короткую программу, которая просит пользователя ввести два целых числа и выбрать математическую
операцию: + ,-, * или /.
Убедитесь, что пользователь ввел корректный символ математической операции (используйте проверку).

#include <iostream>

int main(){
	int a,b;
	char op;
	std::cout << "введіть перше ціле число:";
	std::cin >> a;
	std::cout << "введіть друге ціле число:";
	std::cin >> b;
	while(true){
		std::cout << "введіть арифметичну операцію (+ , - , * чи /) : ";
		std::cin >> op;
		if(op=='+' || op=='-' || op=='*' || op=='/') 
			break;
		else
			std::cout << "Помилка в операції. Спробуйсе ще раз: \n";
	}
}

Ответ 1.a)

b) Напишите функции add(), subtract(), multiply() и divide(). Они должны принимать два целочисленных параметра и
возвращать целочисленное значение.

int add(int a, int b){
	return a+b;
}
int subtract(int a, int b){
	return a-b;
}
int multiply(int a, int b){
	return a*b;
}
int divide(int a, int b){
	return a/b;
}

Ответ 1.b)

c) Создайте typedef с именем arithmeticFcn для указателя на функцию, которая принимает два целочисленных параметра
и возвращает целочисленное значение.

typedef int (*arithmeticFcn)(int,int);

Ответ1.c)

d) Напишите функцию с именем getArithmeticFcn(), которая принимает символ выбранного математического оператора и
возвращает соответствующую функцию в качестве указателя на функцию.

arithmeticFcn getArithmeticFcn(char op){
	if(op=='+')
		return add;
	else if(op=='-')
		return subtract;
	else if(op=='*')
		return multiply;
	else if(op=='/')
		return divide;
	else
	{
		std::cout << "getArithmeticFcn отримала помилковий аргумент op. Це " << op << ". Шукайте помилку.\n"
		return 0;
	}
}

Ответ 1.d)



e) Добавьте в функцию main() вызов функции getArithmeticFcn().

#include <iostream>

int main(){
	int a,b;
	char op;
	std::cout << "введіть перше ціле число:";
	std::cin >> a;
	std::cout << "введіть друге ціле число:";
	std::cin >> b;
	while(true){
		std::cout << "введіть арифметичну операцію (+ , - , * чи /) : ";
		std::cin >> op;
		if(op=='+' || op=='-' || op=='*' || op=='/') 
			break;
		else
			std::cout << "Помилка в операції. Спробуйсе ще раз: \n";
	}
	arithmeticFcn arfunc;
	arfunc=getArithmeticFcn(op);
}

Ответ 1.e)



f) Соедините все части вместе.

#include <iostream>

typedef int (*arithmeticFcn)(int,int);

int add(int a, int b){
	return a+b;
}
int subtract(int a, int b){
	return a-b;
}
int multiply(int a, int b){
	return a*b;
}
int divide(int a, int b){
	return a/b;
}

arithmeticFcn getArithmeticFcn(char op){
	if(op=='+')
		return add;
	else if(op=='-')
		return subtract;
	else if(op=='*')
		return multiply;
	else if(op=='/')
		return divide;
	else
	{
		std::cout << "getArithmeticFcn отримала помилковий аргумент op. Це " << op << ". Шукайте помилку.\n"
		return 0;
	}
}

int main(){
	int a,b;
	char op;
	std::cout << "введіть перше ціле число:";
	std::cin >> a;
	std::cout << "введіть друге ціле число:";
	std::cin >> b;
	while(true){
		std::cout << "введіть арифметичну операцію (+ , - , * чи /) : ";
		std::cin >> op;
		if(op=='+' || op=='-' || op=='*' || op=='/') 
			break;
		else
			std::cout << "Помилка в операції. Спробуйте ще раз: \n";
	}
	arithmeticFcn arfunc;
	arfunc=getArithmeticFcn(op);
	std::cout << a << op << b << "=" << arfunc(a,b) << "\n";
	return 0;
}




Полная программа

#include <iostream>
 
int getInteger()
{
    std::cout << "Enter an integer: ";
    int a;
    std::cin >> a;
    return a;
}
 
char getOperation()
{
    char op;
 
    do
    {   
        std::cout << "Enter an operation ('+', '-', '*', '/'): ";
        std::cin >> op;
    }
    while (op!='+' && op!='-' && op!='*' && op!='/');
 
    return op;
}
 
int add(int a, int b)
{
    return a + b;
}
 
int subtract(int a, int b)
{
    return a - b;
}
 
int multiply(int a, int b)
{
    return a * b;
}
 
int divide(int a, int b)
{
    return a / b;
}
 
typedef int (*arithmeticFcn)(int, int);
 
arithmeticFcn getArithmeticFcn(char op)
{
	switch (op)
	{
	default: // функцией по умолчанию будет add()
	case '+': return add;
	case '-': return subtract;
	case '*': return multiply;
	case '/': return divide;
	}
}
 
int main()
{
    int a = getInteger();
    char op = getOperation();
    int b = getInteger();
 
	arithmeticFcn fcn = getArithmeticFcn(op);
	std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
 
    return 0;
}

=================================




Задание No 2

Теперь давайте изменим программу, которуюмы написали в 1-м задании, чтобы переместить логику из
getArithmeticFcn в массив.

a) Создайте структуру с именем arithmeticStruct, которая имеет два члена: математический оператор типа char и
указатель на функцию arithmeticFcn.

Ответ 2.a)

b) Создайте статический глобальный массив arithmeticArray, используя структуру arithmeticStruct, который будет
инициализирован каждой из 4 математических операций.

Ответ 2.b)

c) Измените getArithmeticFcn для выполнения цикла по массиву и возврата соответствующего указателя на функцию.

Подсказка: Используйте цикл foreach.

Ответ 2.c)

d) Соедините все части вместе.

Полная программа


#include <iostream>
 
int getInteger()
{
	std::cout << "Enter an integer: ";
	int a;
	std::cin >> a;
	return a;
}
 
char getOperation()
{
	char op;
 
	do
	{
		std::cout << "Enter an operation ('+', '-', '*', '/'): ";
		std::cin >> op;
	} while (op != '+' && op != '-' && op != '*' && op != '/');
 
	return op;
}
 
int add(int a, int b)
{
	return a + b;
}
 
int subtract(int a, int b)
{
	return a - b;
}
 
int multiply(int a, int b)
{
	return a * b;
}
 
int divide(int a, int b)
{
	return a / b;
}
 
typedef int(*arithmeticFcn)(int, int);
 
struct arithmeticStruct
{
	char op;
	arithmeticFcn fcn;
};
 
static arithmeticStruct arithmeticArray[] {
	{ '+', add },
	{ '-', subtract },
	{ '*', multiply },
	{ '/', divide }
};
 
 
arithmeticFcn getArithmeticFcn(char op)
{
	for (auto &arith : arithmeticArray)
	{
		if (arith.op == op)
			return arith.fcn;
	}
 
	return add; // функцией по умолчанию будет add()
}
 
int main()
{
	int a = getInteger();
	char op = getOperation();
	int b = getInteger();
 
	arithmeticFcn fcn = getArithmeticFcn(op);
	std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
 
	return 0;
}
