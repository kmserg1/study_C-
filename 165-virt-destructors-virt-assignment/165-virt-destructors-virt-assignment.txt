Урок No165. Виртуальные деструкторы и Виртуальное присваивание

Хотя язык C++ автоматически предоставляет деструкторы для ваших классов, если вы не предоставляете их самостоятельно,
все же иногда вы можете сделать это сами.

Оглавление:
1. Виртуальные деструкторы
2. Виртуальное присваивание
3. Игнорирование виртуальных функций


Виртуальные деструкторы

При работе с наследованием ваши деструкторы всегда должны быть виртуальными. Рассмотрим следующий пример:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	~Parent() // примечание: Деструктор не виртуальный
7 	{
8 		std::cout << "Calling ~Parent()" << std::endl;
9 	}
10 };
11
12 class Child: public Parent
13 {
14 private:
15 	int* m_array;
16
17 public:
18 	Child(int length)
19 	{
20 		m_array = new int[length];
21 	}
22
23 	~Child() // примечание: Деструктор не виртуальный
24 	{
25 		std::cout << "Calling ~Child()" << std::endl;
26 		delete[] m_array;
27 	}
28 };
29
30 int main()
31 {
32 	Child *child = new Child(7);
33 	Parent *parent = child;
34 	delete parent;
35
36 	return 0;
37 }

Поскольку parent является указателем класса Parent, то при его уничтожении компилятор будет смотреть, является ли
деструктор класса Parent виртуальным. Поскольку это не так, то компилятор вызовет только деструктор класса Parent.

Результат выполнения программы:
Calling ~Parent()

Тем не менее, нам нужно, чтобы delete вызывал деструктор класса Child (который, в свою очередь, будет вызывать деструктор
класса Parent), иначе m_array не будет удален. Это можно выполнить, сделав деструктор класса Parent виртуальным:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	virtual ~Parent() // примечание: Деструктор виртуальный
7 	{
8 	std::cout << "Calling ~Parent()" << std::endl;
9 	}
10 };
11
12 class Child: public Parent
13 {
14 private:
15 	int* m_array;
16
17 public:
18 	Child(int length)
19 	{
20 		m_array = new int[length];
21 	}
22
23 	virtual ~Child() // примечание: Деструктор виртуальный
24 	{
25 		std::cout << "Calling ~Child()" << std::endl;
26 		delete[] m_array;
27 	}
28 };
29
30 int main()
31 {
32 	Child *child = new Child(7);
33 	Parent *parent = child;
34 	delete parent;
35
36 	return 0;
37 }

Результат выполнения программы:
Calling ~Child()
Calling ~Parent()

Правило: При работе с наследованием ваши деструкторы должны быть виртуальными.


Виртуальное присваивание

Оператор присваивания можно сделать виртуальным. Однако, в отличие от деструктора, виртуальное присваивание не всегда
является хорошей идеей. Почему? Это уже выходит за рамки этого урока. Следовательно, для сохранения простоты в вашем
коде, не рекомендуется использовать виртуальное присваивание.


Игнорирование виртуальных функций

В языке С++ мы можем игнорировать вызов переопределений. Например:

1 class Parent
2 {
3 public:
4 	virtual const char* getName() { return "Parent"; }
5 };
6
7 class Child: public Parent
8 {
9 public:
10 	virtual const char* getName() { return "Child"; }
11 };

Здесь мы хотим, чтобы ссылка класса Parent на объект класса Child вызывала Parent::getName() вместо Child::getName(). Чтобы
это сделать, нужно просто использовать оператор разрешения области видимости:

1 #include <iostream>
23 int main()
4 {
5 	Child child;
6 	Parent &parent = child;
7 	// Вызов Parent::GetName() вместо переопределения Child::GetName()
8 	std::cout << parent.Parent::getName() << std::endl;
9 }

Вы, скорее всего, не будете использовать это очень часто, но знать об этом стоит.
