Урок No 61. Структуры

В  программировании есть много случаев, когда может понадобиться больше одной 
переменной для представления определенного объекта.

Оглавление:
1.  Зачем нужны структуры?
2.  Объявление и определение структур
3.  Доступ к членам структур
4.  Инициализация структур
5.  C++11/14: Инициализация нестатических членов структур
6.  Присваивание значений членам структур
7.  Структуры и функции
8.  Вложенные структуры
9.  Размер структур
10. Доступ к структурам из нескольких файлов
11. Заключение
12. Тест
    
Зачем нужны структуры?

Например, для представления самого себя, вы, скорее всего, захотите указать свое имя, день
рождения, рост,вес или любую другую информацию:

1 std::string myName;
2 int myBirthDay;
3 int myBirthMonth;
4 int myBirthYear;
5 int myHeight;
6 int myWeight;

Но теперь у вас есть 6 отдельных независимых переменных.
Если вы захотите передать информацию о себе в функцию, то вам придется передавать каждую переменную по отдельности.
Кроме того, если вы захотите хранить информацию о ком-то еще, то вам придется дополнительно
объявить еще 6 переменных на каждого человека!
Невооруженным глазом видно, что такая реализация не очень эффективна.

К счастью, язык C++ позволяет программистам создавать свои собственные пользовательские
типы данных — типы, которые группируют несколько отдельных переменных вместе. Одним из
простейших пользовательских типов данных является структура.

Структура позволяет сгруппировать переменные разных типов в единое целое.


Объявление и определение структур

Поскольку структуры определяются программистом, то в начале мы должны сообщить
компилятору, как она вообще будет выглядеть. Для этого используется ключевое слово struct:

1 struct Employee
2 {
3  short id;
4  int age;
5  double salary;
6 };

Мы определили структуру с именем Employee. Она содержит 3 переменные: 
 id типа short;
 age типа int;
 salary типа double.

Эти переменные, которые являются частью структуры, называются членами структуры (или
«полями структуры»). Employee — это простое объявление структуры. Хотя мы и указали
компилятору, что она имеет переменные-члены, память под нее сейчас не выделяется. Имена
структур принятописать с заглавной буквы, чтобы отличать их от имен переменных.

Предупреждение: Одна из самых простых ошибок в C++ — забыть точку с запятой в конце
объявления структуры. Это приведет к ошибке компиляции в следующей строке кода.
Современные компиляторы, такие как Visual Studio версии 2010, а также более новых версий,
укажут вам, что вы забыли точку с запятой в конце, но более старые компиляторы могут
этого и не сделать, из-за чего такую ошибку будет трудно найти. О том, как установить Visual
Studio или какую выбрать IDE мы уже говорили на уроке No 4.

Чтобы использовать структуру Employee нам нужно просто объявить переменную типа  Employee:

1 Employee john; // имя структуры Employee начинается с заглавной буквы, а переменная john - с маленькой
Здесь мы определили переменную типа Employee с именем john.

Как и в случае с обычными переменными, определение переменной, типом которой является структура, приведет к
выделению памяти для этой переменной.

Объявить можно и несколько переменных одной структуры:

1 Employee john; // создаем отдельную структуру Employee для John
2 Employee james; // создаем отдельную  структуру Employee для James


Доступ к членам структур    

Когда мы объявляем переменную структуры, например, Employee john, то john ссылается на всю структуру. 
Для того, чтобы получить доступ к отдельным её членам, используется оператор выбора члена (.). Например, в коде, 
приведенном ниже, мы используем оператор выбора членов для инициализации каждого члена структуры:

1 Employee john;// создаем отдельную структуру Employee для John
2 john.id=8; // присваиваем значение члену id структуры john
3 john.age=27; // присваиваем значение члену  age структуры john
4 john.salary=32.17; // присваиваем значение  члену salary структуры  john
5 
6 Employee james; // создаем отдельную структуру Employee для James
7 james.id= 9; // присваиваем значение члену id структуры james
8 james.age=30; // присваиваем значение члену age структуры james
9 james.salary=28.35; // присваиваем значение члену salary структуры james

Каки вслучае с обычными переменными, переменные-члены структуры не инициализируются
автоматически и обычно содержат мусор. Инициализировать их нужно вручную.
В примере, приведенном выше, легко определить, какая переменная относится к структуре John,
а какая — к структуре James. Это обеспечивает гораздо более высокий уровень организации, чем
в случае с обычными отдельными переменными.
Переменные-члены структуры работают так же, как и простые переменные, поэтому с ними
можно выполнять обычные арифметические операции и операции сравнения:   
   
1 int totalAge =john.age+james.age;
2
3 if(john.salary>james.salary)
4	cout << "John makes more than James\n";
5 else if (john.salary < james.salary)
6 	cout << "John makes less than James\n";
7 else
8   	cout << "John and James make the same amount\n";
9 
10 // James получил повышение в должности
11 james.salary += 3.75;
12 
13 // Сегодня день рождения у John
14 ++john.age; // используем пре-инкремент для увеличения возраста John на 1 год


Инициализация структур

Инициализация структур путем присваивания значений каждому члену по порядку — занятие довольно
громоздкое (особенно, если этих членов много), поэтому в языке C++ есть более быстрый способ инициализации
структур — с помощью списка инициализаторов. Он позволяет инициализировать некоторые или все члены
структуры во время объявления переменной типа struct:

1 struct  Employee
2 {
3 	short id;
4 	int age;
5 	double salary;
6 };
7
8 Employee john = { 5, 27, 45000.0 }; // john.id= 5, john.age=27, john.salary =45000.0
9 Employee james={6, 29}; // james.id= 6, james.age= 9, james.salary= 0.0 (инициализация по умолчанию)

В C++11 также можно использовать uniform-инициализацию:
1 Employee john {5,27,45000.0}; // john.id =5,john.age=27, john.salary= 45000.0
2 Employee james{6,29}; // james.id=6, james.age=29, james.salary=0.0 (инициализация по умолчанию)

Если в списке инициализаторов не будет одного или нескольких элементов, то имприсвоятся
значения по умолчанию (обычно 0). В примере, приведенном выше, члену james.salary
присваивается значение по умолчанию 0.0, так как мы сами не предоставили никакого значения
во время инициализации.


C++11/14: Инициализация нестатических членов структур

В C++11 добавили возможность присваивать нестатическим (обычным) членам структуры значения по умолчанию.
Например:

1 #include<iostream>
2
3 struct Triangle
4 {
5  double length=2.0;
6  double width=2.0;
7 };
8
9 int main()
10{
11 Triangle z; //длина =2.0, ширина=2.0
12
13  z.length=3.0; // вы также можете присваивать членам структурыи другие значения
14
15  return 0;
16 }

К сожалению, в C++11 синтаксис инициализации нестатических членов структуры несовместим с
синтаксисом списка инициализаторов или uniform-инициализацией. В C++11 следующая
программа не скомпилируется:

1 #include <iostream>
2 
3 struct Triangle
4 {
5 double length = 2.0; // нестатическая инициализация членов
6 double width = 2.0;
7 };
8
9 int main()
10 {
11  Triangle z{3.0, 3.0 }; // uniform-инициализация
12                        
13 return 0;
14 }

Следовательно, вам нужно будет решить, хотите ли вы использовать инициализацию
нестатических полей или uniform-инициализацию.
uniform-инициализация более гибкая, поэтому рекомендуется использовать именно её.
Однако в C++14 это ограничение было снято, и оба варианта можно использовать. Мы еще
поговорим детально о статических членах структуры на соответствующем уроке.


Присваивание значений членам структур

До C++11, если бы мы захотели присвоить значения членам структуры, то нам бы пришлось это
делать вручную каждому члену по отдельности:

1 struct Employee
2 {
3  short id;
4  int age;
5  double salary;
6 };
7
8 Employee john;
9 john.id= 5;
10 john.age=27;
11 john.salary=45000.0;

Это боль, особенно когда членов в структуре много.

В C++11 вы можете присваивать значения
членам структур, используя список инициализаторов:

1 struct Employee
2 {
3 short id;
4 int age;
5 double salary;
6 };
7
8 Employee john;
9 john= {5,27,45000.0};// начиная с C++11


Структуры и функции

Большим преимуществом использования структур, нежели отдельных переменных, является
возможность передать всю структуру в функцию, которая должна работать с её членами:
1 # include <iostream>
2
3 struct Employee
4 {
5  short id;
6  int age;
7  double salary;
8 };
9
10 void printInformation(Employeeemployee)
11 {
12    std::cout << "ID: " << employee.id << "\n";
13    std::cout << "Age: " << employee.age << "\n";
14    std::cout << "Salary: " << employee.salary << "\n";
15 }
16
17 int main()
18 {
19  Employee john={21,27,28.45 };
20  Employee james= {22,29,19.29};
21
22  // Выводим информацию о John
23  printInformation(john);
24 
25 std::cout << "\n";
26
27 //ВыводиминформациюоJames
28 printInformation(james);
29
30 return 0;
31 }

Это позволило нам не передавать каждую переменную по отдельности. Более того, если мы когда-
либо захотим добавить новых членов в структуру Employee, то нам не придется изменять объявление или вызов функции!

Результат выполнения программы:

ID: 21
Age: 27
Salary: 28.45

ID: 22
Age: 29
Salary: 19.29

В примере, приведенном выше, мы передали структуру Employee в функцию printInformation().
Функция также может возвращать структуру (это один из тех немногих случаев, когда функция может возвращать несколько переменных).

Например:
1 #include <iostream>
2
3 struct Point3d
4 {
5  double x;
6  double y;
7  double z;
8 };
9
10 Point3d getZeroPoint()
11 {
12 Point3d temp ={ 0.0,0.0,0.0};
13 return temp;
14 }
15
16 int main()
17 {
18  Point3d zero=getZeroPoint();
19
20 if (zero.x==0.0 && zero.y==0.0 && zero.z==0.0)
21	std::cout << "The point is zero\n";
22 else
23	 std::cout<< "The point is not zero\n";
24
25  return0;
26 }

Результат выполнения программы:
The point is zero


Вложенные структуры

Одни структуры могут содержать другие структуры. Например:

1 struct Employee
2 {
3 	short id;
4 	int age;
5 	double salary;
6 };
7
8 struct Company
9 {
10  	Employee CEO;// Employee- это структуравнутриструктуры Company
11 	int numberOfEmployees;
12 };
13
14 Company myCompany;

В этом случае, если бы мы хотели узнать, какая зарплата у CEO (исполнительного директора), то
нам бы пришлось использовать оператор выбора членов дважды:
1 myCompany.CEO.salary
Сначала мы выбираем поле CEO из структуры myCompany, а затем поле salary из структуры Employee.
Вы можете использовать вложенные списки инициализаторов c вложенными структурами:

1 struct Employee
2 {
3  short id;
4  int age;
5  float salary;
6 };
7
8 struct Company
9 {
10 	Employee CEO; // Employee является структурой внутри структуры Company
11	int numberOfEmployees;
12 };
13
14 Company myCompany={{3,35,55000.0f},7 };


Размер структур

Как правило, размер структуры — это сумма размеров всех её членов, но не всегда! 
Например, рассмотрим структуру Employee.
На большинстве платформ тип short занимает 2 байта, тип int — 4 байта, а тип double — 8 байт.
Следовательно, ожидается, что Employee будет занимать 2+4+8=14 байт. Чтобы узнать точный размер
Employee, мы можем воспользоваться оператором sizeof:

1 #include <iostream>
2 
3 struct Employee
4 {
5  short id;
6  int age;
7  double salary;
8 };
9
10 int main()
11 {
12  std::cout << "The size of Employee is" << sizeof(Employee) << "\n";
13
14  return 0;
15 }

Результат выполнения программы (накомпьютере автора):
The size of Employee is 16

Оказывается, мы можем сказать только, что размер структуры будет, по крайней мере, не меньше
суммы размеров всех еёчленов. Но он может быть и больше! По соображениям
производительности компилятор иногда может добавлять «пробелы / промежутки» в структуры.
В структуре Employee компилятор неявно добавил 2 байта послечлена id, увеличивая размер
структуры до 16 байтов вместо 14. Описание причины, по которой этопроисходит, выходит за
рамки этого урока, но если выхотите знать больше,то можете прочитать о выравнивании данных в Википедии.


Доступк структурам из нескольких файлов

Поскольку объявление структуры не провоцирует выделение памяти, то использовать
предварительное объявление для нее вы не сможете. Но есть обходной путь: если вы хотите
использовать объявление структуры в  нескольких файлах (чтобы иметь возможность создавать переменные этой
структуры в нескольких файлах), поместите объявление структуры в заголовочный файл и подключайте этот файл везде, где 
необходимо использовать структуру.


Переменные типа struct подчиняются тем же правилам, что и обычные переменные. 
Следовательно, если вы хотите сделать переменную структуры доступной в нескольких файлах, то
вы можете использовать ключевое слово extern.


Заключение

Структуры очень важны в языке C++, поскольку их понимание — это первый большой шаг напути к объектно-ориентированному  программированию! Чуть 
позже мы рассмотрим другой пользовательский тип данных — класс (который является продолжением темы структур).


Тест

Задание No 1
У вас есть веб-сайт и вы хотите отслеживать, сколько денег вы зарабатываете в день от
размещенной на нем рекламы. Объявите структуру Advertising, котораябудет отслеживать:

 сколько объявлений вы показали посетителям(1)
 сколько процентов посетителей нажали на объявления (2);
 сколько вы заработали в среднем за каждое нажатие на объявления(3).

Значения этих трех полей должен вводить пользователь. Передайте структуру Advertising в
функцию, которая выведет каждое из этих значений, а затем подсчитает, сколько всего денег вы       
заработали за день (перемножьте все 3 поля).

#include <iostream>

struct Advertising
{
	int pokazy;
	int percent_press;
	double aver_earnings;
};

void printAdv(Advertising x)
{
std::cout << "Показов за день: " << x.pokazy<< std::endl;
std::cout << "Процент нажатий " << x.percent_press << std::endl;
std::cout << "Плата за нажатие: " << x.aver_earnings<< std::endl;
std::cout << "Заработок за день: " << (x.pokazy+0.0)*(static_cast<double>(x.percent_press)/100)*x.aver_earnings << std::endl;
}


int main()
{
Advertising ad;
std::cout << "Введите число показов за день (целое): ";
std::cin >> ad.pokazy;
std::cout << "Введите процент нажатий (целое): ";
std::cin >> ad.percent_press;
std::cout << "Введите плату за нажатие (с плавающей точкой): ";
std::cin >> ad.aver_earnings;
printAdv(ad);
return 0;
}


Ответ No 1

#include <iostream>
 
// Сначала объявляем структуру Advertising 
struct Advertising
{
    int adsShown;
    double clickThroughRatePercentage;
    double averageEarningsPerClick;
};
 
void printAdvertising(Advertising ad)
{
    using namespace std;
    cout << "Number of ads shown: " << ad.adsShown << endl;
    cout << "Click through rate: " << ad.clickThroughRatePercentage << endl;
    cout << "Average earnings per click: $" << ad.averageEarningsPerClick << endl;
 
    // Следующая строка кода разбита из-за своей длины.
    // Мы делим ad.clickThroughRatePercentage на 100, так как пользователь указывает проценты, а не готовое число
    cout << "Total Earnings: $" <<
        (ad.adsShown * ad.clickThroughRatePercentage / 100 * ad.averageEarningsPerClick) << endl;
}
 
int main()
{
    using namespace std;
    // Объявляем переменную структуры Advertising 
    Advertising ad;
 
    cout << "How many ads were shown today? ";
    cin >> ad.adsShown;
    cout << "What percentage of users clicked on the ads? ";
    cin >> ad.clickThroughRatePercentage;
    cout << "What was the average earnings per click? ";
    cin >> ad.averageEarningsPerClick;
 
    printAdvertising(ad);
 
    return 0;
}




Задание No 2

Создайте структуру для хранения дробных чисел. Структура должна иметь 2 члена:
целочисленный числитель и целочисленный знаменатель. Объявите две дробные переменные и
получите их значения от пользователя. Напишите функцию multiply() (параметрами которой
будут эти две переменные), которая будет перемножать эти числа и выводить результат в виде
десятичного числа.

#include <iostream>

struct Rational
{
int numerator;
int denominator;
};

double multiply(Rational n1, Rational n2)
{
double res;
res=static_cast<double>(n1.numerator)*static_cast<double>(n2.numerator);
res/=static_cast<double>(n1.denominator)*static_cast<double>(n2.denominator);
std::cout << res << std::endl;
return res;
}

int main()
{
Rational num1, num2;
std::cout << "Введите числитель первого числа (целое):";
std::cin >> num1.numerator;
std::cout << "Введите знаменатель первого числа (целое):";
std::cin >> num1.denominator;

std::cout << "Введите числитель второго числа (целое):";
std::cin >> num2.numerator;
std::cout << "Введите знаменатель второго числа (целое):";
std::cin >> num2.denominator;

std::cout << "Результат перемножения этих двух чисел: ";
multiply(num1, num2);
return 0;
}


Ответ No 2

#include <iostream>
 
struct Drob
{
    int chislitel;
    int znamenatel;
};
 
void multiply(Drob d1, Drob d2)
{
    using namespace std;
 
    // Не забываем об операторе static_cast, иначе компилятор выполнит целочисленное деление!
    cout << static_cast<float>(d1.chislitel* d2.chislitel) /
        (d1.znamenatel* d2.znamenatel);
}
 
int main()
{
    using namespace std;
 
    // Определяем первую переменную -дробь 
    Drob d1;
    cout << "Input the first chislitel: ";
    cin >> d1.chislitel;
    cout << "Input the first znamenatel: ";
    cin >> d1.znamenatel;
 
    // Определяем вторую переменную-дробь
    Drob d2;
    cout << "Input the second chislitel: ";
    cin >> d2.chislitel;
    cout << "Input the second znamenatel: ";
    cin >> d2.znamenatel;
 
    multiply(d1, d2);
 
    return 0;
}
