Урок No 141. Конструктор копирования

Вспомним все типы инициализации, которые поддерживает язык C++: прямая инициализация, uniform-инициализацияи
копирующая инициализация.

Оглавление:
1. Конструктор копирования
2. Предотвращение создания копий объектов
3. Конструктор копирования может быть проигнорирован


Конструктор копирования

Рассмотрим примеры всех вышеприведенных инициализаций на практике, используя следующий класс Drob:

1 #include <cassert>
2 #include <iostream>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
19 };
20
21 std::ostream& operator<<(std::ostream& out, const Drob &d1)
22 {
23 	out << d1.m_numerator << "/" << d1.m_denominator;
24 	return out;
25 }

Мы можем выполнить прямуюин ициализацию:

1 int a(7); //прямая инициализация целочисленной переменной
2 Drob sixSeven(6, 7); // прямая инициализация объекта класса Drob, вызывается конструктор Drob(int, int)

В C++11 мы можем выполнить uniform-инициализацию:
1 int a { 7 }; // uniform-инициализация целочисленной переменной
2 Drob sixSeven {6, 7}; // uniform-инициализация объекта класса Drob, вызывается конструктор Drob(int, int)

И, наконец, мы можем выполнить копирующую инициализацию:
1 int a = 7; // копирующая инициализация целочисленной переменной
2 Drob eight = Drob(8); // копирующая инициализация объекта класса Drob, вызывается Drob(8, 1)
3 Drob nine = 9; // копирующая инициализация объекта класса Drob. Компилятор будет искать способ конвертации 9 в объект класса

С прямой инициализацией и uniform-инициализацией создаваемый объект непосредственно инициализируется. Однако с
копирующей инициализацией дела обстоят несколько сложнее. Мы рассмотрим это детально на следующем уроке. Но
перед этим нам еще нужно кое в чём разобраться.
Рассмотрим следующую программу:

1 #include <cassert>
2 #include <iostream>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
19 };
20
21 std::ostream& operator<<(std::ostream& out, const Drob &d1)
22 {
23 	out << d1.m_numerator << "/" << d1.m_denominator;
24 	return out;
25 }
26
27 int main()
28 {
29 	Drob sixSeven(6, 7); // прямая инициализация объекта класса Drob, вызывается конструктор Drob(int, int)
30 	Drob dCopy(sixSeven); // прямая инициализация - какой конструктор вызывается здесь?
31 	std::cout << dCopy << '\n';
32 }

Результат выполнения программы:
6/7

Рассмотрим детально, как работает эта программа.

С объектом sixSeven выполняется обычная прямая инициализация, которая приводит к вызову конструктора 
Drob(int,int). Здесь нет никаких сюрпризов. 

А вот инициализация объекта dCopy также является прямой инициализацией, но
какой конструктор вызывается здесь? 
Ответ:конструктор копирования.

Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта через
копирование существующего объекта. И, как в случае с конструктором по умолчанию, если вы не предоставите конструктор
копирования для своих классов самостоятельно, то язык C++ создаст public-конструктор копирования автоматически.
Поскольку компилятор мало знает о вашем классе, то по умолчанию созданный конструктор копирования будет
использовать почленную инициализацию. Почленная инициализация означает, что каждый член объекта-копии
инициализируется непосредственно из члена объекта-оригинала. Т.е.в примере, приведенном выше, dCopy.m_numerator
будетиметь значение sixSeven.m_numerator ( 6 ), а dCopy.m_denominator будет равен sixSeven.m_ denominator ( 7 ).
Так же, как мы можем явно определить конструктор по умолчанию, также мы можем явно определить и конструктор
копирования. Конструктор копирования выглядит следующим образом:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	//Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 	m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &drob) :
20 		m_numerator(drob.m_numerator), m_denominator(drob.m_denominator)
21 	// Примечание: Мы имеем прямой доступ к членам объекта drob, поскольку мы сейчас находимся внутри класса Drob
22 	{
23 		// Нет необходимости выполнять проверку denominator здесь, так как эта проверка уже осуществляется в конструкторе к
24 		std::cout << "Copy constructor worked here!\n"; // просто, чтобы показать, что это работает
25 	}
26
27 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
28 };
29
30 std::ostream& operator<<(std::ostream& out, const Drob &d1)
31 {
32 	out << d1.m_numerator << "/" << d1.m_denominator;
33 	return out;
34 }
35
36 int main()
37 {
38 	Drob sixSeven(6, 7); // прямая инициализация объекта класса Drob, вызывается конструктор Drob(int, int)
39 	Drob dCopy(sixSeven); // прямая инициализация, вызывается конструктор копирования класса Drob
40 	std::cout << dCopy << '\n';
41 }

Результат выполнения программы:
Copy constructor worked here!
6/7

Конструктор копирования в вышеприведенном примере использует почленную инициализацию и функционально
эквивалентен конструктору по умолчанию, за исключением того, что мы добавили стейтмент вывода,в котором указали
текст (сработал конструктор копирования).


Предотвращение создания копий объектов

Мы можем предотвратить создание копий объектов наших классов, сделав конструктор копирования закрытым:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 	// Конструктор копирования (закрытый)
11 	Drob(const Drob &drob) :
12 		m_numerator(drob.m_numerator), m_denominator(drob.m_denominator)
13 	{
14 		// Нет необходимости выполнять проверку denominator здесь, так как эта проверка уже осуществляется в конструкторе к
15 		std::cout << "Copy constructor worked here!\n"; // просто, чтобы показать, что это работает
16 	}
17
18 public:
19 	// Конструктор по умолчанию
20 	Drob(int numerator=0, int denominator=1) :
21 		m_numerator(numerator), m_denominator(denominator)
22 	{
23 		assert(denominator != 0);
24 	}
25
26 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
27 };
28
29 std::ostream& operator<<(std::ostream& out, const Drob &d1)
30 {
31 	out << d1.m_numerator << "/" << d1.m_denominator;
32 	return out;
33 }
34
35 int main()
36 {
37 	Drob sixSeven(6, 7); // прямая инициализация объекта класса Drob, вызывается конструктор Drob(int, int)
38 	Drob dCopy(sixSeven); // конструктор копирования является закрытым, поэтому эта строка вызовет ошибку компиляции
39 	std::cout << dCopy << '\n';
40 }

Здесь мы получим ошибку компиляции, так как dCopy должен использовать конструктор копирования, но он не видит его,
поскольку конструктор копирования является закрытым.


Конструктор копирования можетбыть проигнорирован

Рассмотрим следующий код:
1 #include <cassert>
2 #include <iostream>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &drob) :
20 		m_numerator(drob.m_numerator), m_denominator(drob.m_denominator)
21 	{
22 		// Нет необходимости выполнять проверку denominator здесь, так как эта проверка уже осуществляется в конструкторе к
23 		std::cout << "Copy constructor worked here!\n"; // просто, чтобы показать, что это работает
24 	}
25
26 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
27 };
28
29 std::ostream& operator<<(std::ostream& out, const Drob &d1)
30 {
31 	out << d1.m_numerator << "/" << d1.m_denominator;
32 	return out;
33 }
34
35 int main()
36 {
37 	Drob sixSeven(Drob(6, 7));
38 	std::cout << sixSeven;
39 	return 0;
40 }

Сначала инициализируется анонимный объект Drob, который приводит к вызову конструктора Drob(int, int). Затем
этот анонимный объект используется для инициализации объекта sixSeven класса Drob. Поскольку анонимный объект
является объектом класса Drob, как и sixSeven, то здесь должен вызываться конструктор копирования, верно?
Запуститеэту программусамостоятельно. 

Ожидаемый результат:
Copy constructor worked here!
6/7

Реальныйрезультат:
6/7

Почему наш конструктор копирования не сработал?
Дело в том, что инициализация анонимного объекта, а затем использование этого объекта для прямой инициализации уже
не анонимного объекта выполняется в два этапа (первый этап — это создание анонимного объекта, второй этап — это
вызов конструктора копирования). Однако, конечный результат по сути идентичен простому выполнению прямой
инициализации, которая занимает всеголишь один шаг.
По этой причине в таких случаях компилятору разрешается отказаться от вызова конструктора копирования и просто
выполнить прямую инициализацию. Этот процесс называется элизией.

Поэтому, даже если вы напишите:
1 Drob sixSeven(Drob(6, 7));
Компилятор может изменить это на:
1 Drob sixSeven(6, 7);

В последнем случае с прямой инициализацией потребуется вызов только одного конструктора (Drob(int, int) ).
Обратите внимание, в случаях, когда используется элизия, любые стейтменты в теле конструктора копирования не
выполняются, даже если они имеют побочные эффекты (например, выводят что-либо на экран)!
Наконец, если вы делаетесвой конструктор копирования закрытым, то любая инициализация, использующая этот
закрытый конструктор копирования, приведет к ошибкам компиляции, даже если конструктор копирования будет
проигнорирован!
