ГлаваNo7.Итоговый тест


Еще одна глава пройдена! Впереди самое сердце этого туториала — объектно-ориентированное программирование, мы
почти добрались! Осталась всеголишь однас тупенька — итоговый тест.

Оглавление:
1. Теория
2. Задание No 1
3. Задание No 2
4. Задание No 3


Теория

Аргументы функциймогут передаваться по значению, по ссылке или поадресу. Используйте:
 передачу по значению для фундаментальных типов данных и перечислителей;
 передачу по (константной) ссылке для структур, классов или в тех случаях, когда нужно, чтобы функция изменяла
значение аргумента;
 передачу по адресу для указателей или обычных массивов.

В большинстве случаев используется возврат по значению, однако возврат по ссылке или по адресу также может быть
полезен при работе с динамически выделенными массивами, структурами или классами. Если используете возврат по
ссылке или по адресу, то убедитесь, что не возвращаете чего-то, что выйдет из локальной области видимости.

С помощью встроенных функций вызов функции можно заменить на непосредственный код этой функции.

Перегрузка функций позволяет создать несколько функций с однимитем же именем, но при условии, что параметры этих
функций будут разные. Возвращаемое значение не считается параметром.

Параметр по умолчанию — этопараметр функции, который имеет значение по умолчанию. Если caller не передает
значение для параметра, то будет использоваться значение по умолчанию. У вас может быть несколько параметров со
значениями по умолчанию. Они всегда должны находиться справа от обычных параметров. Параметр по умолчанию может
быть установлен только в одном месте. Обычно его размещают в предварительном объявлении функции. Если же
предварительного объявления нет, то его размещают в определении функции.

Указатели на функции позволяют передать одну функцию в качестве аргумента другой функции.

Динамическая память выделяется из кучи.

Стек вызовов отслеживает все активные функции (те, которые были вызваны, но еще не завершены) от начала программы
и до текущей точки выполнения. Стек имеет ограниченный размер.
std::vector можно использовать в качестве стека.

Рекурсивная функция — это функция, которая вызывает сама себя. Для всех рекурсивных функций требуется условие
завершения.

Синтаксическая ошибка возникает, когда вы пишете код, который нарушает правила грамматики языка C++. Компилятор
такие ошибки легко отлавливает.

Семантическая ошибка возникает, когда код синтаксически правильный, но выполняет не то, что нужно программисту.
Среди семантических ошибок распространены логические ошибки и ложные предположения.

Стейтмент assert используется для обнаружения ложных предположений, но его недостаток заключается в том, что при
ложном утверждении выполнение программы немедленно прекращается.

Аргументы командной строки позволяют пользователям или другим программам передавать данные в программу при её
запуске. Аргументы командной строки всегда являются строками C-style и для использования числовых значений вам
нужно будет конвертировать строки в числовые типы данных.

Эллипсис позволяет передать переменную, указывающую на количество всех передаваемых аргументов, в функцию.
Однако при таком раскладе игнорируется проверка типов, что крайне нежелательно и может привести к проблемам.


Тест

Задание No 1

Напишите прототипы функций для следующих случаев. Используйте const при необходимости.
a) Функция с именем max(), которая принимает два значения типа double и возвращает большее из них.

double max(const double a, const double b);

Ответ No 1.а)

b) Функция swap(), которая меняет местами двацелых числа.

void max(int &a, int &b);

Ответ No 1.b)

c) Функция getLargestElement(), которая принимает динамически выделенный массив целыхчисел и возвращает
наибольшее число таким образом, что caller может изменитьз начение возвращаемого элемента (не забудьте о параметре-
длине).

int &max(const vector<int> &a, const int len);

Ответ No 1.c)



Задание No 2

Что не так со следующими программами?
a)
1 int &doSomething()
2 {
3  int array[] = {1,3, 5, 7, 9 };
4  return array[2];
5 }

array будет удален после окончания doSomething, поэтому возвращенное значение - это мусор (висящий указатель).

ОтветNo2.а)

b)
1 int sumTo(int value)
2 {
3 return value + sumTo(value-1);
4 }

sumTo - рекурсивная ф-я, у которой нет критерия остановки

Ответ No 2.b)

c)
1 float divide(float a, float b)
2 {
3 return a / b;
4 }
5
6 double divide(float a,float b)
7 {
8 return a / b;
9 }

Неоднозначность. Две функции divide с одинаковыми параментрами, но возвращающие данные разных типов. 

Ответ No 2.c)


d)
1 #include <iostream>
2
3 int main()
4 {
5 int array[1000000000];
6
7 for (const auto &x:array)
8 	std::cout << x << ' ';
9
10 return 0;
11 }

Большой массив объявляется в стеке. Будет переполнение стека

Ответ No 2.d)

e)
1 #include <iostream>
2
3 int main(int argc,char* argv[])
4 {
5 int times = argv[1];
6 for (int count= 0;count<times; count++)
7 	std::cout << count <<'';
8
9 return 0;
10 }

Нет проверки и преобразования в число. Будет ошибка.

Ответ No 2.e)



Задание No 3

Лучшим алгоритмом определения того, существует ли значение в отсортированном массиве или нет, является бинарный
поиск.
Бинарный поиск работает следующим образом:
 Смотрим на центральный элемент массива.
 Если центральный элемент массива больше элемента, который мы ищем, то всё, что находится справа от
центрального элемента — отбрасываем.
 Если центральный элемент меньше элемента, который мы ищем, то отбрасываем всё, что находится слева от
центрального элемента.
 Если центральный элемент равен элементу, который мы ищем, то возвращаем индекс этого элемента.
 Если перебрали весь массив и не нашли искомого значения, то возвращаем контрольное значение с выводом not
found .

Поскольку в каждой итерации мы можем отбрасывать сразу половину массива, то скорость выполнения этого алгоритма
достаточно большая. Даже с массивом в миллион элементов для определения того, существует ли конкретное значение в
этом массиве или нет, потребуется не более 20 итераций! Однако бинарный поиск работает только в отсортированном
массиве.
Изменение массива (например, отбрасывание половины элементов массива) является затратной операцией, поэтому
обычно массив не изменяется. Вместо этого используется два целочисленных значения (min и max) для хранения
индексов минимальной и максимальной границ поиска элемента в массиве.

Рассмотрим пример работы этого алгоритма с массивом {4, 5, 7, 10, 11, 14, 19, 20, 25} и искомым значением 7.
Сначала min = 0, max = 8, так как мы перебираем весь массив (всегоэлементов 9, но индекс последнего элемента равен 8).

 Итерация No 1: Вычисляем среднее значение между min (0) и max (8), которое равно 4. Элемент No 4 имеет значение
11, которое больше нашего искомого значения. Поскольку массив отсортирован,то мы знаем,что все элементы, которые
находятся справа от индекса 4 (и индекс 4 тоже) являются больше нашего искомого числа. Поэтому min оставляем
прежним, а max изменяем на 3.     

 Итерация No 2: Вычисляем среднее значениемежду min (0) и max (3),которое равно 1. Элемент No1 имеет значение
5, которое меньше нашего искомого значения. Поскольку массив отсортирован, то мы знаем, что все элементы, которые
находятся слева от индекса 1 (и индекс 1 тоже) — меньше нашего искомого числа. Следовательно, min изменяем на 2, а
max оставляем прежним.

 Итерация No 3: Вычисляем среднее значение между min (2) и max (3), которое равно 2. Элемент No2 имеет значение
7, которое является нашим искомым значением. Возвращаем элемент No 2 Используяследующий код:

1 // array-это массив, в котором мы проводим поиски.
2 // target - это искомое значение.
3 // min -это индекс минимальной границы массива, в котором мы осуществляем поиск.
4 // max -это индекс максимальной границы массива,в котором мы осуществляем поиск.
5 // Функция binarySearch() должна возвращать индекс искомого значения, если он обнаружен. В противном случае, возвращаем -1
6 int binarySearch(int *array, int target, int min, int max)
7 {
8
9 }
10
11 int main()
12 {
13 int array[] = { 4, 7, 9, 13, 15,19, 22,24, 28,33, 37,41, 43,47, 50};
15 std::cout<<"Enter a number: ";
14
16 int x;
17 std::cin >> x;
18
19 int index = binarySearch(array, x, 0, 14);
20
21 if (array[index] ==x)
22 	std::cout << "Good! Your value " << x << " is on position"<< index<<" inarray!\n";
23 else
24 	std::cout << "Fail! Your value " << x << " isn't in array!\n";
25 return 0;
26 }

a) Напишите итеративную версию функции binarySearch().
#include <cassert>

int binarySearch(int *ar, int x, int min, int max){
    assert ((x>0 && min>=0 && max>0 && (ar) && ar[min]<=x && ar[max]>=x) && " Incorrect arguments");
    int mid;
	while(1)
	{
        	if(ar[min] == x)
            		return min;
        	if(ar[max] == x)
            		return max;
		if( (max-min<=1))
            		return -1;

		mid=min+(max-min)/2;

		if(x == ar[mid])
			return mid;
	        else
        	        (x < ar[mid]) ? max=mid : min=mid;
	}
}



Ответ No 3.а)



b) Напишите рекурсивную версию функции binarySearch().

int binarySearchR(int *ar, int x, int min, int max){
    assert ((x>0 && min>=0 && max>0 && (ar) && ar[min]<=x && ar[max]>=x) && " Incorrect arguments");
    int mid;

       	if(ar[min] == x)
       		return min;
       	if(ar[max] == x)
       		return max;
	if( (max-min<=1))
       		return -1;

	mid=min+(max-min)/2;

	if(x == ar[mid])
		return mid;
        else
	{
       	        (x < ar[mid]) ? max=mid : min=mid;
		return binarySearch(ar,x,min,max);
	}

}


Ответ No 3.b)
