Урок No147. Композиция объектов

В реальной жизнисложные объекты часто состоятиз меньших, более простых объектов. Например, автомобиль состоит из
металлической рамы, двигателя, четырех колес, коробки передач, руля и большого количества других деталей. Персональный
компьютер состоит из центрального процессора, материнской платы, памятии пр. Даже вы состоите из небольших частей: у
вас есть голова, ноги, руки и т.д. Процесс построения сложных объектов из более простых называется композицией объекта.

Оглавление:
1. Типы композиции объектов
2. Композиция
3. Реализация композиций
4. Еще один пример
5. Вариации композиции
6. Композиция и подклассы


Типы композиции объектов

В композиции между двумя объектами представлен тип отношения «имеет». Автомобиль «имеет» коробку передач. Ваш
компьютер «имеет» центральный процессор. Вы «имеете» сердце. Сложный объект иногда называют целым (или
«родителем»). Более простой объект часто называют частью (или «дочерним элементом», «компонентом»).
Ранее мы рассматривали, что структуры и классы могут иметь члены разных типов данных (например, фундаментальных или
вообще других классов). Когда мы создаем классы с членами, то мы, по сути, создаем сложный объект из более простых частей,
чтои является композицией объекта. По этой причине структуры и классы еще называют составными типами данных.

Композиция объектов полезна в контексте языка C++, поскольку позволяет создавать сложные классы, объединяя более
простые и легкоуправляемые части. Это уменьшает сложность и позволяет писать код быстрее и с меньшим количеством
ошибок, так как мы можем повторно использовать код, который уже был написан, протестирован, и является рабочим.
Существует два основных подтипа композиции объекта: композиция и агрегация. На этом урокемы рассмотрим
композицию, а на следующем — агрегацию.

Примечание по терминологии: Термин «композиция» часто используется для обозначения композиции и агрегации, как
единого целого, а не только подтипа композиция. На этом уроке мы будем использовать термин «композиция объекта»,
когдабудем иметь в виду целое (и композицию, и агрегацию), а термин «композиция», когда речь будет идти конкретно о
подтипе композиция.

Композиция

Для реализации композиции объект и часть должны иметь следующие отношения:
 Часть(член) является частью объекта (класса).
 Часть(член) может принадлежать только одному объекту (классу) в моменте.
 Часть(член) существует, управляемая объектом (классом).
 Часть(член) не знает осуществовании объекта (класса).

Хорошим примером композиции в жизни является взаимосвязь междутелом человека и его сердцем. Рассмотрим это
детально.
Отношения в композиции — это отношения части-целого. Например, сердце является частью тела человека. Часть в
композиции может быть частью только одного объекта в моменте. Сердце, которое является частью тела одного человека, не
может быть одновременно частью тела еще одного человека.

В отношениях внутри композиции объект несет ответственность за существование частей. Чащевсего это означает, что часть
создается при создании объекта и уничтожается при его уничтожении. Но в более широком смысле это означает, что объект
управляет временем жизни части таким образом, что пользователь, который использует объект, не должен участвовать в
этом. Например, при создании тела создается и сердце. Когда тело человека уничтожается, то и его сердце уничтожается тоже.
И, наконец, часть не знает о существовании целого. Ваше сердце работает круглосуточно, не зная, что оно является частью
более крупной организации. Это называется однонаправленным отношением, поскольку тело знает о сердце, а сердце о теле
— нет.
Обратите внимание, в композиции ничего не говорится о переносимости частей. Сердце можно пересадить из тела одного
человека в тело другому человеку. Однако даже после пересадки оно по-прежнему будет соответствовать требованиям
композиции (сердце принадлежит другому человеку и может бытьчастью только этого другого человека и никого больше до
тех пор, пока сердце не пересадят снова).                        
Наш уже любимый класс Drob является отличным примером композиции:

1 class Drob
2 {
3 private:
4 	int m_numerator;
5 	int m_denominator;
6
7 public:
8 	Drob(int numerator=0, int denominator=1):
9 	m_numerator(numerator), m_denominator(denominator)
10 	{
11 		// Мы поместили метод reduce() в конструктор, чтобы убедиться, что все дроби будут уменьшены!
12 		reduce();
13 	}
14 };

Этот класс имеет два члена: m_numerator (числитель) и m_denominator (знаменатель). Числитель и знаменатель являются
частью Drob, они находятся в этом классе. Они не могут принадлежать еще одному классу одновременно. 
m_numerator и m_denominator не знают, что они являются частью Drob, они просто хранят целые числа. 
При создании объекта класса Drob создаются и m_numerator , и m_denominator. 
Когда объект класса Drob уничтожается, то и эти члены уничтожаются тоже.
Так как типом отношений в композиции объектов является «имеет» (тело «имеет»сердце, Drob «имеет» m_denominator), то
мы можем сказать, что композиция имеет и тип отношения «часть чего-то» (сердце является «частью» тела, m_numerator
является «частью» Drob). Композиция часто используется для моделирования физических отношений, где один объект
физически находится внутри другого объекта.

Части в композиции могут быть как сингулярными (единственными в своем роде), так и мультипликативными (таких частей
можетбыть несколько). Например, в теле человекаесть только одно сердце (сердце является сингулярным), но также 20
пальцев (пальцы являются мультипликативными и могут быть реализованы в виде массива).


Реализация композиций

Композиции являются одними из самых простых типов отношений для реализации на языке C++. Это обычные структуры или
классы с обычными членами. Поскольку члены существуют непосредственно как части структур/классов, то их
продолжительность жизни напрямую зависит от продолжительности жизни объектовэтих структур/классов.
Композиции, в которых выполняется динамическое выделение или освобождение памяти, могут быть реализованы с
использованием указателей в виде членов этих структур или классов. В этом случае управление памятью полностью
накладывается на композицию.
В общем, если вы можете создать класс, используя композицию, то вы должны создать класс, используя композицию. Классы
с реализованной композицией являются простыми, гибкими и надежными.

Еще один пример
Во многих играх есть существа или объекты, которые перемещаются по карте или вокруг каких-то объектов. Все эти существа/
объекты имеют одну общую вещь — локацию. В следующем примере мы создадим класс Creature, который использует класс
Point2D дляхранения местоположения (локации) существа.
Сначала создадим класс Point2D. Наше существо будет находиться в 2D-измерении, поэтому в нашем классе будет 2 члена: x и y.

Point2D.h:
1 #ifndef POINT2D_H
2 #define POINT2D_H
3
4 #include <iostream>
5
6 class Point2D
7 {
8 private:
9 	int m_x;
10 	int m_y;
11
12 public:
13 	// Конструктор по умолчанию
14 	Point2D()
15 		: m_x(0), m_y(0)
16 	{
17 	}
18
19 	// Специфический конструктор
20 	Point2D(int x, int y)
21 		: m_x(x), m_y(y)
22 	{
23 	}
24
25 	// Перегрузка оператора вывода
26 	friend std::ostream& operator<<(std::ostream& out, const Point2D &point)
27 	{
28 		out << "(" << point.m_x << ", " << point.m_y << ")";
29 		return out;
30 	}
31
32 	// Функция доступа
33 	void setPoint(int x, int y)
34 	{
35 		m_x = x;
36 		m_y = y;
37 	}
38
39 };
40
41 #endif

Обратите внимание, поскольку мы реализовали все наши функциив заголовочном файле (ради сохранения краткости
примера), у наснет Point2D.cpp.
Класс Point2D является целым, которое состоит из частей: x и y, продолжительность жизни которых напрямую зависит от
продолжительности жизни объектов класса Point2D.
Теперь создадим класс Creature. У нашего существа будет 2 свойства: имя (строка) и местоположение (объект класса Point2D).

Creature.h:
1 #ifndef CREATURE_H
2 #define CREATURE_H
3
4 #include <iostream>
5 #include <string>
6 #include "Point2D.h"
7
8 class Creature
9 {
10 private:
11 	std::string m_name;
12 	Point2D m_location;
13
14 public:
15 	Creature(const std::string &name, const Point2D &location)
16 		: m_name(name), m_location(location)
17 	{
18 	}
19
20 	friend std::ostream& operator<<(std::ostream& out, const Creature &creature)
21 	{
22 		out << creature.m_name << " is at " << creature.m_location;
23 		return out;
24 	}
25
26 	void moveTo(int x, int y)
27 	{
28 		m_location.setPoint(x, y);
29 	}
30 };
31 #endif

Класс Creature также является целым, которое состоит из частей: m_name и m_location, продолжительность жизни которых
также зависит от продолжительности жизни объектов класса Creature.

И, наконец, main.cpp:

1 #include <iostream>
2 #include <string>
3 #include "Creature.h"
4 #include "Point2D.h"
5
6 int main()
7 {
8 	std::cout << "Enter a name for your creature: ";
9 	std::string name;
10 	std::cin >> name;
11 	Creature creature(name, Point2D(5, 6));
12
13 	while (1)
14 	{
15 		// Выводим имя существа и его местоположение
16 		std::cout << creature << '\n';
17
18		std::cout << "Enter new X location for creature (-1 to quit): ";
19 		int x=0;
20 		std::cin >> x;
21 		if (x == -1)
22 			break;
23
24 		std::cout << "Enter new Y location for creature (-1 to quit): ";
25 		int y=0;
26 		std::cin >> y;
27 		if (y == -1)
28 			break;
29
30 		creature.moveTo(x, y);
31 	}
32
33 	return 0;
34 }

Результат выполнения программы:

Enter a name for your creature: Anton
Anton is at (5, 6)
Enter new X location for creature (-1 to quit): 7
Enter new Y location for creature (-1 to quit): 11
Anton is at (7, 11)
Enter new X location for creature (-1 to quit): 2
Enter new Y location for creature (-1 to quit): 4
Anton is at (2, 4)
Enter new X location for creature (-1 to quit): -1


Вариации композиции

Хотя в большинстве композиций создание/удаление частей происходит непосредственно при создании/удалении самой
композиции, есть вариации композиции, где правила несколько видоизменены, например:

 Композиция может отложить создание некоторых из своих частей до тех пор, пока они не понадобятся. Например,
строковый класс может не создавать динамический массив символов до тех пор, пока пользователь не предоставит данные,
которые эта строка могла бы хранить.

 Композиция может предпочесть использовать часть, которая была предоставлена ей в качестве входных данных, а не
создавать эту часть самостоятельно.

 Композиция может делегировать уничтожение своих частей другому объекту (например, процедуре сбора мусора).
Ключевым моментом является то, что композиция должна управлять своими частями самостоятельно, без вмешательства
пользователя композиции.


Композиция и подклассы

Одним из самых частых вопросов, которые задают новички, когда дело доходит до композиции объекта, является: «Когда я
должен использовать подкласс вместо непосредственной реализации?». Например, вместо использования класса Point2D для
реализации местоположения Creature, мы могли быпросто добавить в класс Creature еще два члена ( m_x и m_y) и записать
весь код реализации местоположения в классе Creature. Тем не менее, в создании Point2D есть ряд преимуществ:

Преимущество No1: Каждый отдельный класс можно сохранить относительно простым/понятным и сфокусировать на
выполнение одной конкретной задачи. Таким образом, писать классы легче и понимать их проще. Например, в Point2D всё
вертится только вокруг местоположения и это позволяет сохранить общую картину программы более простой.

Преимущество No2: Каждый подкласс может быть автономным, что делает его многоразовым. Например, мы можем повторно
использовать наш класс Point2D в совершенно другой программе. Или, если нашему Creature когда-либо понадобится еще
один пункт в определении локации (например, место куда ему нужно будет добраться), мы можем простодобавить еще одну
переменную-член в Point2D.

Преимущество No3: Родительский класс может оставить выполнение большей части сложной работы на подклассы, а сам
сосредоточиться на координации потока данных между подклассами. Это поможет снизить общую сложность родительского
объекта, поскольку родительский объект делегирует выполнение работы своим дочерним элементам, которые уже знают, как
выполнять эти задания. Например, при перемещении нашего Creature, сам Creature делегирует выполнение перемещения
классу Point2D, который уже понимает, как работать с местоположением. Таким образом, класс Creature не должен
беспокоиться о том, как такие вещи реализовать.

Хорошим правилом является то, что один класс должен выполнять одну конкретную задачу (как в примере с функциями).
Этой задачей может быть хранение, манипулирование данными или координация подклассов.
В нашем случае есть смысл в том, чтобы Creature не беспокоился о реализации местоположения. Задача Creature состоит не в
том, чтобы знать все подробности, а в том, чтобы координировать поток данных и гарантировать, что каждый из подклассов
знает, что он должен делать. То, как следует выполнять конкретные задания — зависит уже от каждого подкласса отдельно.
