Урок No 40. Инкремент, декремент и побочные эффекты

На этом уроке мы рассмотрим, что такое инкремент и декремент в языке С++, а также разберемся с таким понятием, как
«побочные эффекты».

Оглавление:
1. Инкремент идекремент
2. Побочные эффекты


Инкремент и декремент

Операции инкремента (увеличение на 1) и декремента (уменьшение на 1) переменных настолько используемые, что у них
есть свои собственные операторыв языке C++. Кроме того, каждый из этих операторов имеет две версии применения: 
префикс и постфикс.
-----------------------------------------------------------------------------------------------------------
Оператор	 			Символ		Пример		 Операция
-----------------------------------------------------------------------------------------------------------
Префиксный инкремент(пре-инкремент)      ++		 ++x		 Инкремент x, затем вычисление x
Префиксный декремент(пре-декремент)	 −−		 −−x		 Декремент x, затем вычисление x
Постфиксный инкремент(пост-инкремент)	 ++		 x++		 Вычисление x, затем инкремент x
Постфиксный декремент(пост-декремент)	 −−		 x−−		 Вычислениеx, затем декремент x
-----------------------------------------------------------------------------------------------------------

С операторами инкремента/декремента версии префикс всё просто. Значение переменной х сначала увеличивается/
уменьшается, а затем уже вычисляется. Например:
1 int x =5;
2 int y =++x; // x = 6 и 6 присваивается переменной y

А вот с операторами инкремента/декремента версии постфикс несколько сложнее. Компилятор создает временную копию
переменной х, увеличивает или уменьшает оригинальный х (не копию), а затем возвращает копию. Только после возврата
копия х удаляется. Например:

1 int x = 5;
2 int y = x++; // x = 6, но переменной y присваивается 5

Рассмотрим вышеприведенный код детально. Во-первых, компилятор создает временную копию х, котораяимеет то же
значение, что и оригинал (5). Затем увеличивается первоначальный х с 5 до 6. После этого компиляторвозвращает
временную копию, значением которой является 5, и присваивает её переменной у. Только после этого копия x
уничтожается. Следовательно, в вышеприведенном примере мы получим у = 5 и х = 6.
Вот еще один пример, показывающий разницу между версиями префикс и постфикс:

1 #include <iostream>
2
3 int main()
4 {
5 int x = 5, y = 5;
6 std::cout << x << " " << y << std::endl;
7 std::cout << ++x << " " << --y << std::endl; // версия префикс
8 std::cout<< x << " " << y << std::endl;
9 std::cout<< x++ << " " << y-- << std::endl; // версия постфикс
10 std::cout << x << " " << y << std::endl;
11
12 return 0;
13 }

Результат выполненияпрограммы:
5 5
6 4
6 4
6 4
7 3

В строке No 7 переменные х и у увеличиваются/уменьшаются на единицу непосредственно перед обработкой компилятором,
так что сразу выводятся их новые значения. А в строке No 9 временные копии (х = 6 и у = 4 ) отправляются в cout, а только
после этого исходные х и у увеличиваются/уменьшаются на единицу. Именно поэтому изменения значений переменных
после выполнения операторов версии постфикс не видно до следующей строки.
Версия префикс увеличивает/уменьшает значения переменных перед обработкой компилятором, версия постфикс — после
обработки компилятором.

Правило: Используйте префиксный инкремент и префиксный декремент вместо постфиксного инкремента и
постфиксного декремента. Версии префикс не только более производительны, но и ошибок с ними (по статистике)
меньше.


Побочные эффекты

Функция или выражение имеет побочный эффект, если она/оно изменяет состояние чего-либо, делает ввод/вывод или
вызывает другие функции, которые имеютпобочные эффекты.
В большинстве случаев побочные эффекты являются полезными:
1 #include <iostream>
2
3 int main()
4 {
5 int x = 5;
6 ++x;
7 std::cout << x;
8
9 return 0;
10 }

В примере, приведенном выше, оператор присваивания имеетпобочный эффект, который проявляется в изменении значения
переменной х. Оператор ++ имеет побочный эффект инкремента переменной х. Вывод х имеет побочный эффект внесения
изменений в консольное окно.
Также побочные эффекты могут приводить и к неожиданным результатам:

1 #include <iostream>
2
3 int add(int x, int y)
4 {
5 return x + y;
6 }
7
8 int main()
9 {
10 int x = 5;
11 int value= add(x, ++x); //здесь 5+6 или 6 + 6? Это зависит от компилятора и от того, в каком порядке он будетобрабатываться
12
13 std::cout<< value; // результатом может быть 11 или 12
14
15 return 0;
16 }

Язык C++ не определяет порядок, в котором вычисляются аргументы функции. Если левый аргумент будет вычисляться
первым, то add(5, 6) и результат — 11. Если правый аргумент будет вычисляться первым, то add(6, 6) и результат— 12 !
А проблема то кроется в побочном эффекте одного из аргументов функции add().
Вот еще один пример:

1 #include <iostream>
2
3 int main()
4 {
5 int x = 1;
6 x = x++;
7 std::cout << x;
8
9 return 0;
10 }

Какой результат выполнения этой программы? 
Если инкремент переменной х выполняется до операции присваивания, то
ответ — 1. Если же после операции присваивания, то ответ — 2.
Есть и другие случаи, в которых C++ не определяет порядок обработки данных, поэтому в разных компиляторах могут быть
разные результаты. Но даже в тех случаях, когда C++ и уточняет порядок обработки данных, некоторые компиляторы все равно
вычисляют переменные с побочными эффектами некорректно. Этого всего можно избежать, если использовать переменные с
побочными эффектами не более одного раза водном стейтменте.

Правило: Не используйте переменную с побочным эффектом больше одного раза в одном стейтменте.
