Урок No 46. Битовые флаги и битовые маски


На этом уроке мы рассмотрим битовые флаги и битовыемаски в языке С++.

Примечание: Длянекоторых этот материал может показаться немного сложным. Если вы застряли или что-то не
понятно — пропустите этот урок, в будущем сможете вернуться и разобраться детально. Он нестоль важен для
прогресса в изучении языка C++, как другие уроки, и изложен здесь в большей мере для общего развития.

Оглавление:
1. Битовые флаги
2. Почему битовые флаги полезны?
3. Введение в std::bitset
4. Битовые маски
5. Пример сRGBA
6. Заключение
7. Тест
8. Ответы


Битовые флаги

Используя целый байт для хранения значения логического типа данных, вы занимаете только 1 бит,а остальные 7 из 8 —
не используются. Хотя в целом это нормально, но в особых, ресурсоёмких случаях, связанных с множеством логических
значений, может быть полезно «упаковать» 8 значений типа bool в 1байт, с экономив при этом память и увеличив, таким
образом, производительность. Эти отдельные битыи называются битовыми флагами. Поскольку доступ к этим битам
напрямую отсутствует, то для операций с ними используются побитовыеоператоры.

Примечание: На этом урокемы будем использовать значения из шестнадцатеричной системы счисления.
Например:
1 // Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите).
2 // Обратите внимание, в C++11 лучше использовать "uint8_t" вместо "unsigned char"
3 const unsigned char option1=0x01; // шестнадцатеричный литерал для 0000 0001
4 const unsigned char option2=0x02; // шестнадцатеричный литерал для 0000 0010
5 const unsigned char option3=0x04; // шестнадцатеричный литерал для 0000 0100
6 const unsigned char option4=0x08; // шестнадцатеричный литерал для 0000 1000
7 const unsigned char option5=0x10; // шестнадцатеричный литерал для 0001 0000
8 const unsigned char option6=0x20; // шестнадцатеричный литерал для 0010 0000
9 const unsigned char option7=0x40; // шестнадцатеричный литерал для 0100 0000
10 const unsigned char option8=0x80; // шестнадцатеричный литерал для 1000 0000
11
12 // Байтовое значение для хранения комбинаций из 8 возможных вариантов
13 unsigned char myflags=0; // все флаги/параметры отключены до старта

Чтобы узнать битовое состояние (значение конкретного бита), используется побитовое И:
1 if (myflags&option4)...// если option4 установлено (четвертый бит равен 1) - что-нибудь делаем

Чтобы включить (установить в 1) конкретные биты, используется побитовое ИЛИ:
1 myflags|=option4; / /включаемoption4
2 myflags|=(option4 | option5); // включаем option4 и option5

Чтобы выключить (установить в 0) конкретные биты, используется побитовое И с инвертированным литералом:
1 myflags&= ~option4;// выключаем option4
2 myflags&= ~(option4|option5); // выключаем option4 и option5

Для переключения между состояниями бит, используется побитовое исключающее ИЛИ (XOR):
1 myflags^= option4; //включаем или выключаем option4
2 myflags^= (option4 | option5);// изменяем состояния option4 и option5

В качестве примера возьмем библиотеку 3D-графики OpenGL, в которой некоторые функции принимают один или
несколько битовых флагов в качестве параметров:

1 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // очищаем буфер цвета и глубины

GL_COLOR_BUFFER_BITи GL_DEPTH_BUFFER_BIT определяются следующим образом(вgl2.h):
1 #define GL_DEPTH_BUFFER_BIT	 0x00000100
2 #define GL_STENCIL_BUFFER_BIT	 0x00000400
3 #define GL_COLOR_BUFFER_BIT	 0x00004000

Вотнебольшой пример:
1 #include <iostream>
2
3 int main()
4 {
5 // Определяем набор физических/эмоциональных состояний
6 const unsigned charis Hungry = 0x01; // шестнадцатеричный литерал для 0000 0001
7 const unsigned char isSad = 0x02; // шестнадцатеричный литерал для 	0000 0010
8 const unsigned char isMad = 0x04; // шестнадцатеричный литерал для	0000 0100
9 const unsigned char isHappy = 0x08; //шестнадцатеричный литерал для	0000 1000
10 const unsigned char isLaughing=0x10; //шестнадцатеричный литерал для	0001 0000
11 const unsigned char isAsleep = 0x20; // шестнадцатеричныйлитерал для 0010 0000
12 const unsigned char isDead = 0x40; // шестнадцатеричный литерал для 	0100 0000
13 const unsigned char isCrying = 0x80;//шестнадцатеричный литерал для	1000 0000
14
15 unsigned char me = 0; // все флаги/параметры отключены до старта
16 me|= isHappy|isLaughing; //Я isHappy и isLaughing
17 me&= ~isLaughing; // Я уже не isLaughing
18
19 // Запрашиваем сразу несколько состояний (мы будем использовать static_cast<bool> для конвертации результатов в значения типа bool)
20 std::cout<< "I am happy?" << static_cast<bool>(me & isHappy)<< '\n';
21 std::cout<< "Iam laughing?"<< static_cast<bool>(me & isLaughing)<< '\n';
22
23 return0;
24 }


Почему битовые флаги полезны?

Внимательные читатели заметят, что в примерах с myflags мы фактически не экономим память. 
8 логических значений займут 8 байт. Но пример, приведенный выше, использует 9 байт (8 для определения параметров и 1 для битового флага)!
Так зачем же тогда нужны битовые флаги?
Они используются в двух случаях:

Cлучай No 1: 
Еслиу вас много идентичных битовых флагов.
В место одной переменной myflags, рассмотрим случай, когда у вас есть две переменные: myflags1 и myflags2, каждая
из которых может хранить 8 значений. Если вы определите их какдва отдельных логических набора, то вампотребуется 16
логических значенийи, таким образом, 16 байт. Однако с использованием битовых флагов вам потребуется только 10 байт
(8 для определения параметров и 1 для каждой переменной myflags). А вот если у васбудет 100 переменных myflags, то,
используя битовые флаги, вам потребуется 108 байт вместо 800. Чем больше идентичных переменных вам нужно, тем
более значительной будет экономия памяти.
Давайте рассмотрим конкретный пример. Представьте, что вы создаете игру, вк оторой игроку придется бороться с
монстрами. Монстр, в свою очередь, может быть устойчив к определенным типам атак (выбранных случайным образом). 
В игре есть следующие типы атак: яд, молнии, огонь, холод, кража, кислота, паралич и слепота.
Чтобы отследить, к какому типу атаки монстр устойчив, мы можем использовать одно логическое значение на
сопротивление (для одногомонстра). Это 8 логических значений (сопротивлений) для одного монстра = 8 байт.
Для 100 монстров это будет 800 переменных типа bool и 800 байт памяти.
А вот и спользуя битовые флаги:
1 const unsigned char resistsPoison = 0x01;
2 const unsigned char resistsLightning = 0x02;
3 const unsigned char resistsFire = 0x04;
4 const unsigned char resistsCold = 0x08;
5 const unsigned char resistsTheft = 0x10;
6 const unsigned char resistsAcid = 0x20;
7 const unsigned char resistsParalysis = 0x40;
8 const unsigned char resistsBlindness = 0x80;
Намнужен будет только 1 байт для хранения сопротивления каждого монстра и одноразовая плата в 8 байт для типов атак.
Таким образом, потребуется только 108 байт или примерно в 8 раз меньше памяти.
В большинстве программ, сохраненный объем памяти с использованием битовых флагов не стоит добавленной сложности.
Но в программах, где есть десятки тысяч или даже миллионы похожих объектов, их использование может значительно
сэкономить память. Согласитесь, знать о таком полезном трюке не помешает.

Случай No 2: 
Представьте, что у вас есть функция, которая может принимать любую комбинацию из 32 различных
вариантов.
Одним из способов написания такой функции является использование 32 отдельных логических параметров:
1 void someFunction(booloption1,bool option2,booloption3, bool option4,bool option5, booloption6,bool option7, boolo
ption8,bool option9, booloption10, booloption11, booloption12, booloption13, booloption14,booloption15,booloptio
4, booloption25, booloption26, booloption27,booloption28,booloption29,booloption30,booloption31,bool option3
n16, booloption17, booloption18, booloption19, booloption20, booloption21,booloption22,booloption23,booloption2
2);

Затем, если выз ахотите вызвать функцию с 10-м и 32-м параметрами, установленными как true — вам придется сделать
следующее:
1 someFunction(false, false,false,false, false,false,false, false, false,true, false,false, false, false,false,false, 
false,false,false, false,false,false, false, false,false,false, false,false,false, false, false,true);

Т.е. перечислить все варианты как false, кроме 10 и 32 — они true.
Читать такой код сложно, да и требуется держать в памяти порядковые номера нужных параметров (10 и 32 или 11 и 33?).
Такая простыня не может быть эффективной. А вот если определить функцию с помощью битовых флагов:
1 void someFunction(unsigned int options);
То можно выбирать и передавать только нужные параметры:
1 someFunction(option10 | option32);

Кроме того, что это читабельнее, это также эффективнее и производительнее, так как включает только 2 операции 
(1 побитовое ИЛИ и 1 передача параметров).
Вот почему в OpenGL используют битовые флаги вместо длинной последовательности логических значений.
Также, если у вас есть не используемые битовые флаги и вам нужно позже добавить параметры, вы можете просто
определить битовый флаг. Нет необходимости изменять прототип функции, а этоплюс к обеспечению обратной
совместимости.


Введение в std::bitset

Все эти биты, битовые флаги, операции-манипуляции — всё это утомительно, не правда ли?
К счастью, в Стандартной библиотеке C++ есть такой объект, как std::bitset, который упрощает работу с битовыми флагами.
Для его использования необходимо подключить заголовочный файл bitset, а затем определить переменную типа
std::bitset, указав необходимое количество бит. Она должна быть константой типа compile time.
1 #include <bitset>
2
3 std::bitset<8> bits;// нам нужно 8бит
При желании std::bitset можно инициализировать начальным набором значений:
1 #include <bitset>
2
3 std::bitset<8>bits(option1 | option2) ; //начнем с включенных option1 и option2
4 std::bitset<8> morebits(0x2); //начнем с битового шаблона 0000 0010

Обратите внимание, наше начальное значение конвертируется в двоичную систему. Так как мы ввели
шестнадцатеричное 2,то std::bitset преобразует его в двоичное 00000010.
В std::bitset есть 4 основные функции:
 функция test() — позволяет узнатьзначение бита(0или1).
 функция set() — позволяет включить биты (если они уже включены, то ничего не произойдет).
 функция reset() — позволяет выключить биты (если они уже выключены, то ничего не произойдет).
 функция flip() — позволяет изменить значения бит на противоположные (с 0 на 1 или с 1 на 0).

Каждая из этих функций принимает в качестве параметров позиции бит. Позиция крайнего правого бита (последнего)
равна 0, затем порядковый номер растет с каждым последующим битом влево (1,2,3,4 и т.д.). Старайтесь давать
содержательные имена битовым индексам (либо путем присваивания их константным переменным, либо с помощью
перечислений — о них мы поговорим на соответствующем уроке).
1 #include<iostream>
2 #include<bitset>
3
4 //Обратите внимание, используя std::bitset, наши options соответствуют порядковым номерам бит, а неих значениям
5 const int option_1 = 0;
6 const int option_2 = 1;
7 const int option_3 = 2;
9 const int option_5 = 4;
8 const int option_4 = 3;
11 const int option_7 = 6;
10 const int option_6 = 5;
12 const int option_8 = 7;
13
14 int main()
15 {
17 std::bitset<8> bits(0x2); // нам нужно 8 бит, начнем с битового шаблона 0000 0010
16 //Помните,что отсчет бит начинается не с 1, а с 0
18 bits.set(option_5); // включаем 4-й бит -его значение изменится на 1 (теперь мы имеем 0001 0010)
19 bits.flip(option_6); // изменяем значения 5-го бита на противоположное (теперь мы имеем 0011 0010)
20 bits.reset(option_6); // выключаем 5-й бит - его значение снова 0 (теперь мы имеем 0001 0010)
21
22 std::cout<< "Bit 4 has value:" << bits.test(option_5) << '\n';
23 std::cout<< "Bit 5 has value:"<< bits.test(option_6)<<'\n';
24 std::cout<< "All the bits: " << bits <<'\n';
25
26 return 0;
27 }

Результат выполнения программы:
Bit 4 has value: 1
Bit 5 has value: 0
All the bits: 00010010

Обратите внимание, отправляя переменную bits в std::cout — выводятся значения всех бит в std::bitset.
Помните, что инициализируемое значение std::bitset рассматривается как двоичное, в товремякак функции std::bitset
используют позиции бит!

std::bitset также поддерживает стандартные побитовые операторы (|, & и ^), которые также можно использовать (они
полезны при проведении операций одновременно сразу с несколькими битами).
Вместо выполнения всех побитовых операций вручную, рекомендуется использовать std::bitset, так как он более удобен и
менее подвержен ошибкам.


Битовые маски

Включение, выключение, переключение или запрашивание сразу нескольких битможно осуществить в одной битовой операции.
Когда мы соединяем отдельные битыв месте, в целях их модификации как группы, то это называется битовой маской.
Рассмотрим пример. 
В следующей программе мы просим пользователяв вести число. Затем, используя битовую маску, мы
сохраняем только последние 4 бита, значения которых и выводим в консоль:

1 #include <iostream>
2
3 int main()
5 const unsigned int lowMask=0xF; //битовая маска для хранения последних 4бит (шестнадцатеричный литерал для 0000 0000 0000 1111)
4 {
7 std::cout<< "Enter an integer: ";
6
8 int num;
9 std::cin >> num;
10
11 num &=lowMask; // удаляем первые биты, оставляя последние 4
12
13 std::cout << "The 4 low bits have value:" << num << '\n';
14
15 return 0;
16 }

Результатвыполненияпрограммы:
Enter an integer: 151
The 4 low bits have value: 7

151 в десятичной системе равно 10010111 в двоичной.
lowMask — это 0000 1111 в 8-битной двоичной системе.
1001 0111 & 0000 1111 = 00000111, что равно десятичному 7.

Пример с RGBA
Цветные дисплейные устройства, такие как телевизоры и мониторы, состоят из миллионов пикселей, каждый из которых
может отображать точку определенного цвета. Точка каждого цвета состоит из смеси 3 цветов: красного, зелёного и синего (сокр. «RGB» от
англ. «Red,Green,Blue»). Изменяя их интенсивность, можно воссоздать любой цвет. 
Количество цветов R, G и В в одном пикселе представлено 8-битным целым числомun signed. 
Например, красный цвет имеет сумму трех цветов: R=255, G =0, B=0; фиолетовый: R=255, G=0, B=255; серый: R=127 ,G=127, B=127.
Используется еще 4-е значение, которое называется А.
«А» от англ. «Alfa», которое отвечает за прозрачность. Если А=0, то
цвет полностью прозрачный. Если А=255, то цвет непрозрачный.
В совокупности R, G,В и А составляют одно 32-битное целое число, с 8 битами для каждого компонента:

32 - битное значение RGBA:
------------------------------------------------------------
биты 31-24 	 биты 23-16	 биты 15-8 	 биты 7-0
------------------------------------------------------------
RRRRRRRR	 GGGGGGGG	 BBBBBBBB	 AAAAAAAA
------------------------------------------------------------
red		 green		 blue		 alpha
------------------------------------------------------------

Следующая программа просит пользователя ввести 32-битное шестнадцатеричное значение,
а затем извлекает 8-битные цветовые значения R, G, B и A:

1 # include <iostream>
2
3 int main()
4 {
5 const unsigned int redBits = 0xFF000000;
6 const unsigned int greenBits = 0x00FF0000;
7 const unsigned int blueBits = 0x0000FF00;
8 const unsigned int alphaBits = 0x000000FF;
9
11 unsigned int pixel;
10 std::cout << "Entera 32-bit RGBA color value in hexadecimal (e.g.FF7F3300):";
12 std::cin >> std::hex >> pixel; // std::hex позволяет вводить шестнадцатеричные значения
13
14 // Используем побитовое И для изоляции красных пикселей, а затем сдвигаем значение вправо в диапазон 0-255
15 unsigned char red=(pixel&redBits) >> 24;
17
 unsigned char blue = (pixel & blueBits) >> 8;
16
 unsigned char green = (pixel&greenBits) >> 16;
18
 unsigned char alpha = pixel & alphaBits;
19
20 std::cout << "Your color contains:\n";
21 std::cout << static_cast<int>(red) << " of 255 red\n";
22 std::cout << static_cast<int>(green) << " of 255 green\n";
23 std::cout << static_cast<int>(blue) << "of 255 blue\n";
25           
24 std::cout << static_cast<int>(alpha)<< " of 255 alpha\n";
26 return 0;
27 }

Результат выполнения программы:
Enter a 32-bit RGBA color value in hexadecimal (e.g.FF7F3300): FF7F3300
Your color contains:
255 of 25 5red
127 of 255 green
51 of 255 blue
0 of 255 alpha

В программе, приведенной выше, побитовое И используется для запроса 8-битного набора, который нас интересует, затем
мы его сдвигаем вправо в диапазон от 0 до 255 для хранения и вывода.
Примечание:RGBA иногда может храниться как ARGB. В таком случае, главным байтом является альфа.

Заключение
Давайте кратко повторим то, как включать, выключать, переключать и запрашивать битовые флаги.

Для запроса битового состояния используется побитовое И:
1 if (myflags&option4)...// если установлен option4, то делаем что-нибудь

Для включения битиспользуется побитовое ИЛИ:
1 myflags|= option4; //включаем option4
2 myflags|= (option4 | option5); // включаем option4 и option5

Для выключения бит используется побитовое И с инвертированным литералом:
1 myflags&= ~option4;// выключаем option4
2 myflags&= ~(option4|option5); //выключаем option4 и option5

Для переключения между битовыми состояниями используется побитовое исключающее ИЛИ (XOR):
1 myflags^= option4; // включаем или выключаем option4
2 myflags^= (option4 | option5);// изменяем на противоположные option4 и option5

Тест
Есть следующий фрагмент кода:

1 int main()
2 {
3 unsigned char option_viewed = 0x01;
4 unsigned char option_edited = 0x02;
5 unsigned char option_favorited=0x04;
6 unsigned char option_shared = 0x08;
7 unsigned char option_deleted=0x80;
8
9 unsigned charmy ArticleFlags;
10
11 return 0;
12 }

Примечание: Статья — это myArticleFlags.
Задание No 1
Добавьте строку кода, чтобы пометить статью как уже прочитанную (option_viewed).
myArticleFlags|=option_viewed;

Задание No 2
Добавьте строку кода, чтобы проверить, былали статья удалена (option_deleted).
if(myArticleFlags&option_deleted) std::cout<<"Удалена\n";

Задание No 3
Добавьте строку кода, чтобы открепить статью от закрепленного места (option_favorited).
myArticleFlags&=~option_favorited;

Задание No 4
Почемуследующие две строки идентичны?
1 myflags&= ~(option4|option5); // выключаемoption4 и option5
2 myflags&= ~option4 & ~option5; // выключаем option4 и option5


Ответы
ОтветNo1
myArticleFlags |= option_viewed;


ОтветNo2
if (myArticleFlags & option_deleted) …

ОтветNo3
myArticleFlags &= ~option_favorited;

ОтветNo4
Законы Де Моргана гласят, что если мы используем побитовое НЕ, то операторы И и ИЛИ меняются местами. 
Следовательно, ~(option4 | option5) становится ~option4 & ~option5.
