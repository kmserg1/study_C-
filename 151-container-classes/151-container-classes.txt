Урок No 151. Контейнерные классы

В реальной жизни мы постоянно используем контейнеры. Гречка с куриной грудкой в контейнере для еды, страницы в книге с
обложкой и переплетом,вещи в тумбочке/рюкзаке и т.д. Без этих контейнеров было бы крайне неудобно работать с
объектами, находящимися внутри. Представьте, что вы пытаетесь читать книгу без переплета и обложки, или пытаетесь есть
гречку с грудкой, не используя контейнер для еды/миску/тарелкуи т.д. Непорядок! Ценность контейнеров заключается в том,
что они помогают должн ымобразом организовать и хранить объекты.

Оглавление:
1. Контейнерные классы
2. Типы контейнерных классов
3. Контейнерный класс-массив


Контейнерные классы

Контейнерный класс (или «класс-контейнер») в языке C++ — это класс, предназначенный для хранения и организации
нескольких объектов определенного типа данных (пользовательских или фундаментальных). Существует много разных
контейнерных классов, каждый из которых имеет свои преимущества, недостатки или ограничения в использовании.
Безусловно, наиболее частоиспользуемым контейнером в программировании является массив, который мы уже
использовали во многих примерах. Хотяв языке C++ есть стандартные обычные массивы, большинство программистов
используют контейнерные классы-массивы: std::array или std::vector из-за преимуществ, которые они предоставляют.
В отличие от стандартных массивов, контейнерные классы-массивы имеют возможность динамического изменения своего
размера, когда элементы добавляются или удаляются. Это не только делает их более удобными, чем обычные массивы, но и
безопаснее.

Обычно, функционал классов-контейнеров языка C++ следующий:

 Создание пустого контейнера (через конструктор).
 Добавление нового объекта в контейнер.
 Удаление объекта из контейнера.
 Просмотр количества объектов, находящихся на данный момент в контейнере.
 Очистка контейнера от всех объектов.
 Доступ к сохраненным объектам.
 Сортировка объектов/элементов (не всегда).

Иногда функционал контейнерных классов может быть не столь обширным, какэто указано выше. Например, контейнерные
классы-массивы часто не имеют функционала добавления/удаления объектов, так как они и так медленные, и разработчик
просто не хочет увеличивать нагрузку.

Типом отношений в классах-контейнерах является «член чего-то». Например,элементы массива «являются членами»
массива (принадлежат ему). Обратите внимание, мы здесь используем термин «член чего-то» не в смысле члена класса C++.


Типы контейнерных классов

Контейнерные классы обычно бывают двух типов:

 Контейнеры значения — это композиции, которые хранят копии объектов (и, следовательно, ответственны за
создание/уничтожениеэтих копий).
 Контейнеры ссылки — это агрегации, которые хранят указатели или ссылки на другие объекты (и, следовательно, не
ответственны за создание/уничтожениеэтих объектов).

В отличие от реальной жизни, когда контейнеры могут хранить любые типы объектов, которые в них помещают, в языке C++
контейнеры обычно содержат только один тип данных. Например, если у вас целочисленный массив, то он может содержать
только целочисленные значения. В отличие от некоторых других языков программирования, C++ не позволяет смешивать
разные типы данных внутри одного контейнера. Если вамнужны контейнеры для хранения значений типов int и double, то вам
придется написать два отдельных контейнера (или использовать шаблоны, о которых мы поговорим на соответствующем
уроке). Несмотря на ограничения их использования, контейнеры чрезвычайно полезны, так как делают программирование
проще, безопаснее и быстрее.


Контейнерный класс-массив

Сейчас мы напишем целочисленный класс-массив с нуля, реализуя функционал контейнеров в языке С++. Этот класс-массив
будет типа контейнера значения, в котором будут храниться копии элементов, а не сами элементы.

Сначала создадим файл ArrayInt.h:
1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 class ArrayInt
5 {
6 };
7
8 #endif

Наш ArrayInt должен отслеживать два значения: данные и свою длину. Поскольку мы хотим, чтобы наш массив мог изменять
свою длину, то нам нужно использовать динамическое выделение памяти, что означает, что мы будем использовать
указатель для хранения данных:

1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 class ArrayInt
5 {
6 private:
7 	int m_length;
8 	int *m_data;
9 };
10
11 #endif

Теперь нам нужно добавить конструкторы, чтобы иметь возможность создавать объекты класса ArrayInt. Мы добавим два
конструктора: первый будет создавать пустой массив, второй — массив заданного размера:

1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 #include <cassert> // для assert()
5
6 class ArrayInt
7 {
8 private:
9 	int m_length;
10 	int *m_data;
11
12 public:
13 	ArrayInt():
14 		m_length(0), m_data(nullptr)
15 	{
16 	}
17
18 	ArrayInt(int length):
19 		m_length(length)
20 	{
21 		assert(length >= 0);
22
23 		if(length > 0)
24 			m_data = new int[length];
25 		else
26 			m_data = nullptr;
27 	}
28 };
29
30 #endif

Нам также потребуются функции, которые будут выполнять очистку ArrayInt. Во-первых, добавим деструктор, который будет
просто освобождать любую динамически выделенную память. Во-вторых, напишем функцию erase(), которая будет выполнять
очисткумассива и сбрасывать его длину на 0 :

1 ~ArrayInt()
2 {
3 	delete[] m_data;
4 	// Здесь нам не нужно присваивать значение null для m_data или выполнять m_length = 0, так как объект и так будет уничтожен
5 }
6
7 void erase()
8 {
9 	delete[] m_data;
10
11 	//Здесь нам нужно указать m_data значение nullptr, чтобы на выходе не было висячего указателя
12 	m_data = nullptr;
13 	m_length = 0;
14 }

Теперь перегрузим оператор индексации [], чтобы иметь доступ к элементам массива. Мы также должны выполнить
проверку корректности передаваемого индекса, что лучше всего сделать с помощью стейтмент аassert. Также добавим
функцию доступа для возврата длины массива:

1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 #include <cassert> // для assert()
5
6 class ArrayInt
7 {
8 private:
9 	int m_length;
10 	int *m_data;
11
12 public:
13 	ArrayInt():
14 		m_length(0), m_data(nullptr)
15 	{
16 	}
17
18 	ArrayInt(int length):
19 		m_length(length)
20 	{
21 		assert(length >= 0);
22
23 	if(length > 0)
24 		m_data = new int[length];
25 	else
26 		m_data = nullptr;
27 	}
28
29 	~ArrayInt()
30 	{
31 		delete[] m_data;
32 	}
33
34 void erase()
35 {
36 	delete[] m_data;
37 	// Указываем m_data значение nullptr, чтобы на выходе не было висячего указателя
38 	m_data = nullptr;
39 	m_length = 0;
40 }
41
42 	int& operator[](intindex)
43 	{
44 		assert(index >=0 && index <m_length);
45 		return m_data[index];
46 	}
47
48 	int getLength() { return m_length; }
49 };
50
51 #endif

Теперь унас уже есть класс ArrayInt, который мы можем использовать. Мы можем выделить массив определенного размера и
использовать оператор [] для извлечения или изменения значений элементов.
Тем не менее, есть еще несколько вещей, которые мы не можем выполнить с нашим ArrayInt. Это автоматическое изменение
размера массива, добавление/удаление элементов и сортировка элементов.

Во-первых, давайте реализуем возможность массива изменять свой размер. Мы напишем две разные функции для этого.
Первая функция — reallocate(); при изменении размера массива она будет уничтожать все существующие элементы (это быстро).
Вторая функция — resize(); при изменении размера массива будет сохранять все существующие элементы (это медленно).

1 // Функция reallocate() изменяет размер массива. Все существующие элементы внутри массива будут уничтожены. Процесс быстрый
2 void reallocate(intnewLength)
3 {
4 	// Удаляем все существующие элементы внутри массива
5 	erase();
6
7 	// Если наш массив должен быть пустым, то выполняем возврат здесь
8 	if(newLength <= 0)
9 		return;
10
11 	// Дальше нам нужно выделить новые элементы
12 	m_data = new int[newLength];
13 	m_length = newLength;
14 }
15
16 // Функция resize() изменяет размер массива. Все существующие элементы сохраняются. Процесс медленный
17 void resize(int newLength)
18 {
19 	// Если массив уже нужной длины, то выполняем return
20 	if(newLength == m_length)
21 	return;
22
23 	// Если нужно сделать массив пустым, то делаем это и затем выполняем return
24 	if(newLength <= 0)
25 	{
26 		erase();
27 		return;
28 	}
29
30 	// Теперь предположим, что newLength состоит, по крайней мере, из одного элемента. Выполняется следующий алгоритм действий
31 	// 1. Выделяем новый массив.
32 	// 2. Копируем элементы из существующего массива в наштолько что выделенный массив.
33 	// 3. Уничтожаем старый массив и даем команду m_data указывать на новый массив.
34
35 	// Выделяем новый массив
36 	int *data = newint[newLength];
37
38 	// Затем нам нужно разобраться с количеством копируемых элементов в новый массив.
39 	// Нам нужно скопировать столько элементов, сколько их есть в меньшем из массивов
40 	if(m_length > 0)
41 	{
42 		int elementsToCopy = (newLength > m_length) ? m_length : newLength;
43
44 		// Поочередно копируем элементы
45 		for (int index=0; index < elementsToCopy ; ++index)
46 			data[index] = m_data[index];
47 	}
48
49 	// Удаляем старый массив, так как он нам уже не нужен
50 	delete[] m_data;
51
52 	// И используем вместо старого массива новый! Обратите внимание, m_data указывает на тот же адрес, на который указывает наш новый динамически выделенный массив.
53 	// Поскольку данные были динамически выделены то они не будут уничтожены когдавыйдут из области видимости
54 	m_data = data;
55 	m_length = newLength;
56 }

Фух! Было непросто!

Функционал большинства контейнерных классов-массивов на этом заканчивается. Однако, если вы хотите увидеть, как
реализовать возможность добавления/удаления элементов, то мы сейчас это рассмотрим. Следующие два алгоритма очень
похожи на функцию resize():

1 void insertBefore(int value, intindex)
2 {
3 	// Проверка корректности передаваемого индекса
4 	assert(index >=0 && index <= m_length);
5
6 	// Создаем новый массив на один элемент больше старого массива
7 	int *data = newint[m_length+1];
8
9 	//Копируем всеэлементы аж до index
10 	for (int before=0; before < index; ++before)
11 		data[before] = m_data[before];
12
13 	//Вставляем наш новый элемент в наш новый массив
14 	data [index] = value;
15
16 	//Копируем все значения после вставляемого элемента
17 	for (int after=index; after < m_length; ++after)
18 		data[after+1] = m_data[after];
19
20 	//Удаляем старый массив и используем вместо него новый массив
21 	delete[] m_data;
22 	m_data = data;
23 	++m_length;
24 }
25
26 void remove(int index)
27 {
28 	// Проверка на корректность передаваемого индекса
29 	assert(index >=0 && index <m_length);
30
31 	// Если это последний элемент массива, то делаем массив пустым и выполняем return
32 	if(m_length ==1)
33 	{
34 		erase();
35 		return;
36 	}
37
38 	// Cоздаем новый массив на один элемент меньше нашего старого массива
39 	int *data = newint[m_length-1];
40
41 	// Копируем все элементы аж до index
42 	for (int before=0; before <index; ++before)
43 		data[before] = m_data[before];
44
45 	//Копируем все значения после удаляемого элемента
46 	for (int after=index+1; after < m_length;++after )
47 		data[after-1] = m_data[after];
48
49 	//Удаляем старый массив и используем вместо него новый массив
50 	delete[] m_data;
51 	m_data = data;
52 	--m_length;
53 }
54
55 // Несколько дополнительных функций просто для удобства
56 void insertAtBeginning(int value) { insertBefore(value, 0); }
57 void insertAtEnd(int value) { insertBefore(value, m_length); }

Вот наш контейнерный класс-массив ArrayInt целиком.

ArrayInt.h:
1 #ifndef ARRAYINT_H
2 #define ARRAYINT_H
3
4 #include <cassert> // для assert()
5
6 class ArrayInt
7 {
8 private:
9 	int m_length;
10 	int *m_data;
11
12 public:
13 	ArrayInt():
14 		m_length(0), m_data(nullptr)
15 	{
16 	}
17
18 	ArrayInt(int length):
19 	m_length(length)
20 	{
21 		assert(length >= 0);
22 		if (length > 0)
23 			m_data = new int[length];
24 		else
25 			m_data = nullptr;
26 	}
27
28 	~ArrayInt()
29 	{
30 		delete[] m_data;
31 	}
32
33 	void erase()
34 	{
35 		delete[] m_data;
36 		// Здесь нужно указать m_data значение nullptr, чтобы на выходе не было висячего указателя
37 		m_data = nullptr;
38 		m_length = 0;
39 	}
40
41 	int& operator[](int index)
42 	{
43 		assert(index >= 0 && index < m_length);
44 		return m_data[index];
45 	}
46
47 	// Функция reallocate() изменяет размер массива. Все существующие элементы внутри массива будут уничтожены. Процесс быстрый
48 	void reallocate(int newLength)
49 	{
50 		// Удаляем все существующие элементы внутри массива
51 		erase();
52
53 		// Если наш массив должен быть пустым, то выполняем возврат здесь
54 		if (newLength <= 0)
55 			return;
56
57 		// Затем выделяем новые элементы
58 		m_data = new int[newLength];
59 		m_length = newLength;
60 	}
61
62 	// Функция resize() изменяет размер массива. Все существующие элементы сохраняются. Процесс медленный
63 	void resize(int newLength)
64 	{
65 		// Если массив нужной длины, то выполняем return
66 		if (newLength == m_length)
67 		return;
68
69 		// Если нужно сделать массив пустым, то делаем это и затем выполняем return
70 		if (newLength <= 0)
71 		{
72 			erase();
73 			return;
74 		}
75
76 		// Теперь предположим что newLength состоит по крайней мере из одного элемента. Выполняется следующий алгоритм действий:
77 		// 1. Выделяем новый массив.
78 		// 2. Копируем элементы из существующего массива в наш только что выделенный массив.
79 		// 3. Уничтожаем старый массив и даем команду m_data указывать на новый массив.
80
81 		// Выделяем новый массив
82 		int *data = new int[newLength];
83
84 		// Затем нам нужно разобраться с количеством копируемых элементов в новый массив.
85 		// Нам нужно скопировать столько элементов, сколько их есть в меньшем из массивов
86 		if (m_length >0)
87 		{
88 			int elementsToCopy = (newLength > m_length) ? m_length : newLength;
89
90 			// Поочередно копируем элементы
91 			for (int index=0; index< elementsToCopy ; ++index)
92 				data[index] = m_data[index];
93		 }
94
95 		// Удаляем старый массив, так как он нам уже не нужен
96 		delete[] m_data;
97
98 		// И используем вместо старого массива новый! Обратите внимание, m_data указывает на тот же адрес, на который указываевает наш новый динамически выделенный массив.
99 		// Поскольку данные были динамически выделены, то они не будут уничтожены, когда выйдут из области видимости
100 		m_data = data;
101 		m_length = newLength;
102 	}
103
104 	void insertBefore(int value, int index)
105 	{
106 		// Проверка корректности передаваемого индекса
107 		assert(index >= 0 && index <= m_length);
108
109 		// Создаем новый массив на один элемент больше старого массива
110 		int *data = new int[m_length+1];
111
112 		// Копируем все элементы аж до index
113 		for (int before=0; before <index; ++before)
114 			data [before] = m_data[before];
115
116 		// Вставляем наш новый элемент в наш новый массив
117 			data [index] =value;
118
119 		// Копируем все значения после вставляемого элемента
120 		for (int after=index; after< m_length; ++after)
121 			data[after+1] = m_data[after];
122
123 		// Удаляем старый массив и используем вместо него новый массив
124 		delete[] m_data;
125 		m_data = data;
126 		++m_length;
127 	}
128
129 	void remove(int index)
130 	{
131 		// Проверка на корректность передаваемого индекса
132 		assert(index >= 0 && index < m_length);
133
134 		// Если это последний элемент массива, то делаем массив пустым и выполняем return
135 		if (m_length == 1)
136 		{
137 			erase();
138 			return;
139 		}
140
141 		// Cоздаем новый массив на один элемент меньше нашего старого массива
142 		int *data = new int[m_length-1];
143
144 		// Копируем все элементы аж до index
145 		for (int before=0; before < index; ++before)
146 			data[before] = m_data[before];
147
148 		// Копируем все значения после удаляемого элемента
149 		for (int after=index+1; after < m_length; ++after )
150 			data[after-1] = m_data[after];
151
152 		// Удаляем старый массив и используем вместо него новый массив
153 		delete[] m_data;
154 		m_data = data;
155 		--m_length;
156 	}
157
158 	// Несколько дополнительных функций просто для удобства
159 	void insertAtBeginning(int value) { insertBefore(value, 0); }
160 	void insertAtEnd(int value) { insertBefore(value, m_length); }
161
162 	int getLength() { return m_length; }
163 };
164
165 #endif


Теперь протестируем программу:
1 #include <iostream>
2 #include "ArrayInt.h"
3
4 int main()
5 {
6 	// Объявляем массивс 10 элементами
7 	ArrayInt array(10);
8
9 	// Заполняем массив числами от 1 до 10
10 	for (int i=0; i<10;i++)
11 		array[i] = i+1;
12
13 	// Изменяем размер массива до 7 элементов
14 	array.resize(7);
15
16 	// Вставляем число 15 перед элементом с индексом 4
17 	array.insertBefore(15, 4);
18
19 	// Удаляем элемент с индексом 5
20 	array.remove(5);
21
22 	// Добавляем числа 35 и 50 в конец и в начало
23 	array.insertAtEnd(35);
24 	array.insertAtBeginning(50);
25
26 	// Выводим все элементы массива
27 	for (int j=0; j<array.getLength(); j++)
28 		std::cout << array[j] << " ";
29
30 	return 0;
31 }

Результат:
50 1 2 3 4 15 6 7 35

Хотя написание контейнерных классов может быть несколько сложным, но хорошая новость заключается в том, чтовам их
нужно написать только один раз. Как только контейнерный класс работает, вы можете его повторно использовать где-угодно
без каких-либо дополнительных действий/усилий по части программирования.
Также стоит отметить, что, хотя наш контейнерный класс ArrayInt содержит фундаментальный тип данных (int), мы также могли
бы легко использовать и пользовательский тип данных.

Примечание: Если класс из Стандартной библиотеки C++ полностью соответствует вашим потребностям, то используйте
его вместо написания своего контейнерного класса. Например, вместо ArrayInt лучше использовать std::vector<int>, так
как реализация std::vector<int> протестирована/проверена уже многими годами, эффективна и отлично работает с
другими классами из Стандартной библиотеки C++. Но так как не всегда может быть возможным использовать классы из
Стандартной библиотеки C++, то вы уже знаете, как создавать свои собственные контейнерные классы.
