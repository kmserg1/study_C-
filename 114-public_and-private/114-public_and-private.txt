Урок No 114. Спецификаторы доступа public и private


На этом уроке мы рассмотрим,что такое спецификаторы доступа в языке С++, какие они бывают и
как их использовать.                                 

Оглавление:
1. Спецификаторы доступа
2. Использование спецификаторов доступа
3. Структуры vs. Классы
4. Тест


Спецификаторы доступа

Рассмотрим следующую программу:

1 struct DateStruct //члены структуры являются открытыми по умолчанию
2 {
3 int day; // открытопо умолчанию, доступ имеетлюбой объект
4 int month;// открытопо умолчанию, доступ имеетлюбой объект
5 int year; //открыто поумолчанию,доступимеет любойобъект
6 };
7
8 int main()
9 {
10 DateStruct date;
11 date.day =12;
12 date.month=11;
13 date.year = 2018;
14
15 return 0;
16 }

Здесь мы объявляем структуру DateStruct, а затем напрямую обращаемсяк её членам для их
инициализации. Это работает, так как все члены структуры являются открытыми по умолчанию.
Открытые члены (или «public-члены») — это члены структуры или класса, к которым можно
получить доступ извне этой же структуры или класса. В программе, приведенной выше, функция
main() находится вне структуры, но она может напрямую обращаться к членам day, month и
year ,так как они являются открытыми.
С другой стороны, рассмотрим следующий почти идентичный класс:

1 class DateClass //члены класса являются закрытыми по умолчанию
2 {
3 int m_day; // закрыто по умолчанию, доступ имеют только другие членыкласса
4 int m_month; // закрыто по умолчанию, доступимеют только другие члены класса
5 int m_year; //закрыто по умолчанию, доступ имеют только другие члены класса
6 };
7
8 int main()
9 {
10 DateClass date;
11 date.m_day=12; // ошибка
12 date.m_month=11; // ошибка
13 date.m_year = 2018; // ошибка
14
15 return 0;
16 }

Вам бы не удалось скомпилировать эту программу, так как все члены класса являются закрытыми
по умолчанию.

Закрытые члены (или «private-члены») — это члены класса, доступ к которым
имеют только другие члены этого же класса. Поскольку функция main() не является членом
DateClass, то она и не имеет доступа к закрытым членам объекта date.

Хотя члены класса являются закрытыми по умолчанию, мы можем сделать их открытыми, используя 
ключевое слово public:

1 class DateClass
2 {
3 public: // обратите внимание на ключевое слово public и двоеточие
5 int m_month; // открыто, доступ имеет любой объект
4 int m_day; // открыто, доступ имеет любой объект
6 int m_year; // открыто, доступ имеет любой объект
7 };
8
9 int main()
10 {
11 DateClass date;
12 date.m_day=12; // ок,так как m_day имеет спецификатор доступа public
13 date.m_month=11; // ок,так как m_month имеет спецификатор доступа public
14 date.m_year = 2018;// ок, так как m_year имеет спецификатор доступа public
15
16 return 0;
17 }

Поскольку теперь члены класса DateClass являются открытыми, то к ним можно получить доступ
напрямую из функции main().
Ключевое слово public вместе с двоеточием называется спецификатором доступа. Спецификатор
доступа определяет, кто имеет доступ к членам этого спецификатора. Каждый из членов
«приобретает» уровень доступа в соответствии со спецификатором доступа (или, если он не
указан, в соответствии со спецификатором доступа по умолчанию).

В языке C++ есть 3 уровня доступа:
 спецификатор public делает члены открытыми;
 спецификатор private делает члены закрытыми;
 спецификатор protected открывает доступ к членам только для дружественных и дочерних
классов (детально об этом на соответствующем уроке).


Использование спецификаторов доступа

Классы могут использовать (и активно используют) сразу несколько спецификаторов доступа для
установки уровней доступа для каждого из своих членов. Обычно переменные-члены являются
закрытыми, а методы — открытыми. Почему именно так? Об этом мы поговорим на следующем
уроке.

Правило: Устанавливайте спецификатор доступа private переменным - членам класса и
спецификатор доступа public — методам класса (если у вас нет веских оснований делать
иначе).

Рассмотрим пример класса, который использует спецификаторы доступа private и public:

1 #include <iostream>
2
3 classDateClass //члены класса являются закрытыми по умолчанию
4 {
5 	int m_day;// закрытопо умолчанию, доступ имеют только другие члены класса
6 	int m_month;// закрыто по умолчанию, доступ имеют только другие члены класса
7 	int m_year; //закрыто по умолчанию, доступ имеют только другие члены класса
8
9 public:
10 	void setDate(int day, int month, int year) // открыто, доступ имеет любой объект
11 	{
12 		// МетодsetDate() имеетдоступ кзакрытымчленамкласса, так как самявляетсячленомкла
13 		m_day = day;
14 		m_month = month;
15 		m_year=year;
16 	}
17
18 	void print() // открыто, доступ имеет любой объект
19 	{
20 		std::cout <<m_day <<"/" <<m_month << "/" <<m_year;
21 	}
22 };
23
24 int main()
25 {
26  DateClass date;
27  date.setDate(12,11, 2018); // ок,так как setDate() имеет спецификатор доступа public
28  date.print(); //ок, так как print() имеет спецификатор доступа public
29
30 return 0;
31 }

Результат выполнения программы:
12/11/2018

Обратите внимание, хоть мы и не можем получить доступ к переменным-членам объекта date
напрямую из main() (так как они являются private по умолчанию), мы можем получить доступ к
ним через открытые методы setDate() и print()!

Открытые члены классов составляют открытый (или«public») интерфейс. Поскольку доступ к
открытым членам класса может осуществляться извне класса, то открытый интерфейс и
определяет, как программы, использующие класс, будут взаимодействовать с этим же классом.
Некоторые программисты предпочитают сначала перечислить private-члены, а затем уже public-
члены. Они руководствуются следующей логикой: public-члены обычно используют private-члены
(те же переменные-члены в методах класса), поэтому имеет смысл сначала определять private-
члены, а затемуже public-члены. Другие же программисты считают, что сначала нужно указывать
public-члены. Здесь уже иная логика: поскольку private-члены закрыты и получить к ним доступ
напрямую нельзя, то и выносить их на первоеместо тоже не нужно. Работать будет и так, и так.
Какой способ использовать — выбирайте сами, что вам удобнее.
Рассмотрим следующую программу:

1 #include <iostream>
2
3 class DateClass // члены класса являются закрытыми по умолчанию
4 {
5 int m_day; // закрытопо умолчанию, доступ имеют только другие члены класса
6 int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
7 int m_year; //закрыто по умолчанию, доступ имеют только другие члены класса
8
9 public:
10 void setDate(int day, int month, int year)
11 {
12 m_day = day;
13 m_month = month;
14 m_year=year;
15 }
16
17 void print()
18 {
19 std::cout <<m_day <<"/" <<m_month << "/" <<m_year;
20 }
21
22 // Обратите внимание на этот дополнительный метод
23 void copyFrom(const DateClass &b)
25 // Мы имеем прямой доступ к закрытым членам объекта b
24 {
26 	m_day = b.m_day;
27 	m_month = b.m_month;
28 	m_year=b.m_year;
29 }
30 };
31
32 int main()
33 {
34 DateClass date;
35 date.setDate(12,11, 2018); //ок,так как setDate() имеет спецификатордоступа public
36
37 DateClass copy;
38 copy.copyFrom(date); //ок, так как copyFrom() имеет спецификатор доступа public
39 copy.print();
40
41 return 0;
42 }

Один нюанс в языке C++, который часто игнорируют / забывают / неправильно понимают,
заключается в том, что контроль доступа работает на основе класса, а не на основе объекта.
Это означает, что, когда метод имеет доступ к закрытым членам класса, онм ожет обращаться к
закрытым членам любого объекта этого класса.

В примере, приведенном выше, метод copyFrom() является членом класса DateClass, что
открывает ему доступ к private-членам класса DateClass. Это означает, что copyFrom() может не
только напрямую обращаться к закрытым членам неявного объекта с которым работает (копия
объекта), но и имеет прямой доступ к закрытым членам объекта b класса DateClass!
Это полезно, когда нужно скопировать элементы из одного объекта класса в другой объект того
же класса. Детально об этом мы поговорим на следующих уроках.


Структуры vs.Классы

Теперь, когда мы узнали о спецификаторах доступа, мы можем поговорить о фактических
различиях между классом и структурой в языке C++. Класс по умолчанию устанавливает всем
своим членам спецификатор доступа private. Структура же по умолчанию устанавливает
всем своим членам спецификатор доступа public.
Есть еще одно незначительное отличие: структуры наследуют от других конструкций языка
С++ открыто, в то время как классы наследуют закрыто.

Тест

Задание No 1
a) Чтотакое открытый член?
Это член, напрямую доступный из ф-й/объектов, не принадлежащих этому классу. 

Ответ No1.а)

b)Чтотакое закрытыйчлен?
Это член, доступный только для ф-й, находящихся в этом классе. 

Ответ No1.b)

c) Чтотакое спецификатор доступа?
Это одно из ключевых слов private, public, protected + ':', находящиеся внутри определения класса и 
определяющие доступнность нижележащих членов.

Ответ No1.c)

d) Сколько есть спецификаторов доступа в языке C++? Назовите их.
См мой ответ на 1.с)

Ответ No 1.d)


Задание No 2

a) Напишите простой класс с именем Numbers. Этот класс должен иметь:

 три закрытые переменные-члены типа double: m_a, m_b и m_c;

 открытый метод с именем setValues(), который позволит устанавливать значения для m_a,
m_b и m_c;

 открытый метод с именем print(), который будет выводить объект класса Numbers в
следующем формате: <m_a, m_b, m_c>.

Следующий код функции main():
1 int main()
2 {
3 Numbers point;
4 point.setValues(3.0, 4.0, 5.0);
5
6 point.print();
7
8 return 0;
9 }

Должен выдавать следующий результат:
<3,4,5>

#include <iostream>

class Numbers{
	double m_a;
	double m_b;
	double m_c;

public:
	void setValues(double first,double second,double third){
		m_a=first;
		m_b=second;
		m_c=third;
	}
	void print(){
		std::cout << '<' << m_a << ',' << m_b << ',' << m_c << ">\n";
	}
}

int main()
{
Numbers point;
point.setValues(3.0, 4.0, 5.0);
point.print();
return 0;
}




Ответ No 2.а)

b) Добавьте функцию isEqual() в класс Numbers, чтобы следующий кодработал корректно:

1 int main()
2 {
3 	Numbers point1;
4 	point1.setValues(3.0,4.0, 5.0);
5
6 	Numbers point2;
7 	point2.setValues(3.0,4.0, 5.0);
8
9 	if (point1.isEqual(point2))
10 		std::cout <<"point1 and point2 are equal\n";
11 	else
12       	std::cout <<"point1 andpoint2 are not equal\n";
13
14 	Numbers point3;
15 	point3.setValues(7.0,8.0, 9.0);
16
17 	if (point1.isEqual(point3))
18      	std::cout <<"point1 and point3 are equal\n";
19 	else
20 		std::cout <<"point1 andpoint3 arenot equal\n";
21
22 return 0;
23 }


bool isEqual(Numbers arg){
	return (m_a==arg.m_a && m_b==arg.m_b && m_c==arg.m_c);
}

Ответ No 2.b)



Задание No 3

Теперь попробуем что-то посложнее. Напишите класс, который реализует функционал
стека. Класс Stack должен иметь:
 закрытый целочисленный фиксированный массив длиной 10 элементов;
 закрытое целочисленное значение для отслеживания длины стека;
 открытый методсименем reset(), который будет инициализировать значением 0 длину и
все значения элементов;
 открытый метод с именем push(), который будет добавлять значение в стек. Метод push()
должен возвращать значение false, если массив уже заполнен, в противном случае — true ;
 открытый метод с именем pop() для возврата значений из стека. Если в стеке нет значений,
то должен выводиться стейтмент assert;
 открытый метод с именем print(), который будет выводить всезначения стека.

Следующий код функции main():
1 int main()
2 {
3 Stack stack;
4 stack.reset();
5
6 stack.print();
7
8 stack.push(3);
9 stack.push(7);
10 stack.push(5);
11 stack.print();
12
13 stack.pop();
14 stack.print();
15
16 stack.pop();
17 stack.pop();
18
19 stack.print();
20
21 return 0;
22 }

Должен выдавать следующий результат:
( )
( 3 7 5 )
( 3 7 )
( )


ОтветNo3