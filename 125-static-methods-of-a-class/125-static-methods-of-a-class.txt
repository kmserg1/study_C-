Урок No125. Статические методы класса


На предыдущем уроке мы узнали, что статические переменные-члены — это члены, которые принадлежат классу, а не его
объектам.

Оглавление:
1. Статические методы
2. Статические методы не имеют указателя *this
3. Еще один пример
4. Предупреждение о классах со всеми статическими членами
5. C++ не поддерживает статические конструкторы
6. Заключение


Статические методы

Если статические переменные-члены являются открытыми, то мы можем получить к ним доступ напрямую через имя класса и
оператор разрешения области видимости. Но что, если статические переменные-члены являются закрытыми? Рассмотрим
следующий код:

1 class Anything
2 {
3 private:
4 	static int s_value;
5
6 };
7
8 int Anything::s_value = 3; // определение статического члена, несмотря на то, что он является private
9
10 int main()
11 {
12 	// Как получить доступ к Anything::s_value здесь, если s_value является private?
13 }

В этом случае мы не можем напрямую получить доступ к Anything::s_value из функции main(), так как этот член является
private. Обычно, доступ к закрытымч ленам класса осуществляется через public-методы. Хотя мы могли бы создать обычный
метод для получения доступа к s_value, но нам тогда пришлось бы создавать объект этого класса для использования метода!

Есть вариант получше: мы можем сделать метод статическим.
Подобно статическим переменным-членам, статические методы не привязаны к какому-либо одному объекту класса. Вот
вышеприведенный пример, но уже со статическим методом:

1 class Anything
2 {
3 private:
4 	static int s_value;
5 public:
6 	static int getValue() { return s_value; } // статический метод
7 };
8
9 int Anything::s_value = 3; // определение статической переменной-члена класса
10
11 int main()
12 {
13 	std::cout << Anything::getValue() << '\n';
14 }

Поскольку статические методы не привязаны к определенному объекту, то их можно вызывать напрямую через имя классаи
оператор разрешения области видимости, а также через объекты класса (но это не рекомендуется).


Статические методы не имеют указателя *this

У статических методов есть две интересные особенности.

Во-первых, поскольку статические методы не привязаны к объекту, то они не имеют скрытого указателя *this! Здесь есть
смысл, так как указатель *this всегда указывает на объект, с которым работает метод. Статические методы могут не работать
через объект, поэтому и указатель *this не нужен.

Во-вторых, статические методы могут напрямую обращаться к другим статическим членам (переменным или функциям), но не
могут напрямую обращаться к нестатическим членам. Это связано с тем, что нестатические члены принадлежат объекту
класса, а статические методы — нет!

Еще один пример

Статические методы можно определять вне тела класса. Это работает так же, как и с обычными методами. Например:

1 #include <iostream>
2
3 class IDGenerator
4 {
5 private:
6 	static int s_nextID; // объявление статической переменной-члена
7
8 public:
9 	static int getNextID(); // объявление статического метода
10 };
11
12 // Определение статической переменной-члена находится вне тела класса. Обратите внимание, мы не используем здесь ключевое слово static
13 // Начинаем генерировать ID с 1
14 int IDGenerator::s_nextID = 1;
15
16 // Определение статического метода находится вне тела класса. Обратите внимание, мы не используем здесь ключевое слово static 
17 int IDGenerator::getNextID() { return s_nextID++; }
18
19 int main()
20 {
21 for (int count=0; count < 4; ++count)
22 std::cout << "The next ID is: " << IDGenerator::getNextID() << '\n';
23
24 return 0;
25 }

Результат выполнения программы:
The next ID is: 1
The next ID is: 2
The next ID is: 3
The next ID is: 4

Обратите внимание, поскольку все переменные и функции этого класса являются статическими, то нам не нужно создавать
объект этого класса для работы с ним! Статическая переменная-член используется для хранения значения следующего
идентификатора, который должен быть ей присвоен, а статический метод —для возврата идентификатора иегоувеличения.


Предупреждение о классах со всеми статическими членами

Будьте осторожны при написании классов со всеми статическими членами. Хотя такие «чисто статические классы» могут быть
полезны, но они также имеют свои недостатки.

Во-первых, поскольку все статические члены создаются только один раз, то несколько копий «чисто статического класса» быть
не может (без клонирования класса и его дальнейшего переименования). Например, если нам нужны два независимых
объекта класса IDGenerator, то это будет невозможно через «чисто статический» класс.

Во-вторых, из урока о глобальных переменных мы знаем, чтоглобальные переменные опасны, поскольку любая часть кода
может изменить их значения и, в конечном итоге, изменит другие фрагменты, казалось бы, не связанного с этими
переменными кода (детально см.здесь). То же самое справедливо и для «чисто статических» классов. Поскольку все члены
принадлежат классу (а не его объектам), а классы имеют глобальную область видимости, то в «чисто статическом классе» мы
объявляем глобальные функциии переменные со всеми минусами, которые они имеют.


C++ не поддерживает статические конструкторы

Если вы можете инициализировать обычную переменную-член через конструктор, то по логике вещей вы должны иметь
возможность инициализировать статические переменные-члены через статический конструктор. И, хотя некоторые
современные языки программирования действительно поддерживают использование статических конструкторов именно для
этой цели, язык C++, к сожалению, не является одним из таковых.

Если ваша статическая переменная может быть инициализирована напрямую, то конструктор не нужен: вы можете определить
статическую переменную-член, даже если она является private. Мы делали это в вышеприведенном примере с s_nextID. Вот
еще один пример:

1 class Something
2 {
3 public:
4 	static std::vector<char> s_mychars;
5 };
6
7 std::vector<char> Something::s_mychars = { 'o', 'a', 'u', 'i', 'e' }; // определяем статическую переменную-член

Если для инициализации вашей статической переменной-члена требуется выполнить код (например, цикл), то есть несколько
разных способов это сделать. Следующий способ является лучшим из них:

1 #include <iostream>
2 #include <vector>
3
4 class Something
5 {
6 private:
7 	static std::vector<char> s_mychars;
8
9 public:
10 	class _nested // определяем вложенный класс с именем _nested
11 	{
12 	public:
13 		_nested() // конструктор _nested() инициализирует нашу статическую переменную-член
14 		{
15 			s_mychars.push_back('o');
16 			s_mychars.push_back('a');
17 			s_mychars.push_back('u');
18 			s_mychars.push_back('i');
19 			s_mychars.push_back('e');
20 		}
21 	};
22
23 	// Статический метод для вывода s_mychars
24 	static void getSomething() {
25 		for (auto const &element : s_mychars)
26 			std::cout << element << ' ';
27 	}
28 private:
29 	static _nested s_initializer; // используем статический объект класса _nested для гарантии того, что конструктор _nested()
30 };
31
32 std::vector<char> Something::s_mychars; // определяем нашу статическую переменную-член
33 Something::_nested Something::s_initializer; // определяем наш статический s_initializer, который вызовет конструктор _nested()
34
35 int main() {
36 	Something::getSomething();
37 	return 0;
38 }

Результат выполнения программы:
o a u i e

При определении статического члена s_initializer вызовется конструктор по умолчанию _nested() (так как s_initializer
является объектом класса_nested). Мы можем использоватьэтот конструктор для инициализации любых статических
переменных-членов класса Something. Самое крутое здесь — это то, что весь код инициализации скрыт внутри исходного
класса со статическимчленом.

Заключение

Статические методы могут использоваться для работы со статическими переменными-членами класса. Для работы с ними не
требуется создавать объекты класса.
Классы могут быть «чисто статические» (со всеми статическими переменными-членами и статическими методами). Однако,
такие классы, по сути, эквивалентны объявлению функций и переменныхв глобальной области видимости, и этого следует
избегать, если у вас нет на это веских причин.
