Урок No 117. Список инициализации членов класса


На этом уроке мы рассмотрим, как инициализировать переменные-члены класса спомощью
списка инициализации в языке С++, а также особенности и нюансы, которыепри э том могут
возникнуть.

Оглавление:
1. Списки инициализациичленовкласса
2. uniform-инициализация в C++11
3. Инициализация массивов в классе
4. Инициализация переменных-членов, которые являютсяклассами
5. Использованиесписковинициализации
6. Порядоквыполненияв спискеинициализации
7. Заключение
8. Тест


Списки инициализации членов класса

На предыдущем урокемы инициализировали члены нашегокласса в конструкторе через
оператор присваивания:

1 class Values
2 {
3 private:
4 int m_value1;
5 double m_value2;
6 char m_value3;
7
8 public:
9 Values()
10 {
11 // Это всё операции присваивания, а не инициализация
12 m_value1 = 3;
13 m_value2 = 4.5;
14 m_value3 = 'd';
15 }
16 };

Сначала создаются m_value1, m_value2 и m_value3 . Затем выполняется тело конструктора, где
этим переменным присваиваются значения. Аналогичен код в не объектно-ориентированном C++:

1 int m_value1;
2 double m_value2;
3 char m_value3;
4
5 m_value1 = 3;
6 m_value2 = 4.5;
7 m_value3 = 'd';

Хотя в плане синтаксиса языкаC++ вопросов никаких нет — всё корректно, но более эффективно
— использовать инициализацию, а не присваивание после объявления.
Как мы уже знаем из предыдущих уроков, некоторые типы данных (например, константы и
ссылки) должны быть инициализированы сразу. Рассмотрим следующий пример:

1 class Values
2 {
3 private:
4 const int m_value;
5
6 public:
7 Values()
8 {
9 m_value = 3; // ошибка: константам нельзя присваивать значения
10 }
11 };

Аналогичен код в необъектно-ориентированном C++: 

1 const int m_value; // ошибка: константы должны быть инициализированы значениями
2 m_value = 7; // ошибка: константам нельзя присваивать значения

Для решения этой проблемы в C++ добавили метод инициализации переменных-членов класса
через список инициализации членов, вместо присваивания им значений после объявления. 
Не путайте этот список с аналогичным списком инициализаторов, который используется для
инициализации массивов.

Изурока No 28 мы уже знаем, что инициализировать переменные можно тремя способами: через
копирующую инициализацию, прямую инициализацию или uniform-инициализацию.

1 int value1 = 3; // копирующая инициализация
2 double value2(4.5); // прямая инициализация
3 char value3 {'d'} // uniform-инициализация

Использование списка инициализации почти идентично выполнению прямой инициализации
(или uniform-инициализации в C++11).

Чтобы было понятнее, рассмотрим пример. Вот код с присваиванием значений переменным-
членам класса в конструкторе:

1 class Values
2 {
3 private:
4 int m_value1;
5 double m_value2;
6 char m_value3;
7
8 public:
9 Values()
10 {
11 // Это всё операции присваивания, а не инициализация
12 m_value1 = 3;
13 m_value2 = 4.5;
14 m_value3 = 'd';
15 }
16 };

Теперь давайте перепишем этот код, но уже с использованием списка инициализации:

1 #include <iostream>
2
3 class Values
4 {
5 private:
6 	int m_value1;
7 	double m_value2;
8 	char m_value3;
9
10 public:
11 	Values() : m_value1(3), m_value2(4.5), m_value3('d') // напрямую инициализируем переменные-чл
12 	{
13 		// Нет необходимости использовать присваивание
14 	}
15
16 	void print()
17 	{
18 		std::cout << "Values(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
19 	}
20 };
21
22 int main()
23 {
24 Values value;
25 value.print();
26 return 0;
27 }

Результат выполнения программы:

Values(3, 4.5, d)

Список инициализации членов находится сразу же после параметров конструктора. Он
начинается с двоеточия ( : ), а затем значение для каждой переменной указывается в круглых
скобках. Больше не нужно выполнять операции присваивания в теле конструктора. Также
обратите внимание, что список инициализации членов не заканчивается точкой с запятой.
Можно также добавить возможность caller-у передавать значения для инициализации:

1 #include <iostream>
2
3 class Values
4 {
5 private:
6 	int m_value1;
7 	double m_value2;
8 	char m_value3;
9
10 public:
11 	Values(int value1, double value2, char value3='d')
12 		: m_value1(value1), m_value2(value2),m_value3(value3) // напрямую инициализируем перемен
13 	{
14 		// Нет необходимости использовать присваивание
15 	}
16
17 	void print()
18 	{
19 		std::cout << "Values(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
20 	}
21
22 };
23
24 int main()
25 {
26 	Values value(3, 4.5); // value1 = 3, value2 = 4.5, value3 = 'd' (значение по умолчанию)
27 	value.print();
28 	return 0;
29 }

Результат выполнения программы:
Values(3, 4.5, d)

Мы можем использовать параметры по умолчанию для предоставления значений по
умолчанию, если пользователь их не предоставил. Например, класс, который имеет константную
переменную-член:

1 class Values
2 {
3 private:
4 const int m_value;
5
6 public:
7 Values(): m_value(7) // напрямую инициализируем константную переменную-член
8 {
9 }
10 };

Это работает, поскольку нам разрешено инициализировать константные переменные (но не
присваивать им значения после объявления!).
Правило: Используйте списки инициализации членов, вместо операций присваивания,
для инициализации переменных-членов вашего класса.


uniform-инициализация в C++11

В C++11 вместо прямой инициализации можно использовать uniform-инициализацию:

1 class Values
2 {
3 private:
4 const int m_value;
5
6 public:
7 Values(): m_value { 7 } // используем uniform-инициализацию
8 {
9 }
10 };

Настоятельно рекомендуется использовать этот синтаксис (даже если вы не используете
константы или ссылки в качестве переменных-членов вашего класса), поскольку списки
инициализации членов необходимы при композиции и наследовании (это рассмотрим несколько
позже).

Правило: Используйте uniform-инициализацию вместо прямой инициализации в C++11.


Инициализация массивов в классе

Рассмотрим класс с массивом в качестве переменной-члена:

1 class Values
2 {
3 private:
4 	const int m_array[7];
5
6 };

До C++11 мы могли только обнулить массив через список инициализации:

1 class Values
2 {
3 private:
4 const int m_array[7];
5
6 public:
7 Values(): m_array {} // обнуляем массив
8 	{
9 		// Если мы хотим, чтобы массив имел значения, то мы должны здесь использовать присваивание
10 	}
11
12 };

Однако в C++11 вы можете полностью инициализировать массив, используя uniform-инициализацию:

1 class Values
2 {
3 private:
4 const int m_array[7];
5
6 public:
7 Values(): m_array { 3, 4, 5, 6, 7, 8, 9 } // используем uniform-инициализацию для инициализации
8 	{
9 	}
10
11 };


Инициализация переменных-членов, которые являются классами

Список инициализации членов также может использоваться для инициализации членов, которые
являются классами:

1 #include <iostream>
2
3 class A
4 {
5 public:
6	 A(int a) { std::cout << "A " << a << "\n"; }
7 };
8
9 class B
10 {
11 private:
12 	A m_a;
13 public:
14 	B(int b)
15 		: m_a(b-1) // вызывается конструктор A(int) для инициализации члена m_a
16 	{
17 		std::cout << "B " << b << "\n";
18 	}
19 };
20
21 int main()
22 {
23 	B b(7);
24 	return 0;
25 }

Результат выполнения программы:
A 6
B 7

При создании переменной b вызывается конструктор B(int) со значением 7.
До того, как тело конструктора выполнится, инициализируется m_a, вызывая конструктор A(int) со значением 6. 
Таким образом, выведется A 6. 
Затем управление возвратится обратно к конструктору B(), и тогда уже он выполнится и выведется B 7.


Использование списков инициализации

Если список инициализации помещается на той же строке, что и имя конструктора, то лучше всё
разместить в одной строке:

1 class Values
2 {
3 private:
4 int m_value1;
5 double m_value2;
6 char m_value3;
7
8 public:
9 	Values() : m_value1(3), m_value2(4.5), m_value3('d') // всё находится в одной строке
10 	{
11 	}
12 };

Если список инициализации членов не помещается в строке с именем конструктора, то на
следующей строке (используя перенос), инициализаторы должны быть с отступом:

1 class Values
2 {
3 private:
4 	int m_value1;
5 	double m_value2;
6 	char m_value3;
7
8 public:
9 	Values(int value1, double value2, char value3='d') // на этой строке уже и так много чего,
10 		: m_value1(value1), m_value2(value2),m_value3(value3) // / поэтому переносим инициализаторы на новую строку (не забываем использовать отступ)
11 	{
12 	}
13
14 };

Если все инициализаторы не помещаются на одной строке,то вы можете выделить для каждого
инициализатора отдельную строку:

1 class Values
2 {
3 private:
4 	int m_value1;
5 	double m_value2;
6 	char m_value3;
7 	float m_value4;
8
9 public:
10 	Values(int value1, double value2, char value3='d', float value4=17.5) // на этой строке уже и так много чего,
11 		: m_value1(value1), // поэтому выделяем каждому инициализатору отдельную строку, не забывая о запятой в конце
12 		m_value2(value2),
13 		m_value3(value3),
14 		m_value4(value4)
15 	{
16 	}
17
18 };


Порядок выполнения в списке инициализации

Удивительно, но переменные в списке инициализации не инициализируются в том порядке, в
котором они указаны. Вместо этого они инициализируются в том порядке, в котором объявлены в
классе, поэтому следует соблюдать следующие рекомендации:

 Не инициализируйте переменные-члены таким образом, чтобы они зависели от других
переменных-членов, которые инициализируются первыми (другими словами, убедитесь,что
все ваши переменные-члены правильно инициализируются, даже если порядок в списке
инициализации отличается).
 Инициализируйте переменные в списке инициализации в том порядке, в котором они
объявлены вклассе.


Заключение

Списки инициализации членов позволяют инициализировать члены, а не присваивать им
значения. Это единственный способ инициализации констант и ссылок, которые являются
переменными-членами вашего класса. Во многих случаях использование списка инициализации
может быть более результативным, чем присваивание значений переменным-членам в теле
конструктора. Списки инициализации работают как с переменными фундаментальных типов
данных, так и с членами, которые сами являются классами.

Тест

Напишите класс с именем RGBA, который содержит 4 переменные-члены типа std::uint8_t
(подключите заголовочный файл cstdint для доступа к типу std::uint8_t):
 m_red;
 m_green ;
 m_blue;
 m_alpha .

Присвойте 0 в качестве значения по умолчанию для m_red, m_green и m_blue, и 255 для m_alpha. 

Создайте конструктор со списком инициализации членов, который позволит
пользователю передавать значения для m_red , m_green , m_blue и m_alpha . 

Напишите функцию print(), которая будет выводить значения переменных-членов.

Подсказка: Еслифункция print() работает некорректно, то убедитесь, что вы
конвертировали std::uint8_t в int.

Следующий код функции main():

1 int main()
2 {
3 	RGBA color(0, 135, 135);
4 	color.print();
5
6 	return 0;
7 }

Должен выдавать следующий результат:
r=0 g=135 b=135 a=255

#include <iostream>
#include <cstdint>

class RGBA{

private:
	std::uint8_t m_red, m_green, m_blue, m_alpha;

public:

	RGBA(std::uint8_t r=0,std::uint8_t g=0, std::uint8_t b=0, std::uint8_t a=255)
		:m_red{r},m_green{g},m_blue{b},m_alpha{a}
	{
	}

	print(){
		std::cout << "r=" << m_red << " g=" << m_green << " b=" << m_blue << " a=" << m_alpha << '\n' 
	};
};





Ответ