Урок No19. Прототип функции и Предварительное объявление

На этом уроке мы рассмотрим прототип функции и предварительное объявлениевязыке С++.

Оглавление:
1. Наличие проблемы
2. Прототипыфункцийи Предварительное объявление
3. Предварительно объявили, но не определили
4. Объявление vs. Определение
5. Тест
6. Ответы

Наличие проблемы
Посмотрите на этот,казалось бы,невинный кусочек кода под названием add.cpp:

1 #include <iostream>
2
3 int main()
4 {
5 std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
6 return 0;
7 }
8
9 int add(int x, int y)
10 {
11 return x + y;
12 }

Вы, наверное, ожидаете увидеть примерно следующий результат:
The sum of 3 and 4 is: 7
Но в действительности эта программа даже не скомпилируется. Причиной этому является то, что компилятор читает код
последовательно. Когда он встречает вызов функции add() в строке No 5 функции main(), он даже не знает, что такое add(), так
как это еще не определили! В результате чего мы получим следующую ошибку:
add: идентификатор не найден
Чтобы устранить эту проблему, мы должны учитывать тот факт, что компилятор не знает, что такое add(). Есть 2 решения.

Решение No1: Поместить определение функцииadd() выше её вызова (т.е.перед функциейmain()):

1 #include <iostream>
2
3 int add(int x, int y)
4 {
5 return x + y;
6 }
7
8 int main()
9 {
10 std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
11 return 0;
12 }

Таким образом, при вызове функции add() в функции main(), компилятор будет знать, что это такое. Так как это простая
программа, то внести подобные изменения несложно. Однако в программах, содержащих большое количество строк кода, это
может быть утомительно — узнавать кто кого вызываети в каком порядке (чтобы соблюсти правильную последовательность).
Кроме того,этот вариант не всегда возможен. Например, мы пишем программу, которая имеет две функции: А() и В(). Если
функция А() вызывает функцию В(), а функция В() вызывает функцию А(), то нет никакого способа упорядочить эти
функции таким образом, чтобы они обе одновременно знали о существовании друг друга. Если вы объявите сначала А(), то
компилятор будет жаловаться, что не знает, что такое В() . Если вы объявите сначала В() , то компилятор будет жаловаться,
что не знает, что такое А().

Прототипы функций и Предварительное объявление

Решение No2: Использовать предварительное объявление.

Предварительное объявление сообщает компилятору о существовании идентификатора ДО его фактического определения.
В случае функций, мы можем сообщить компилятору о существовании функции до её фактического определения. Для этого
нам следует использовать прототип этой функции. Прототип функции (полноценный) состоит из типа возврата функции, её
имени и параметров (тип + имя параметра). В кратком прототипе отсутствуют имена параметров функции. Основная часть
(между фигурными скобками) опускается. А поскольку прототип функции является стейтментом, то он также заканчивается
точкой с запятой.
Вот прототип функции add():
1 int add(int x, int y); // прототип функции состоит из типа возврата функции, её имени, параметров и точки с запятой

А вот вышеприведенная программа, но уже с прототипом функции в качестве предварительного объявления аdd():

1 #include <iostream>
2
3 int add(int x, int y); // предварительное объявление функции add() (используется её прототип)
4
5 int main()
6 {
7 std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl; // это работает, так как мы предварительно (выше функции
8 return 0;
9 }
10
11 int add(int x, int y) // хотя определение функции add() находится ниже её вызова
12 {
13 return x + y;
14 }

Теперь, когда компилятор встречает вызов функции add() в main(), он знает, что это такое и где это искать.
Стоит отметить, что в прототипах функций можно и не указывать имена параметров. Например, прототип выше мы можем
записать следующим образом:
1 int add(int, int);

Тем не менее, предпочтительнее указывать имена параметров, чтобы непутаться лишний раз.

Лайфхак: Прототипы функций можно легко создавать с помощью копирования/вставки из фактического определения
функции. Просто не забывайте указывать точку с запятой в конце.

Предварительно объявили, но не определили

Вопрос: «А что произойдет, если мы предварительно объявим функцию, но не запишем её определение?». Однозначного
ответа нет. Если предварительное объявление записано, но функция никогда не вызывается, то программа может запуститься
без ошибок. Однако, если предварительное объявление записано, функция вызывается, но её определения нет, то вы
получите ошибку на этапе линкинга: программа просто не сможет обработать вызов этой функции.
Рассмотрим следующую программу:

1 #include <iostream>
2
3 int add(int x, int y); // предварительное объявление функции add() (используется её прототип)
4
5 int main()
6 {
7 std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
8 return 0;
9 }

В этой программе мы предварительно объявили функцию add(), вызвали её в main(), но не записали её определения. При
попытке компиляции этой программы мы получим ошибку от линкера.

Объявление vs. Определение

В языке C++ вы часто будете слышать слова «объявление»и «определение». Что это такое?
Определение фактически реализует (вызывает выделение памяти) идентификатор. Вот примеры определений:

1 int add(int x, int y) // определяем функцию add()
2 {
3 int z = x + y; // определяем переменную z
4
5 return z;
6 }

Определение необходимо для корректной работы линкера. Если вы используете идентификатор без его определения, то
линкер выдаст вам ошибку.
В языке C++ есть правило одного определения, которое состоит из трех частей:
 Внутри файла функция, объект, тип или шаблон могут иметь только одно определение.
 Внутри программы объект или обычная функция могутиметь только одно определение.
 Внутри программы типы, шаблоны функций и встроенные функции могут иметь несколько определений, если они
идентичны.
Нарушение первой части правила приведеткошибке компиляции. Нарушение второй или третьей части правила приведет к
ошибке линкинга.

Объявление — это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе. Вот примеры
объявлений:

1 int add(int x, int y); // сообщаем компилятору о функции add(), которая имеет два параметра типа int и возвращает целочисленное значение
2 int x; // объявляем целочисленную переменную х

Объявление — это всё, что необходимо для корректной работы компилятора, но недостаточно для корректной работы
линкера. Определение — это то, что обеспечит корректную работу как компилятора, так и линкера.

Тест
Задание No1: В чём разница между прототипом функции и предварительным объявлением?
Прототип это строчка, которая определяет тип, название и типы (и, возможно, имена) параметров функции и заканчивается точкой с запятой.
Предварительное объявление сообщает компилятору о существовании идентификатора до его фактического определения.
Для функций прототип является предварительным объявлением.

Задание No2: Запишите прототип следующей функции:
1 int doMath(int first, int second, int third, int fourth)
2 {
3 return first + second * third / fourth;
4 }

вар.1: int doMath(int first, int second, int third, int fourth);
вар.2: int doMath(int, int, int, int);

Задание No 3: Выясните, какие из следующих программ не пройдут этап компиляции, какие не пройдут этап линкинга,а какие
не пройдут и то, и другое?

Программа No 1: 

1 #include <iostream>
2
3 int add(int x, int y);
4
5 int main()
6 {
7 std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
8 return 0;
9 }
10 
11 int add(int x, int y)
12 {
13  return x + y;
14 }

Сломается при компиляции, т.к. к-во параметров у add() отличается при объявлении и при вызове


Программа No 2:

1 #include <iostream>
2
3 int add(int x, int y);
4
5 int main()
6 {
7 std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
8 return 0;
9 }
10
11 int add(int x, int y, int z)
12 {
13
 return x + y + z;
14 }

Сломается при компиляции, т.к. к-во параметров у add() отличается при объявлении и при вызове


Программа No 3:

1 #include <iostream>
2
3 int add(int x, int y);
4
5 int main()
6 {
7 std::cout << "3 + 4 + 5 = " << add(3, 4) << std::endl;
8 return 0;
9 }
10
11 int add(int x, int y, int z)
12 {
13 return x + y + z;
14 }

Сломается при линкинге, т.к. к-во параметров у add() отличается при объявлении и при вызове

Программа No 4:
1 #include <iostream>
2
3 int add(int x, int y, int z);
4
5 int main()
6 {
7 std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
8 return 0;
9 }
10
11 int add(int x, int y, int z)
12 {
13
 return x + y + z;
14 }

Все правильно. Будет работать.

