Урок No 25. Разработка ваших первых программ

При написании программ, у вас, как правило, есть какая-то проблема, которую нужно решить.
Новички очень часто спотыкаются на этапе преобразования идеи решения проблемы в реальный код. Но самое главное, что вам нужно запомнить
— разработка программы выполняется перед этапом написания её кода.

Во многих отношениях, программирование — это как архитектура. Что произойдет, если вы попытаетесь построить дом без
соблюдения архитектурного плана? Дом может вы и сумеете построить, но какой он будет: кривые стены, протекающая крыша
и т.д. Аналогично, если вы начнете программировать что-нибудь серьезное перед тем, как составите план, то очень скоро
обнаружите, что ваш код имеет очень много проблем, на решения которых вы потратите гораздо больше времени/усилий/
нервов, нежели на изначальное составление хорошего плана.

Оглавление:
Шаг No 1: Определите проблему
Шаг No 2: Определите свой инструментарий, цели и план бэкапа
Шаг No 3: Разбейте проблему на части
Шаг No 4: Определите последовательность событий
Шаг No 5: Определите данные ввода и данные вывода на каждом этапе
Шаг No 6: Позаботьтесь о деталях
Шаг No 7: Соедините данные ввода с данными вывода в программе

Шаг No 1: Определите проблему
Первое,что вам нужно сделать — это определить проблему, которую решит ваша программа. В идеале, вы должны
сформулировать это одним или двумя предложениями. Например:

Я хочу написать программу - справочник для удобного хранения и редактирования всех телефонных номеров и звонков.

Или

Я хочу написать программу для генерации случайных чисел, с помощью которой можно будет определять победителей
разных конкурсов.

Или

Я хочунаписать программу, которая будет отслеживать и анализировать акции на фондовом рынке для генерации
выигрышных прогнозов.


Хотя этот шаг кажется очевидным, но он также очень важен. Самое худшее, что выможете сделать — этонаписать программу
которая делает не то, что вам нужно!


Шаг No 2: Определите свой инструментарий, цели и план бэкапа
Для опытныхп рограммистов на этом этапе будет еще немало дополнительных пунктов:

 Какая ваша целевая аудитория и какие у нее потребности?
 На какой архитектуре / ОС ваша программа будет работать?
 Какой инструментарий вы будете использовать?
 Будете ли вы разрабатывать программу в одиночку или в составе команды?
 Анализтребований.
 Определение стратегий тестирования / обратной связи / релиза
 Создание плана бэкапа вслучае неожиданных проблем.

Новички, как правило, большим количеством вопросов не задаются: «Пишу программу для собственного использования, в
одиночку, на своей операционной системе, с помощью своей IDE, пользоваться этой программой будутолько я». Всё просто.

Если же вы будете работать над чем-нибудь посерьезнее, то стоит еще задуматься о плане бэкапа вашей программы / проекта.
Это не просто скопировать код в другую папку ноутбука (хотя это уже лучше, чем ничего). Если ваша ОС «сломается», то вы
потеряете все данные. Хорошая стратегия резервного копирования включает в себя создание копии вашего кода вне вашей
операционной системы, например:

 Отправить самому себе E-mail с кодом (прикрепить как файл).
 Скопировать в Dropbox или в любое другое облако.
 Перенести на внешнее запоминающее устройство (например, на портативный жёсткий диск).
 Скопировать на другой компьютер в локальной сети.
 Воспользоваться системами контроля версий (например, GitHub, GitLab или Bitbucket).


Шаг No 3: Разбейте проблему на части
В реальной жизни нам часто приходится выполнять очень сложные задачи. Понять, как их решить, также бывает очень
трудно. В таких случаях можно использовать метод деления на части (или метод «от большого к малому»).
То есть, вместо того, чтобы решать одну большую сложную задачу, мы разбиваем её на несколько подзадач, каждую из которых проще
решить. Если эти подзадачи все еще слишком сложные, то их также нужно еще разразбить. И так до тех пор, пока мы не
доберемся до точки, где каждая отдельно взятая задача — легкорешаема.
Рассмотрим это на примере. Допустим, что нам нужно написать доклад о картошке. Наша иерархия задач в настоящее время
выглядит следующим образом:
 Написать доклад о картошке

Это довольно большая задача, давайте разделим её на подзадачи:

  Написатьдоклад о картошке
 Поиск информации о картошке
 Создание плана
 Заполнение каждого пункта плана подробной информацией
 Заключение

Это уже проще, так как теперь мы имеем список подзадач, на которых можем сосредоточиться в индивидуальном порядке. Тем
не менее,в данном случае, «Поиск информации о картошке» звучит немного расплывчато, нужно дополнительно разбить и
этот пункт:

 Написатьдоклад о картошке
  Поискинформациио картошке
	 Сходить в библиотеку за книжками о картошке
	 Поискать информацию в Интернете
	 Делать заметки в соответствующих разделах из справочного материала
 Создание плана
	 Информация о выращивании
	 Информация об обработке
	 Информация об удобрениях
 Заполнение каждого пункта плана подробной информацией
 Заключение

Выполняя каждый подпункт этого задания, мы решим одну большую задачу.

Есть еще один метод создания иерархии — метод «от малого к большому». Рассмотрим на примере.
Большинство из нас вынуждены ходить на работу (школу/университет) по будням. Предположим, что нам нужно решить
проблему «от постели к работе». Еслибы вас спросили, что вы делаете перед тем, как добраться на работу, вы бы ответили
примерно следующее:
 Выбрать одежду
 Одеться
 Позавтракать
 Ехать на работу
 Почистить зубы
 Встать с постели
 Приготовить завтрак
 Принять душ

Используя метод «отмалого к большому», мы можем сгруппировать задания и создать иерархию
Отпостелик работе
 Спальня
	 Встатьспостели
	 Выбратьодежду
	 Одеться
 Ванная
 Принятьдуш
 Почистить зубы
 Завтрак
	 Сделать завтрак
	 Позавтракать
 Транспорт
	 Ехатьнаработу

   Использование подобных иерархий чрезвычайно полезно в программировании для определения структуры всей программы
Задача верхнего уровня (например, «Написать доклад о картошке» или «От постели к работе») становится функцией main() 
(та как это основная проблема, которую нужно решить). Подзадачи становятся функциями в программе.


Шаг No 4: Определите последовательность событий

Теперь, когда ваша программа имеетструктуру, пришло время ответить на вопрос: «А как же связать все этипункты вместе?»
Первый шаг заключается в определении последовательности событий. Например, когдавы просыпаетесь утром, в какой
последовательности вы выполняете вышеперечисленные дела? Скореевсего, в следующей:
 Встать с постели
 Выбрать одежду
 Принятьдуш
 Одеться
 Приготовить завтрак
 Позавтракать
 Почистить зубы
 Ехать наработу

Если бы мы создавали калькулятор, то последовательность заданий выглядела бы следующим образом:
 Получить первое значение от пользователя
 Получить математическую операцию от пользователя
 Получить второе значение от пользователя
 Вычислить результат
 Вывести результат

Этот список определяет содержимое функции main():
1 int main()
2 {
3 getOutOfBed();
4 pickOutClothes();
5 takeAShower();
6 getDressed();
7 prepareBreakfast();
8 eatBreakfast();
9 brushTeeth();
10 driveToWork();
11 }

Или, в случае с калькулятором:
1 int main()
2 {
3 //Получитьпервое значениеотпользователя
4 getUserInput();
5
6 //Получить математическую операцию отпользователя
7 getMathematicalOperation();
8
9 //Получитьвторое значениеотпользователя
10 getUserInput();
11
12 //Вычислить результат
13 calculateResult();
14
15 //Вывестирезультат
16 printResult();
17 }


Шаг No 5: Определите данные ввода и данные вывода на каждом этапе

После определения иерархии задач и последовательности событий, нам нужно определить, какими будут данные ввода и
данные вывода на каждом этапе.
Например, первая функция из вышеприведенного примера — getUserInput(), довольно проста. Мы собираемся получить число
от пользователя и вернуть его обратно в caller. Таким образом, прототип функции будет выглядеть следующим образом:
1 int getUserInput();

В примере с калькулятором, функции calculateResult() требуется 3 ввода данных: два числа и 1 математический оператор. При
вызове calculateResult() у нас уже должны быть 3 фрагмента данных, которые мы будем использовать в качестве параметров функции.
Функция calculateResult() вычисляет значение результата, но не выводит его. Следовательно,нам необходимо
вернуть этот результат в качестве возвращаемого значения обратно в caller, чтобы другие функции также имели возможность
его использовать.
Учитывая это, прототип функции становится следующим:
1 int calculateResult(int input1, int op, int input2);


Шаг No 6: Позаботьтесь одеталях

На этом этапе нам нужно реализовать каждый подпункт из нашей иерархии задач. Если вы разбили задание на достаточно
мелкие кусочки, то выполнить каждый из этих кусочков будет несложно.Например:

1 int getMathematicalOperation()
2 {
4
3 std::cout << "Please enter which operator you want ( 1=+, 2 = -, 3=*, 4=/ ):";
5 int op;
6 std::cin>>op;
7
8 // А что, если пользователь введет некорректный символ?
9 // Пока чтомы это проигнорируем
10
11 return op;
12 }


Шаг No 7: Соедините данные ввода с данными вывода в программе

И, наконец, последний шаг — это соединение данных ввода с данными вывода. Например, вы можете отправить выходные
данные функции calculateResult() во входные данные функции printResult(), чтобы вторая функция могла вывести результат.

Чаще всего в таких случаях используются промежуточные переменные для временного хранения результата и его
перемещения между функциями. Например:

1 // Переменная result - это промежуточная переменная, которая используется для передачи выходного значения функции calculateResult
2 int result = calculateResult(input1, op, input2);
3 printResult(result);

Согласитесь, что вариант, приведенный выше, читабельнее варианта без использования временных переменных (см. ниже):

1 printResult(calculateResult(input1,op,input2));

Рассмотрим готовую версию программы - калькулятора, еёструктуру и перемещение данных

1 #include<iostream>
2
3 int getUserInput()
4 {
6 int value;
5 std::cout << "Please enter an integer:";
7 std::cin >> value;
8 return value;
9 }
10
11 int getMathematicalOperation()
12 {
13 std::cout << "Please enter which operator you want ( 1=+, 2 = -, 3=*, 4=/ ):";
14
15 int op;
16 std::cin>>op;
18  // А что, если пользователь введет некорректный символ?
17
19 // Пока что мы это проигнорируем
20
21 return op;
22 }
23
24 int calculateResult(int x, int op,int y)
25 {
26 / /Обратите внимание, оператор == используется для сравнения двух значений
28 if(op == 1) //если пользователь выбрал операцию сложения (No 1)
27
29 return x + y; // то выполняем эту строку
30 if(op == 2) // если пользователь выбрал операцию вычитания (No 2)
31 	return x - y; // то выполняем эту строку
32 if(op == 3) //если пользователь выбрал операцию умножения (No 3)
33 	return x * y; // то выполняем эту строку
34 if(op == 4) //если пользователь выбрал операцию деления (No 4)
35 	return x / y; // то выполняем эту строку
36
37 return -1; //вариант, если пользователь ввел некорректный символ
38 }
39
40 voidprintResult(int result)
41 {
42 std::cout << "Your result is:" << result << std::endl;
43 }
44
45 int main()
46 {
47 // Получаем первое значение от пользователя
48 int input1= getUserInput();
49
50 // Получаем математическую операцию от пользователя
51 int op=getMathematicalOperation();
52
53 // Получаем второе значение от пользователя
54 int input2= getUserInput();
55
56 // Вычисляем результат и сохраняем его во временной переменной
57 int result= calculateResult(input1,op,input2 );
58
59 // Выводим результат
60 printResult(result);
61
62 return 0;
63 }

Здесь есть несколько концепций, которые мы еще не рассматривали: условное ветвление if и использование оператора
равенства == для сравнения двух элементов. Не беспокойтесь, если вы это не понимаете — мы всё это детально рассмотрим
на следующих уроках.


Советы

Пускай ваши первые программы будут простыми. Очень часто новички ставят слишком высокие планки для своих первых
более-менее серьезных программ. Например, «Я хочу написать игру с графикой, звуком, монстрами, подземельями и городом
в котором можно будет продавать найденные вещи». Если вы попытаетесь написать что-нибудь подобное в начале вашего
пути как программиста, то очень скоро у вас пропадет любое желание программировать.
Вместо этого, пускай ваши первые цели / задания / программы будут попроще ,например, «Я хочу написать программу,
которая отображала бы 2D-поле наэкране. 

Добавляйте новый функционал со временем. Как только вы написали простенькую программу, которая работает (и даже без сбоев),
то следующим вашим шагом должно стать добавление нового функционала. Например, когда вы сможете отображать
2D-поле на экране — добавьте персонажа, который сможет ходить по этомуполю. После того, как вы уже сможете ходить —
добавьте стены, которые будут препятствовать вашему движению. После того, как у вас будут стены — постройте из них город.
После того, как у вас будет город — добавьте персонажей-продавцов. При таком подходе на вас не наваливается всё сразу и вы
знаете с чего начинать, что делать дальше, в какойпоследовательности и т.д.

Фокусируйтесь только на одном задании в определенный промежуток времени. Не пытайтесь сделать всё и сразу, не
распыляйтесь на несколько задач одновременно. Сосредоточьтесь на одном. Лучше иметь одно выполненное задание и пять
невыполненных, нежели шесть частично выполненных заданий. Есливы рассеиваете свое внимание в нескольких
направлениях, то и ошибок будет много.

Тестируйте каждую новуючасть кода. Начинающие программисты часто пишут программу за один присест. Затем, при
компиляции проекта, получают сотни ошибок. Поэтому, после написания определенной части кода — сразу компилируйте и
тестируйте её. Если ваш код не будетработать, то выбудете знать, где находится проблема, и исправить её будет намного
легче. Как только вы убедились, что ваш код рабочий — переходите к написанию следующей части, а затем repeat.
Тестирование может занять больше времени, но в конечном итоге ваш код будет работать так, как вам нужно.
Большинство новичков пропустят некоторые из этих шагов и советов, так как это не столь захватывающе, как, собственно, сам
процесс кодинга. Хорошая новость заключается в том, что как только вы освоите все эти концепции — они станут для вас
естественными в процессе разработки ваших программных продуктов.
