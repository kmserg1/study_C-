ГлаваNo9.Итоговый тест

В этой главе мы рассмотрели перегрузку операторов, перегрузку операций преобразования типов данных, а также
несколько тем, связанных с конструктором копирования. Пора закрепить полученные знания.

Оглавление:
1. Теория
2. Задание No 1
3. Задание No 2
4. Задание No 3
5. Задание No 4


Теория

Перегрузка оператора — это специфическая перегрузка функции, которая позволяет использовать операторы с
объектами пользовательских классов. При перегрузке операторов их функционал и назначение следует сохранять
максимально приближенно к их первоначальному применению. Если суть применяемого оператора с объектами
пользовательских классов интуитивно не понятна, то лучше использовать функцию с именем, вместо перегрузки
оператора.

Операторы могут быть перегружены через обычные функции, через дружественные функции и через методы
класса. Следующие правила помогут сориентироваться, какой способ перегрузки и когда следует использовать:

 Перегрузку операторов присваивания(=), индекса([]), вызова функции ( () ) или выбора члена (->) выполняйте
через методы класса.
 Перегрузку унарных операторов выполняйте через методы класса.
 Перегрузку бинарных операторов, которые изменяют свой левый операнд ( например, оператор += ) выполняйте
через методы класса.
 Перегрузку бинарных операторов, которые не изменяют свой левый операнд (например, оператор +) выполняйте
через обычные или дружественные функции.

Перегрузка операций преобразования типов данных используется для явного или неявного преобразования объектов
пользовательского класса в другой тип данных.

Конструктор копирования — это особый тип конструктора, используемый для инициализации объекта другим объектом
того же класса. 
Конструкторы копирования используются в: 
	- прямой/uniform- инициализации объектов объектами того же типа, 
	- копирующей инициализации ( Fraction f=Fraction(7,4) ) и 
	- при передаче или возврате параметров по значению.

Если вы не предоставите свой конструктор копирования, то компилятор автоматически его предоставит. Конструкторы
копирования по умолчанию (предоставляемые компилятором) используют почленную инициализацию. Это означает, что
каждый член объекта копии инициализируется соответствующим членом исходного объекта. Конструктор копирования
может быть проигнорирован компилятором в целях оптимизации, даже если он имеет побочные эффекты, поэтому сильно
не полагайтесь на свой конструктор копирования.

Конструкторы считаются конструкторами преобразования по умолчанию. Это означает, что компилятор будет
использовать их для неявной конвертации объектов других типов данных в объекты вашего класса. Вы можете избежать
этого, используя ключевое слово explicit. Вы также можете удалить функции внутри своего класса, включая конструктор
копирования и перегруженный оператор присваивания, если это необходимо. И если позже в программе будет вызываться
удаленная функция, то компилятор выдаст ошибку.

Оператор присваивания может быть перегружен для выполнения операций присваивания с объектами вашего класса.
Если вы не предоставите перегруженный оператор присваивания сами, то компилятор создаст его за вас. Перегруженные
операторы присваивания всегда должны иметь проверку на самоприсваивание.
По умолчанию оператор присваивания и конструктор копирования, предоставляемые компилятором, выполняют
почленную инициализацию/присваивание, что является поверхностным копированием. Если в вашем классе есть
динамически выделенные члены, то это, скорее всего, приведет к проблемам (несколько объектов могут указывать на одну
и ту же выделенную память). В таком случае вам нужно будет явно определить свой конструктор копирования и перегрузку
оператора присваивания для выполнения глубокого копирования.


Тест

Задание No 1
Предположим, что Square — это класс, а square — это объект этого класса. Какой способ перегрузки лучше использовать
для следующих операторов?
 square + square
 -square
 std::cout << square
 square = 7;

Ответ No 1

Задание No 2
Напишите класс Average, который будет вычислять среднее значение всех передаваемых ему целых чисел. Используйте два
члена: первый должен быть типа int32_t и использоваться для вычисления суммы всех передаваемых чисел, второй должен
быть типа int8_t и использоваться для вычисления количества передаваемых чисел. Чтобы найти среднее значение, нужно
разделить сумму на количество.

a) Следующий код функции main():

1 int main()
2 {
3 	Average avg;
4
5 	avg +=5;
6 	std::cout << avg << '\n'; // 5 / 1 = 5
8 	avg +=9;
7
9 	std::cout << avg << '\n'; // (5+9) / 2 = 7
10
11 	avg +=19;
12 	std::cout << avg << '\n'; // (5+9+19)/3=11
13
14 	avg+=-9;
15 	std::cout << avg << '\n'; // (5+9+19 - 9)/4=6
16
17 	(avg+= 7)+= 11;// выполнение цепочки операций
18 	std::cout << avg <<'\n'; // (5+9+19 - 9 + 7 + 11)/6=7
19
20 	Average copy=avg;
21 	std::cout << copy << '\n';
22
23 	return 0;
24 }

Должен выдавать следующий результат:
5
7
11
6
7
7

Ответ No2.а)

b) Требуется ли этому классу явный конструктор копирования или оператор присваивания?

ОтветNo2.b)


Задание No 3

Напишите свой собственный класс-массив целых чисел IntArray (не используйте std::array или std::vector). Пользователи
должны передавать размер массива при создании объекта этого класса, а сам массив (переменная-член) должен
выделяться динамически. Используйте стейтменты assert для проверки передаваемых значений, а также свой конструктор
копирования и перегрузку оператора присваивания, если это необходимо, чтобы следующий код:

1 #include<iostream>
2
3 IntArray fillArray()
4 {
5 	IntArraya(6);
6 	a[0]=6;
7 	a[1]=7;
8 	a[2]=3;
9 	a[3]=4;
10 	a[4]=5;
11 	a[5]=8;
12
13 	return a;
14 }
15
16 int main()
17 {
18 	IntArray a = fillArray();
19 	std::cout << a <<'\n';
20
21 	IntArray b(1);
22 	a = a;
23 	b = a;
24
25 	std::cout <<b<<'\n';
26
27 	return 0;
28 }

Выдавал следующий результат:
6 7 3 4 5 8
6 7 3 4 5 8

Ответ No 3


Задание No 4
Значение типа с плавающей точкой — это число с десятичной дробью, где количество цифр после точки (дробная часть)
может меняться. Значениет ипа с фиксированной точкой — это число с дробью, где дробь (после точки) фиксированная.
Вам нужно написать класс для реализации значений типа с фиксированной точкой с двумя цифрами после точки
(например, 11.47, 5.00 или 1465.78). Диапазон класса должен быть от -32768.99 до32767.99, в дробной части могут
быть любые две цифры, не допускайте проблем с точностью.

a) Какого типа данных переменную-член следует использовать для реализации значений типа с фиксированной точкой с 
2-мя цифрами после точки? (Обязательно прочитайте ответ, прежде чем приступать к выполнению следующего задания)

Ответ No 4.а)


b) Напишите класс FixedPoint, который реализует рекомендуемое решение из предыдущего задания. Если дробная или
целая части значения являются отрицательными, то число должно рассматриваться, как отрицательное. Реализуйте
перегрузку необходимых операторов и напишите необходимые конструкторы, чтобы следующий код функции main():

1 int main()
2 {
3 FixedPoint a(37,58);
4 std::cout << a << '\n';
5
6 FixedPoint b(-3,9);
7 std::cout << b << '\n';
8
9 FixedPoint c(4, -7);
10 std::cout <<c<<'\n';
11
12 FixedPoint d(-5,-7);
13 std::cout <<d<<'\n';
14
15 FixedPoint e(0, -3);
17
16 std::cout << e <<'\n';
18 std::cout <<static_cast<double>(e)<< '\n';
19
20 return 0;
21 }

Выдавал следующий результат:
37.58
-3.09
-4.07
-5.07
-0.03
-0.03

Подсказка: Для вывода значения конвертируйте его в тип double, используя оператор static_cast.

Ответ No 4.b)

c) Теперь добавьте конструктор, который будет принимать значение типа double. Вы можете округлить целую часть (слева
от точки) с помощью функции round() ( которая находится в заголовочном файле cmath).
Подсказки:
 Выможете получить целую часть от числа типа double путем конвертации числа типа double в число типа int.
 Для перемещения одной цифры влево от точки используйте умножение на 10. Для перемещения двух цифр
используйте умножение на 100.

Следующий код функцииmain():

1 int main()
2 {
3 	FixedPointa(0.03);
4 	std::cout <<a<<'\n';
5
6 	FixedPointb(-0.03);
7 	std::cout <<b<<'\n';
8
9 	FixedPointc(4.01); // сохранится, как 4.0099999..., поэтому нам нужно это всё округлить
10 	std::cout << c << '\n';
11
12 	FixedPointd(-4.01); //сохранится,как-4.0099999..., поэтому нам нужно это всё округлить
13 	std::cout << d << '\n';
14
15 	return 0;
16 }

Должен выдавать следующий результат:
0.03
-0.03
4.01
-4.01

Ответ No 4.c)

d) Выполните перегрузку следующих операторов: ==, >>, −(унарный) и + (бинарный).

Следующая программа:
1 void SomeTest()
2 {
3 	std::cout <<std::boolalpha;
4 	std::cout <<(FixedPoint(0.75) + FixedPoint(1.23)== FixedPoint(1.98))<< '\n'; //обазначенияположительные, никакого
5 	std::cout <<(FixedPoint(0.75) + FixedPoint(1.50)== FixedPoint(2.25))<< '\n'; //обазначенияположительные, переполн
6 	std::cout <<(FixedPoint(-0.75)+FixedPoint(-1.23)== FixedPoint(-1.98)) <<'\n';// оба значения отрицательные,никак
7 	std::cout <<(FixedPoint(-0.75)+FixedPoint(-1.50)== FixedPoint(-2.25)) <<'\n';// оба значения отрицательные,переп
8 	std::cout <<(FixedPoint(0.75) + FixedPoint(-1.23) ==FixedPoint(-0.48))<< '\n'; //второе значение отрицательное,ник
9 	std::cout <<(FixedPoint(0.75) + FixedPoint(-1.50) ==FixedPoint(-0.75))<< '\n'; //второе значение отрицательное,воз
10 	std::cout <<(FixedPoint(-0.75)+FixedPoint(1.23) ==FixedPoint(0.48)) <<'\n';// первоезначениеотрицательное, ника
11 std::cout <<(FixedPoint(-0.75)+FixedPoint(1.50) ==FixedPoint(0.75)) <<'\n';// первоезначениеотрицательное, возм
12 }
13
14 int main()
15 {
16 	SomeTest();
17
18 	FixedPointa(-0.48);
19 	std::cout <<a<<'\n';
20
21 	std::cout <<-a << '\n';
22
23 	std::cout <<"Enteranumber:"; //введите5.678
24 	std::cin>> a;
25
26 	std::cout <<"Youentered: " <<a<< '\n';
27
28 	return 0;
29 }

Должна выдавать следующий результат:
true
true
true
true
true
true
true
true
-0.48
0.48
Enter a number: 5.678
You entered:5.68

Подсказка:Для выполнения перегрузки оператора >> используйте конструктор с параметром типа double для
создания анонимного объекта класса FixedPoint, а затем присвойте этот объект параметру функции перегрузки
оператора >>.

Ответ No 4.d)