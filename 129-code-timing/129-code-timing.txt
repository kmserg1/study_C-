Урок No 129. Измерение времени выполнения (тайминг) кода


Иногда, в процессе написания кода, вы можете столкнуться с ситуациями, когда не будете уверены, какая из двух функций
окажется более эффективной (предполагается, что конечный результат у обеих функций одинаковый). Как это определить?
Один изсамых простых способов — засечь время выполнения каждого из фрагментов кода. В C++11 этоделается через
библиотеку chrono. Мы можем легко инкапсулировать весь необходимый нам функционал в класс, который затем будем
использовать в наших собственных программах.

Вот класс:

1 #include <chrono> // для функций из std::chrono
2
3 class Timer
4 {
5 private:
6 	// Псевдонимы типов используются для удобного доступа к вложенным типам
7 	using clock_t = std::chrono::high_resolution_clock;
8 	using second_t = std::chrono::duration<double, std::ratio<1> >;
9
10 	std::chrono::time_point<clock_t> m_beg;
11
12 public:
13 	Timer() : m_beg(clock_t::now())
14 	{
15 	}
16
17 	void reset()
18 	{
19 		m_beg = clock_t::now();
20 	}
21
22 	double elapsed() const
23 	{
24 		return std::chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
25 	}
26 };

Для его использования нужно определить объект класса Timer в верхней части функции main() (или откуда вы хотите начинать
отсчет), а затем просто вызватьметод elapsed() после части кода, которую вы проверяете:

1 int main()
2 {
3 	Timer t;
4
5 	// Здесь находится код, к которому применяется тайминг
6
7 	std::cout << "Time elapsed: " << t.elapsed() << '\n';
8
9 	return 0;
10 }

Рассмотрим реальный пример, где нужно отсортировать массив из 10 000 элементов. Воспользуемся алгоритмом
сортировки методом выбора:

1 #include <iostream>
2 #include <array>
3 #include <chrono> // для функций из std::chrono
4
5 const int g_arrayElements = 10000; // общее количество всех элементов массива
6
7 class Timer
8 {
9 private:
10 	// Псевдонимы типов используются для удобного доступа к вложенным типам
11 	using clock_t = std::chrono::high_resolution_clock;
12 	using second_t = std::chrono::duration<double, std::ratio<1> >;
13
14 	std::chrono::time_point<clock_t> m_beg;
15
16 public:
17 	Timer() : m_beg(clock_t::now())
18 	{
19 	}
20
21 	void reset()
22 	{
23 		m_beg = clock_t::now();
24 	}
25
26 	double elapsed() const
27 	{
28 		return std::chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
29 	}
30 };
31
32 void sortArray(std::array<int, g_arrayElements> &array)
33 {
34
35 	// Перебираем каждый элемент массива (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберемся
36 	for (int startIndex = 0; startIndex < g_arrayElements - 1; ++startIndex)
37 	{
38 		// В переменной smallestIndex хранится индекс наименьшего значения, которое мы нашли в этой итерации.
39 		// Начнем с того, что наименьший элемент в этой итерации - это первый элемент (индекс 0)
40 		int smallestIndex = startIndex;
41
42 		// Затем ищем элемент меньше нашего smallestIndex в оставшейся части массива
43 		for (int currentIndex = startIndex + 1; currentIndex < g_arrayElements; ++currentIndex)
44 		{
45 			// Если нашли элемент, который меньше нашего наименьшего элемента,
46 			if (array[currentIndex] < array[smallestIndex])
47 				// то записываем/запоминаем его
48 				smallestIndex = currentIndex;
49 		}
50
51 		// smallestIndex теперь наименьший элемент в оставшейся части массива.
52 		// Меняем местами наше стартовое наименьшее значение с тем, которое мы обнаружили
53 		std::swap(array[startIndex], array[smallestIndex]);
54 	}
55 }
56
57 int main()
58 {
59 	std::array<int, g_arrayElements> array;
60 	for (int i = 0; i < g_arrayElements; ++i)
61 		array[i] = g_arrayElements - i;
62
63 	Timer t;
64
65 	sortArray(array);
66
67 	std::cout << "Time taken: " << t.elapsed() << '\n';
68
69 	return 0;
70 }

На компьютере автора результат трех прогонов кодасоставляет 0.0508 , 0.0507 и 0.0499 секунды, т.е. около 0.05 секунды.
Теперь проделаем то же самое, но сstd::sort из Стандартной библиотеки C++:

1 #include <iostream>
2 #include <array>
3 #include <chrono> // для функций из std::chrono
4 #include <algorithm> // для std::sort()
5
6 const int g_arrayElements = 10000; // общее количество всех элементов массива
7
8 class Timer
9 {
10 private:
11 	// Псевдонимы типов используются для удобного доступа к вложенным типам
12 	using clock_t = std::chrono::high_resolution_clock;
13 	using second_t = std::chrono::duration<double, std::ratio<1> >;
14
15 	std::chrono::time_point<clock_t> m_beg;
16
17 public:
18 	Timer() : m_beg(clock_t::now())
19 	{
20 	}
21
22 	void reset()
23 	{
24 		m_beg = clock_t::now();
25 	}
26
27 	double elapsed() const
28 	{
29 		return std::chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
30 	}
31 };
32
33 void sortArray(std::array<int, g_arrayElements> &array)
34 {
35
36 	// Перебираем каждый элемент массива (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберемс
37 	for (int startIndex = 0; startIndex < g_arrayElements - 1; ++startIndex)
38 	{
39 		// В переменной smallestIndex хранится индекс наименьшего значения, которое мы нашли в этой итерации.
40 		// Начнем с того, что наименьший элемент в этой итерации - это первый элемент (индекс 0)
41 		int smallestIndex = startIndex;
42
43 		// Затем ищем элемент меньше нашего smallestIndex в оставшейся части массива
44 		for (int currentIndex = startIndex + 1; currentIndex < g_arrayElements; ++currentIndex)
45 		{
46 			// Если нашли элемент, который меньше нашего наименьшего элемента,
47 			if (array[currentIndex] < array[smallestIndex])
48 				// то записываем/запоминаем его
49 				smallestIndex = currentIndex;
50 		}
51
52 		// smallestIndex теперь является наименьшим элементом в оставшейся части массива.
53 		// Меняем местами наше стартовое наименьшее значение с тем, которое мы обнаружили
54 		std::swap(array[startIndex], array[smallestIndex]);
55 	}
56 }
57
58 int main()
59 {
60 	std::array<int, g_arrayElements> array;
61 	for (int i = 0; i < g_arrayElements; ++i)
62 		array[i] = g_arrayElements - i;
63
64 	Timer t;
65
66 	std::sort(array.begin(), array.end());
67
68 	std::cout << "Time taken: " << t.elapsed() << '\n';
69
70 	return 0;
71 }

Результаты трехпрогоновна компьютере авторасоставляют 0.000694 , 0.000693 и 0.000697 секунды, т.e.около 0.0007
секунды.
Таким образом, алгоритм std::sort() в 75 раз быстрее, чем сортировка, которую написали мы сами!


Что влияет на тайминг кода?

Тайминг кода является достаточно простым и прозрачным, но ваши результатымогут существенно отличаться из-за ряда
вещей:

Во-первых, убедитесь, что вы используете режим конфигурации «Release», а не «Debug». Во время режима «Debug»
оптимизация обычно отключена, а она может оказывать значительное влияние на результаты. Например, в конфигурации
«Debug», выполнение сортировки элементов массива через std::sort() на компьютере автора заняло 0.0237 секунды,что в 34
раза больше, нежели в конфигурации «Release»!

Во-вторых, на результаты тайминга влияют процессы, которые ваша система может выполнять в фоновом режиме.
Для достижения наилучших результатов убедитесь, что ваша ОС не делает ничего, что интенсивно нагружает процессор,
жесткий диск (например, запущен поиск файла или сканирование антивирусом) или расходует много памяти (например, вы
играете в игры или работаете в фото или видеоредакторе).
Выполняйте тайминг как минимум 3 раза. Если результаты одинаковые — выбираем среднее. Если один или два результата
значительно отличаются друг от друга, то запустите тайминг еще несколько раз, пока не получите лучшее представление о
том, какие из результатов оказались «левыми». Обратите внимание, некоторые, казалось бы, невинные вещи, такие как веб-
браузеры, могут временно увеличить нагрузку наваш процессор до 100%, когда сайт, на котором вы находитесь в фоновом
режиме, выполняет целую кучу скриптов JavaScript (рекламные баннеры, запуск видео, сложная анимация и т.д.). Запуск
тайминга несколько раз позволит определить, повлияло ли подобное событие на ваши результаты.

В-третьих, при сравнении двух фрагментов кода старайтесь не запускать ничего лишнего в фоновом режиме при
прогонах кода, так как это также может повлиять на результаты тайминга. Возможно, ваш антивирус начал сканирование в
фоновом режиме, или, может быть, вы решили послушать музыку на стриминговом сервисе (и это всё в перерывах между
прогонами).
Рандомизация также может повлиять на тайминг. Если бы мы отсортировали массив, заполненный случайными числами,
то это бы повлияло на результаты тайминга (тот факт, что числа являются рандомными). Рандомизацию использовать можно,
но убедитесь, что ваше стартовое значение является фиксированным (т.е. не используйте системные часы в качестве
стартового значения) и результаты рандомизации идентичны прикаждом запуске. Кроме того, убедитесь, что в фрагментах
кода не используется пользовательский ввод, так как время ожидания ввода от пользователя не должно учитываться при
определении эффективности кода.
Наконец, ваширезультаты действительны только для архитектуры вашего компьютера, ОС, компилятора и
системных/технических характеристик. Вы можете получить совсем другие результаты на других системах, которые имеют
другие сильные и слабые стороны.
