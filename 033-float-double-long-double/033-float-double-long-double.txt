Урок No 33. Типы данных с плавающей точкой: float, double и long double


На этом уроке мы рассмотрим типы данных с плавающей точкой в языке С++, их точность и диапазон. Выясним, что такое
экспоненциальная запись и как она используется, а также рассмотрим ошибки округления и дадимо пределения для nan и
inf .

Оглавление:
1. Типы данных с плавающей точкой
2. Экспоненциальная запись
3. Конвертация чисел в экспоненциальную запись
4. Точность и диапазон типов с плавающей точкой
5. Ошибки округления
6. nan и inf
7. Заключение
8. Тест

Типы данныхс плавающейточкой

Целочисленные типы данных отлично подходят для работы с целыми числами, но есть ведь еще и дробные числа. И тут нам
на помощь приходит тип данных с плавающей точкой (или типданных с плавающей запятой»,англ. "floating point")
Переменная такого типа может хранить любые действительные дробные значения,  например: 4320.0, -3.33 или
0.01226.
Почему точка «плавающая»? 
Дело в том,что точка/запятая перемещается («плавает») между цифрами, разделяя целую и дробную части значения.
Есть три типа данных с плавающейточкой: float, double и long double.
Язык C++ определяет только их минимальный размер (как и с целочисленными типами). 
Типы данных с плавающей точкой всегда являются signed (т.е. могут хранить как положительные, так и отрицательные числа).
 
----------------------------------------------------------------------------------------
Название		Тип		Минимальный размер		Типичный размер
----------------------------------------------------------------------------------------
Типданных с плавающей	float 		4 байта 			4 байта
точкой  		double		8 байт				8 байт
			long double	8 байт				8, 12 или 16 байт
----------------------------------------------------------------------------------------

Объявление переменных разных типов данных с плавающей точкой:
1 float fValue;
2 double dValue;
3 long doubledValue2;

Если нужно использовать целое число с переменной типа с плавающей точкой, то тогда после этого числануж нопоставить
разделительную точку и нуль.
Это позволяет различать переменные целочисленных типов от переменных типов с плавающей запятой:

1 int n(5);// 5-это целочисленный тип
2 double d(5.0);// 5.0 - это тип данных с плавающей точкой (по умолчанию double)
3 float f(5.0f);// 5.0 - это тип данных с плавающей точкой ("f" от "float")

Обратите внимание, литералы типа с плавающей точкой по умолчанию относятся к типу double. f в конце числа означает тип
float.

Экспоненциальная запись.

Экспоненциальная запись очень полезна для написания длинных чисел в краткой форме. Числа в экспоненциальной записи
имеютследующий вид: мантисса × 10^экспонент. Например, рассмотрим выражение 1.2 × 10^4. Значение 1.2 — это
мантисса (или «значащая часть числа»), а 4 — это экспонент (или «порядок числа»). Результатом этого выражения является
значение 12000.
Обычно, в экспоненциальной записи, в целой частинаходится только одна цифра, все остальные пишутся после
разделительной точки (в дробной части).
Рассмотрим массу Земли. В десятичной системе счисления она представлена как 5973600000000000000000000 кг.
Согласитесь, очень большое число (даже слишком большое, чтобы поместиться в целочисленную переменную размером 8
байт). Это число даже трудно читать (там 19 или 20 нулей?). Но используя экспоненциальную запись, массу Земли можно
представить, как 5.9736 × 10^24кг (что гораздо легче воспринимается, согласитесь). 
Еще одним преимуществом экспоненциальной записи является сравнение двух очень больших или очень маленьких чисел — 
для этого достаточно просто сравнить их экспоненты.

В языке C++ буква е / Е означает, что число 10 нужно возвести в степень, которая следует за этой буквой.
Например, 1.2 × 10^4 эквивалентно 1.2e4 ,значение 5.9736 ×10^24 еще можно записать как 5.9736e24.
Для чисел меньше единицы экспонент может быть отрицательным. Например, 5e-2 эквивалентно 5 * 10^-2, что, в свою
очередь, означает 5/10^2 или 0.05. Масса электрона равна 9.1093822e-31 кг .

На практике экспоненциальная запись может использоваться в операциях присваивания следующим образом:

1 double d1(5000.0);
2 double d2(5e3); //другой способ присвоить значение 5000
4 double d3(0.05);
3
5 double d4(5e-2); // другой способ присвоить значение 0.05

Конвертация чисел в экспоненциальную запись
Для конвертации чисел в экспоненциальную запись необходимо следовать процедуре, указанной ниже:
 Ваш экспонентначинается с нуля.
 Переместите разделительную точку (которая разделяет целую и дробную части) влево, чтобы слева от нее осталась
только одна ненулевая цифра:
	 каждое перемещение точки влево увеличивает экспонент на 1;
	 каждое перемещение точки вправо уменьшает экспонент на 1 .
 Откиньте все нули перед первой ненулевой цифрой в целойчасти.
 Откиньте все конечные нули в правой (дробной) части, только если исходное числоявляется целым (без разделительной точки).

Рассмотрим примеры:

Исходное число: 42030
Перемещаем разделительную точку на 4 цифры влево: 4.2030e4
Слева (в целой части) нетнулей:4.2030e4
Отбрасываем конечный нуль в дробной части: 4.203e4 (4 значащие цифры)

Исходноечисло: 0.0078900
Перемещаем разделительную точку на 3 цифры вправо: 0007.8900e-3
Отбрасываем нули слева: 7.8900e-3
Не отбрасываем нули справа (исходное число является дробным): 7.8900e-3 (5 значащих цифр)

Исходноечисло: 600.410
Перемещаем разделительную точку на 2 цифры влево: 6.00410e2
Слева нет нулей:6.00410e
Нули справа оставляем:6.00410e2 (6 значащих цифр)

Самое главное, что нужно запомнить — это то, что цифры в мантиссе (часть перед e) называются значащими цифрами.
Количество значащих цифр определяет точность самого значения. Чем больше цифр в мантиссе, тем точнее значение.


Точность и диапазон типов с плавающей точкой

Рассмотрим дробь 1/3. Десятичное представление этогочисла — 0.33333333333333... (с тройками до бесконечности).
Бесконечное число требует бесконечной памяти для хранения, а у нас в запасе, как правило, 4 или 8 байт. 
Переменные типа с плавающей запятой могут хранить только определенное количество значащих цифр, остальные — отбрасываются.
Точность определяется количеством значащих цифр, которые представляют число без потери данных.
Когда мы выводим переменные типа с плавающей точкой, то точность объекта cout, по умолчанию, составляет 6. 
Т.е. на экране мы увидим только 6 значащих цифр, остальные — потеряются. Например:

1 #include<iostream>
2
3 int main()
4 {
5 float f;
6 f = 9.87654321f;
7 std::cout<< f << std::endl;
8 f = 987.654321f;
9 std::cout<< f << std::endl;
10 f = 987654.321f;
11 std::cout<< f << std::endl;
12 f = 9876543.21f;
13 std::cout<< f << std::endl;
14 f = 0.0000987654321f;
15 std::cout<< f << std::endl;
16 return 0;
17 }

Результат выполнения программы:
9.87654
987.654
987654
9.87654e+06
9.87654e-05

Обратите внимание, каждое из выше приведенных значений имеет только 6 значащих цифр (цифры перед e, а не перед
точкой).

Также, в некоторых случаях, cout сам может выводить числа в экспоненциальной записи. В зависимости от компилятора,
экспонент может быть дополнен нулями. Например, 9.87654e+06 — этото жесамое, что и 9.87654e6 (просто с добавленным
нулем и знаком+). Минимальное количество цифр экспонента определяется компилятором (VisualStudio использует 2, другие
компиляторы могут использовать 3).
Также мы можем переопределить точность cout, используя функцию std::setprecision(), которая находится в заголовочном
файле iomanip:

1 #include <iostream>
2 #include <iomanip> // для std::setprecision()
3
4 int main()
5 {
6 std::cout<< std::setprecision(16); //задаемточностьв16цифр
7 float f =3.33333333333333333333333333333333333333f;
8 std::cout<< f << std::endl;
9 doubled = 3.3333333333333333333333333333333333333;
10 std::cout<< d << std::endl;
11 return 0;
12 }

Результат выполнения программы:
3.333333253860474
3.333333333333333

Так как мы увеличили точность до 16, то каждая переменная выводится с 16 цифрами. Но, как вы можете видеть, исходные
числа имеют больше цифр!
Точность зависит от размера типа данных (в типе float точность меньше, чем в типе double) и от присваиваемого значения:
 точностьfloat: от 6 до 9 цифр (восновном7);
 точность double: от 15 до 18 цифр (восновном 16);
 точность long double: 15,18 или 33 цифры (в зависимости от того, сколько байт занимает тип данных на компьютере).
Этот принцип относится не только к дробным числам, но и ко всем значениям, которые имеют слишком большое количество
значащих цифр.Например:

1 #include <iostream>
2 #include <iomanip> // для std::setprecision()
3
4 int main()
5 {
6 float f(123456789.0f);//переменная f имеет 10 значащихцифр
7 std::cout << std::setprecision(9);// задаем точность в 9 цифр
8 std::cout<< f << std::endl;
9 return 0;
10 }

Результат:
123456792

Но ведь 123456792 большечем 123456789, не так ли?
Значение 123456789.0 имеет 10 значащих цифр, ноточность float равна 7.
Поэтому мы и получили другое число - произошла потеряданных!
Следовательно, нужно быть осторожными, когда вы используете переменные типа с плавающей точкой вместе с очень
большими / очень маленькими числами, которые требуют большей точности, чем их текущий тип данных может предложить.

Диапазон и точность типов данных с плавающей точкой, согласно стандарту IEEE754:
-------------------------------------------------------------------------------------------
Размер	 	Диапазон	 			Точность
-------------------------------------------------------------------------------------------
4 байта		от ±1.18 x 10^-38 до ±3.4 x 10^38 	6-9 значащих цифр(в основном 7)
8 байт		от ±2.23 x 10^-308 до ±1.80x10^308 	15-18 значащих цифр (в основном 16)
12 байт 	от ±3.36x10^-4932 до ±1.18x10^4932	18-21 значащих цифр
16 байт 	от ±3.36x10^-4932 до ±1.18x10^4932 	33-36 значащих цифр
-------------------------------------------------------------------------------------------

Может показаться немного странным, что 12-байтовая переменная типа с плавающей точкой имеет тот же диапазон, 
что и 16-байтовая переменная. Это потому, что они имеют одинаковое количество бит, выделенных для экспонента 
(только в 16-байтовой переменной точность будет выше).

Правило: Используйте по умолчанию тип double вместо типа float, так как его точность выше.


Ошибки округления

Рассмотрим дробь 1/10. В десятичной системе счисления эту дробь можно представить, как 0.1.
В двоичной системе счисления эта дробь представлена в виде бесконечной последовательности — 0.00011001100110011...
Именно из-за подобных разногласий в представлении чисел в разных системах счисления, у нас могут возникать проблемы с точностью. 
Например:

1 #include <iostream>
2 #include <iomanip> // для std::setprecision()
3
4 int main()
5 {
6 doubled(0.1);
7 std::cout<< d << std::endl; //используем точность coutпоумолчанию (6 цифр)
8 std::cout<< std::setprecision(17);
9 std::cout<< d << std::endl;
10 return 0;
11 }

Результат выполнения программы:
0.1
0.10000000000000001

Первый coutвыводит 0.1 (что и ожидаемо).
После того, как мы изменили для объекта cout точность вывода до 17 цифр, мы
увидели, что значением переменной d является не совсем 0.1! Подобное происходит из-за ограничений в количестве
выделяемой памяти для переменных типа double, а также из-за необходимости «округлять» числа. 
По факту мы получили типичную ошибку округления.
Подобные ошибки могут иметь неожиданные последствия:

1 #include<iostream>
2 #include<iomanip> // для std::setprecision()
3
4 int main()
5 {
6 std::cout<< std::setprecision(17);
7
8 doubled1(1.0);
9 std::cout<< d1<<std::endl;
10
11 doubled2(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1); //должнополучиться 1.0
12 std::cout<< d2<<std::endl;
13 }

Результат выполнения программы:
1
0.99999999999999989

Хотя мыожидали, что d1 иd2 окажутся равными, но это не так. Ач то,если бы нам довелось сравнивать эти переменные и,
исходя из результата, выполнять определенный сценарий? В таком случае ошибок нам не миновать.

Математические операции (например,сложение или умножение), как правило, только увеличивают масштаб этих ошибок.
Даже если 0.1 имеет погрешность в 17-й значащей цифре, то привыполнении операции сложения десять раз, ошибка
округления переместитсяк 16-й значащей цифре.


nan и inf

Есть две специальные категории чисел типа с плавающей запятой:
 inf (или «бесконечность», от англ «infinity»), которая может быть либо положительной, либо отрицательной.
 nan (или «нечисло», от англ «not a number»). Их есть несколько видов (обсуждать все виды здесь мы не будем).

Рассмотрим примеры на практике:
1 #include<iostream>
2
3 int main()
4 {
5 double zero=0.0;
6 double posinf=5.0 / zero; // положительная бесконечность
7 std::cout<< posinf <<"\n";
8
9 double neginf=-5.0/zero; // отрицательная бесконечность
10 std::cout<< neginf <<"\n";
11
12 double nan = zero / zero;// нечисло (математически некорректно)
13 std::cout<< nan << "\n";
14
15 return 0;
16 }

Результат выполненияпрограммы:
inf
-inf
-nan(ind)

inf означает«бесконечность», а ind означает «неопределенный» (от англ. «indeterminate»). 
Обратите внимание, результаты вывода inf и nan завися тот компилятора/архитектуры компьютера, поэтому 
ваш результат выполнения вышеприведенной программы может отличаться от моего результата.

Заключение

Переменные типа с плавающей точкой отлично подходят для хранения очень больших или очень маленьких (в том числе и
дробных) чисел до тех пор, пока они имеют ограниченное количество значащих цифр (не превышают точность определенного
типа данных).
Переменные типа с плавающей точкой могут иметь небольшие ошибки округления, даже если точностьтипа не превышена. В
большинстве случаев такие ошибки остаются незамеченными, так как они не столь значительны. Но следует помнить, что
сравнение переменных типов с плавающей точкой можетиметь неопределенные последствия/результаты (а выполнение
математических операций с такими переменными может только увеличить масштаб этих ошибок).

Тест
Запишите следующие числа в экспоненциальной записи в стиле языка C++ (используя букву е, каксимвол экспонента) и
определите, сколько значащих цифр имеет каждое из следующих чисел:
 34.50
3.45e+01, 3 знач. цифры / 3.450e1 (4 значащие цифры). -1

 0.004000
4.0е-03, 1 знач. цифра / 4.000e-3 (4 значащие цифры). -1

 123.005
1.23005e+02, 6 знач. цифр / 1.23005e2 (6 значащих цифр). +1

 146000
1.46e+05, 3  знач. цифры / 1.46e5 (3 значащие цифры). +1

 146000.001
1.46000001e+5, 9 знач. цифр / 1.46000001e5 (9 значащих цифр). +1

 0.0000000008
 8.0e-10, 1 знач. цифра /  8e-10 (1 значащая цифра). Здесь мантисса не 8.0, а 8, поэтому число и имеет только 1 значащую цифру. +1

 34500.0
3.45e+04, 3  знач. цифры / 3.45000e4 (6 значащих цифр). (Здесь конечные нули не игнорируются, так как в исходном числе есть 
точка, которая разделяет целую и дробную части. Хотя эта точка никак не влияет на само число, она влияет на его точность. 
Если бы исходное число было указано, как 34500, то ответ равнялся бы 3.45e4.) -1

Итоговый рез-т: +1 - чуть больше полоовины правильных ответов. На троечку.
Ответ