Урок No53. Пространства имен

Этотурок является продолжением урока No 24.

Оглавление:
1. Конфликт имен
2. Что такое пространство имен?
3. Доступ к пространству имен через оператор разрешения области видимости (::)
4. Пространства имен с одинаковыми названиями
5. Псевдонимы и вложенные пространства имен


Конфликт имен

Конфликт имен возникает, когда два одинаковых идентификатора находятся в однойобласти
видимости, и компилятор не может понять, какой из этих двух следует использовать в конкретной
ситуации. Компилятор или линкер выдаст ошибку, так как у них недостаточно информации, чтобы
решить эту неоднозначность. Как только программы увеличиваются в объемах, количество
идентификаторов также увеличивается, следовательно, увеличивается и вероятность
возникновения конфликтов имен.
Рассмотрим пример такого конфликта. boo.h и doo.h — это заголовочные файлы с функциями,
которые выполняют разные вещи, но имеют одинаковые имена и параметры.

boo.h:
1 // Функция doOperation() выполняет операцию сложения своих параметров
2 int doOperation(int a, int b)
3 {
4  return a + b;
5 }

doo.h:
1 // Функция doOperation() выполняет операцию вычитания своих параметров
2 int doOperation(int a, int b)
3 {
4 return a - b;
5 }

main.cpp:
1 #include <iostream>
2 #include "boo.h"
3 #include "doo.h"
4
5 int main()
6 {
7 std::cout << doOperation(5, 4); // какая версия doOperation() выполнится здесь?
8 return 0;
9 }

Если boo.h и doo.h скомпилировать отдельно, то всё пройдет без инцидентов. Однако, соединив
их в одной программе, мы подключим две разные функции, но с одинаковыми именами и
параметрами, в одну область видимости (глобальную), а это, в свою очередь, приведет к
конфликту имен. В результате, компилятор выдаст ошибку. Для решения подобных проблем и
добавили в язык С++ такую концепцию, как пространства имен.


Что такое пространство имен?

Пространство имен определяет область кода, в которой гарантируется уникальность всех
идентификаторов. По умолчанию, глобальные переменные и обычные функции определены в
глобальном пространстве имен. Например:

1 int g_z = 4;
2
3 int boo(int z)
4 {
5 return -z;
6 }

Глобальная переменная g_z и функция boo() определены в глобальном пространстве имен.
В примере, приведенном выше, при подключении файлов boo.h и doo.h обе версии doOperation()
были включены в глобальное пространство имен, из-за чего, собственно, и произошел конфликт
имен.
Чтобы избежать подобных ситуаций, когда два независимых объекта имеют идентификаторы,
которые могут конфликтовать друг с другом при совместном использовании, язык C++ позволяет
объявлять собственные пространства имен через ключевое слово namespace. Всё, что
объявлено внутри пользовательского пространства имен, принадлежит только этому пространству 
имен (а не глобальному).
Перепишем заголовочные файлы из вышеприведенного примера, но уже с использованием namespace:

boo.h:
1 namespace Boo
2 {
3 	// Эта версия doOperation() принадлежит пространству имен Boo
4 	int doOperation(int a, int b)
5 	{
6 		return a + b;
7 	}
8 }

doo.h:
1 namespace Doo
2 {
3 	// Эта версия doOperation() принадлежит пространству имен Doo
4	int doOperation(int a, int b)
5	 {
6		 return a - b;
7	 }
8 }

Теперь doOperation() из файла boo.h находится в пространстве имен Boo , а doOperation() из
файла doo.h — в пространстве имен Doo . Посмотрим, что произойдет при перекомпиляции

main.cpp:
1 int main()
2 {
3 std::cout << doOperation(5, 4); // какая версия doOperation() здесь выполнится?
4 return 0;
5 }

Результатом будетеще одна ошибка:

C:\VCProjects\Test.cpp(15) : error C2065: 'doOperation' : undeclared identifier

Случилось так, что когда мы попытались вызвать функцию doOperation(), компилятор заглянул в
глобальное пространство имен в поисках определения doOperation(). Однако, поскольку ни одна
из наших версий doOperation() не находится в глобальном пространстве имен, компилятор не
смог найти определение doOperation() вообще!

Существует два разных способа сообщить компилятору, какую версию doOperation() следует
использовать: через оператор разрешенияобласти видимости или с помощью using-стейтментов
(о них мы поговорим на следующем уроке).


Доступк пространству имен черезоператор разрешения области видимости (::)

Первый способ указать компилятору искать идентификатор в определенном пространстве имен
— это использовать название необходимого пространства имен вместе с оператором разрешения
области видимости (::) и требуемым идентификатором.
Например, сообщим компилятору использовать версию doOperation() из пространстваимен Boo:

1 int main(void)
2 {
3 std::cout << Boo::doOperation(5, 4);
4 return 0;
5 }

Результат:
9

Если бы мы захотели использовать версию doOperation() из пространства имен Doo:

1 int main(void)
2 {
3 std::cout << Doo::doOperation(5, 4);
4 return 0;
5 }

Результат:
1

Оператор разрешения области видимости хорош, так как позволяет выбрать конкретное
пространство имен. Мы даже можем сделать следующее:

1 int main(void)
2 {
3 std::cout << Boo::doOperation(5, 4) << '\n';
4 std::cout << Doo::doOperation(5, 4) << '\n';
5 return 0;
6 }

Результат:
9
1

Также этот оператор можно использовать без какого-либо префикса (например, ::doOperation ).
В таком случаемы ссылаемся на глобальное пространство имен.


Пространства имен содинаковыми названиями

Допускается объявление пространств имен в нескольких местах (либо в нескольких файлах, либо
в нескольких местах внутри одного файла). Всё, что находится внутри одного блока имен,
считается частью только этого блока.

add.h:
1 namespace DoMath
2 {
3	 // Функция add() является частью пространства имен DoMath
4 	int add(int x, int y)
5 	{
6 		return x + y;
7	}
8 }

subtract.h:
1 namespace DoMath
2 {
3	 // Функция subtract() является частью пространства имен DoMath
4	 int subtract(int x, int y)
5	 {
6       	 return x - y;
7        }
8 }

main.cpp:
1 #include "add.h" // импортируем DoMath::add()
2 #include "subtract.h" // импортируем DoMath::subtract()
3
4 int main(void)
5 {
6 std::cout << DoMath::add(5, 4) << '\n';
7 std::cout << DoMath::subtract(5, 4) << '\n';
8
9 return 0;
10 }

Всё работает, как нужно.
Стандартная библиотека C++ широко использует эту особенность, поскольку все заголовочные
файлы, которые находятся в ней, реализуют свой функционал внутри пространства имен std.

Псевдонимы и вложенные пространства имен
Однипространства имен могутбытьвложеныв другие пространства имен.Например:
1 #include <iostream>
2
3 namespace Boo
4 {
5	 namespace Doo
6	 {
7		 const int g_x = 7;
8        }
9 }
10
11 int main()
12 {
13 std::cout << Boo::Doo::g_x;
14 return 0;
15 }

Обратите внимание, поскольку Doo находится внутри Boo, то доступ к g_x осуществляется
через Boo::Doo::g_x .
Так как это не всегда удобно и эффективно, то C++ позволяет создавать псевдонимы для
пространств имен:

1 #include <iostream>
2
3 namespace Boo
4 {
5 	namespace Doo
6	{
7		 const int g_x = 7;
8       }
9 }
10
11 namespace Foo = Boo::Doo; // Foo теперь считается как Boo::Doo
12
13 int main()
14 {
15 std::cout << Foo::g_x; // это, на самом деле, Boo::Doo::g_x
16 return 0;
17 }

Стоит отметить, что пространства имен в C++ не были разработаны, как способ реализации
информационной иерархии — они были разработаны в качестве механизма предотвращения
возникновения конфликтов имен. Как доказательство этому, вся Стандартная библиотека
шаблонов находится в единственном пространстве имен std::.
Вложенность пространств имен не рекомендуется использовать, так как при неумелом
использовании увеличивается вероятность возникновения ошибок и дополнительно усложняется
логика программы.

