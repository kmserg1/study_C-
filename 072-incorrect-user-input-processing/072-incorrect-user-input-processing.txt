Урок No72. Обработка некорректного пользовательского ввода


Большинство программ, имеющих хоть какой-либо пользовательский интерфейс, сталкиваются с обработкой
пользовательского ввода. В программах, которые мы писали раньше, используется std::cin для получения пользовательского
ввода. А так как ввод данных имеет свободную форму (пользователь можетввести всё, чтоп ожелает), то пользователю очень
легко ввести данные, которые от него никак не ожидаются.
При написании программ, вы всегда должны учитывать, как пользователи (преднамеренно или непреднамеренно) могут
использовать ваши программы. Хорошо написанная программа предвидит, как ею могут злоупотребить, и либо будет
обрабатывать такие случаи, либо предотвращать их (если это возможно). Программа, которая имеет обработку некорректного
ввода, называется надежной. На этом уроке мы рассмотрим, как пользователи могут вводить некорректные данные через std::cin, 
а также как с этим бороться.                                                

Оглавление:
1. std::cin, буферданных и извлечение
2. Проверка пользовательского ввода
3. Основные типы некорректного пользовательского ввода
	Ошибка No 1
	Ошибка No 2
	Ошибка No 3
	Ошибка No 4
4. Объединяем всё вместе
5. Заключение


std::cin, буфер данных и извлечение

Прежде чем разбираться с обработкой некорректного ввода через std::cin и оператор >>, давайте сначала рассмотрим их принцип работы.
Процесс, когда мы используем оператор >> для получения данных от пользователя и размещение этих данных в определенной переменной, 
называется извлечением. Соответственно, оператор >> называется оператором извлечения.
Когда пользователь вводит данные в ответ на операцию извлечения, то эти данные помещаются в буфер std::cin. Буфер данных — 
это просто часть памяти, зарезервированная для временного хранения данных, когда они перемещаются из одного места в другое. 
В этом случае буфер используется для хранения пользовательского ввода, пока он находится в режиме ожидания выделения для него переменных.

При использовании оператора извлечения, выполняется следующая процедура:

   Если во входном буфере есть данные, то эти данные используются для извлечения.
   Если во входном буфере нет данных, то пользователю предлагается ввести данные (обычно именно это и происходит в большинстве случаев). 
    Когда пользователь нажимает Enter, символ новой строки \n помещается во входной буфер.
   Оператор >> извлекает столько данных из входного буфера в переменную, сколько позволяет размер самой переменной (игнорируя любые пробелы, табы или \n).
   Любые данные, которые не были извлечены, остаются во входном буфере для последующего извлечения.

Извлечение данных считается успешным, если по крайней мере один символ был извлечен из входного буфера. 
Оставшиеся данные во входном буфере используются для последующих извлечений. Например:

int a;
std::cin >> a;

Если пользователь введет 7d, то 7 будет извлечено, преобразовано в целое число и присвоено переменной a. А d\n останется во входном 
буфере дожидаться следующего извлечения.

Извлечение не выполняется, если данные ввода не соответствуют типу переменной, выделенной для них. Например:

int a;
std::cin >> a;

Если бы пользователь ввел z, то извлечение не выполнилось бы, так как z не может быть извлечено в целочисленную переменную.


Проверка пользовательского ввода

Существует три основных способа проверки пользовательского ввода:

   До ввода
	 Предотвращение некорректного пользовательского ввода.
   После ввода
	 Пользователь может вводить всё, что хочет, но осуществляется последующая проверка данных. Если проверка прошла успешно, 
	  то выполняется перемещение данных в переменную.
	  Пользователь может вводить всё, что хочет, но при операции извлечения данных оператором >> параллельно решаются возможные ошибки.

Некоторые графические пользовательские интерфейсы или расширенные текстовые интерфейсы позволяют проверять ввод пользователя сразу 
(символ за символом). Программист создает функцию проверки данных, которая принимает и проверяет пользовательский ввод, и, если данные 
ввода корректны, то возвращается true, если нет — false. Эта функция вызывается каждый раз, когда пользователь нажимает на клавишу. 
Если функция проверки возвращает true, то символ, который пользователь ввел — принимается. Если функция возвращает false, то символ, который 
только что ввел пользователь — отбрасывается (и не отображается на экране). Используя этот метод, мы можем гарантировать, что любой 
пользовательский ввод будет корректным, так как любые неверные нажатия клавиш будут обнаружены и немедленно удалены. 
К сожалению, std::cin не поддерживает этот тип проверки.
Поскольку строки не имеют никаких ограничений на то, какие символы вводятся, то извлечение гарантированно будет успешным (хотя помним, 
что std::cin останавливает процесс извлечения при первом обнаружении символа пробела). После ввода строки программа сразу может её 
проанализировать. Однако этот анализ и последующая конвертация данных в другие типы данных (например, числа) может быть сложной, поэтому 
это делается только в редких случаях.

Чаще всего мы позволяем std::cin и оператору извлечения выполнять тяжелую работу. В соответствии с этим методом пользователь может 
вводить всё, что хочет, а далее std::cin и оператор >> пытаются извлечь данные и, если что-то пойдет не так, выполняется обработка 
возможных ошибок. Это самый простой способ, и его мы и будем рассматривать.

Рассмотрим следующую программу «Калькулятор», которая не имеет обработки ошибок:

#include <iostream>

double getValue()
{
    std::cout << "Enter a double value: ";
    double a;
    std::cin >> a;
    return a;
}
 
char getOperator()
{
    std::cout << "Enter one of the following: +, -, *, or /: ";
    char sm;
    std::cin >> sm;
    return sm;
}
 
void printResult(double a, char sm, double b)
{
    if (sm == '+')
        std::cout << a << " + " << b << " is " << a + b << '\n';
    else if (sm == '-')
        std::cout << a << " - " << b << " is " << a - b << '\n';
    else if (sm == '*')
        std::cout << a << " * " << b << " is " << a * b << '\n';
    else if (sm == '/')
        std::cout << a << " / " << b << " is " << a / b << '\n';
}
 
int main()
{
    double a = getValue();
    char sm = getOperator();
    double b = getValue();
 
    printResult(a, sm, b);
 
    return 0;
}

Здесь мы просим пользователя ввести два числа и арифметический оператор. Результат выполнения программы:

Enter a double value: 4
Enter one of the following: +, -, *, or /: *
Enter a double value: 5
4 * 5 is 20

Теперь рассмотрим, где некорректный ввод пользователя может привести к сбою в программе.

Сначала мы просим пользователя ввести первое число. А что будет, если он введет что-либо другое (например, q)? В этом случае извлечение данных не произойдет.

Во-вторых, мы просим пользователя ввести один из 4 возможных символов (арифметических операторов). Что будет, если он введет какой-то другой символ? Мы 
сможем извлечь данные, но не сможем их обработать.

В-третьих, что будет, если пользователь вместо символа введет строку, например, *q hello. Хотя мы можем извлечь символ *, но в буфере останется 
лишний балласт, который в будущем может привести к проблемам.


Основные типы некорректного пользовательского ввода

Мы выделили 4 типа:
 Извлечение выполняется успешно, но значения бесполезны для программы (например, вместо математического
оператора введен символ k).
 Извлечение выполняется успешно, но пользователь вводит лишний текст (например, *q hello вместо одного символа
математического оператора).
 Извлечение не выполняется (например, вместо числового значения ввели символ q).
 Извлечение выполняется успешно, но пользователь ввел слишком большое числовоез начение.

Таким образом, чтобы наши программы были надежными, то всякий раз, когда мы просим пользователя ввести данные, мы
должны предугадать возможность возникновения любого из вышеуказанных событий, и, если это произойдет, в программе
должна быть обработка таких случаев.
Давайте рассмотрим каждую из ситуаций, приведенных выше, а также алгоритм действий, если такая ситуация случилась.


Ошибка No 1: Извлечение выполняется успешно, но данные бесполезны

Это самый простой случай. Рассмотрим следующий фрагмент выполнения программы, приведенной выше:

Enter a double value: 4
Enter one of the following: +, -, *, or /: k
Enter a double value: 5

Здесь мы просим пользователя ввести одиниз 4 арифметических операторов, но он вводит k. Символ k является
допустимым символом,поэтому std::cinи звлекаетего в переменную sm, и всё это добро возвращается обратно в функцию
main(). Но впрограмме не предусмотрен случай обработки подобного ввода, поэтому мы получаем сбой, и в результате ничего
не выводится.
Решение простое: выполнить проверку пользовательского ввода. Обычно она состоит из трех шагов:

 Проверить пользовательский ввод на ожидаемые значения.
 Если ввод совпадает с ожидаемым, то значения благополучно возвращаются.
 Если нет, то сообщаем пользователю что что-то пошло не так, и просим повторить ввод снова.

Вотобновленная функция getOperator() с проверкой пользовательского ввода:

1 char getOperator()
2 {
3 	while (true) // цикл продолжается до тех пор,покапользователь нев ведет корректное значение
4 	{
5		std::cout << "Enterone of thefollowing:+, -, *, or /: ";
6 		char sm;
7 		std::cin >> sm;
8
9		//Выполняем проверку значений
10 		if(sm == '+'|| sm== '-' || sm =='*' || sm == '/')
11 			return sm; // возвращаем данныев функцию main()
12 		else // в противномслучае, сообщаем пользователю, что что-то пошло не так
13 			std::cout<< "Oops, that input is invalid. Please try again.\n";
14 	}
15 }

Мы используем цикл while для гарантии корректного ввода. Если пользователь введет один из ожидаемых символов, то всё
хорошо — символ возвратится обратно в функцию main(), если нет — пользователю выведется просьба повторить ввод снова.
И вводить данные онбудет до тех пор, пока не введет корректное значение, не закроет программу или не уничтожит свой
компьютер.


Ошибка No 2: Извлечение выполняется успешно, но пользователь вводит лишний текст

Рассмотрим следующее выполнение программы «Калькулятор»:
Enter a double value: 4*5
Как вы думаете, что произойдет дальше?

Enter a double value: 4*5
Enter one of the following: +, -, *, or /: Enter a double value: 4 * 5 is 20

Программа выведет верный результат, но её порядок выполнения неправильный.
Почему? Сейчас разберемся.
Когда пользователь вводит 4*5, то эти данные поступают в буфер. Затем оператор >> извлекает 4 в переменную a,
оставляя *5\n в буфере. Затем программа выводит "Enter one of the following: +, -, *, or /:". Однако, когда
вызывается оператор извлечения, он видит, что в буфере находится *5\n, поэтому он использует эти данные вместо того,
чтобы запрашивать их у пользователя еще раз. Следовательно, извлекается символ *, а 5\n остается во входном буфере.
После того, как пользователя просят ввестидругое число, 5 извлекается из буфера, не дожидаясь ответа от пользователя.
Поскольку у пользователя не было возможности ввести другие значения и нажать Enter (вставляя символ новой строки), то всё
происходит на одной строке.
Хотя результат программы правильный, но её выполнение — нет. Согласитесь, что с наличием возможности просто
проигнорировать лишниес имволы было бы намного лучше. К счастью, это можно сделать следующим образом:

1 std::cin.ignore(32767, '\n'); // удаляем до 32767 символов из входного буфера вплоть до появления символа '\n' (который мы также удаляем)


Поскольку последний символ, введенный пользователем, должен быть \n (так как пользователь в конце ввода нажимает
Enter), то мы можем сообщить std::cin игнорировать все символы в буфере до тех пор, пока не будет найден символ новой
строки (который мы также удаляем). Таким образом, всё лишнее будет успешно проигнорировано.
Обновим нашу функцию getDouble(), добавив эту строку:
1 doublegetValue()
2 {
3 	std::cout << "Enter a double value:";
4 	double a;
5 	std::cin >> a;
6 	std::cin.ignore(32767, '\n');// удаляемдо 32767 символов из входного буфера вплотьдо появления символа '\n' (который мыт
7 	return a;
8 }

Теперь наша программа будет работать так, как надо, даже если мы введем 4*5 в первой строке. Число 4 будет извлечено в
переменную, а все остальные символы будут удалены из входного буфера. Поскольку входной буфер теперь пуст, то при
последующем выполнении операции извлечения всё пройдет гладко и порядок выполнения программы не будет нарушен.


Ошибка No 3: Извлечение не выполняется

Рассмотрим следующее выполнение программы «Калькулятор»:
Enter a double value: a
Теперь уже неудивительно, что программа работает не так, как надо, но её дальнейший ход выполнения — вот что интересно:

Enter a double value: a
Enter one of the following: +, -, *, or /: Enter a double value:

И программа внезапно обрывается.
Этот случай похож на ошибку No 2, но все же несколько отличается. Давайте рассмотрим детально, что здесь происходит.
Когда пользователь вводит a, то этот символ помещаетсяв буфер. Затем оператор >> пытается извлечь a в переменную a
типа double. Поскольку a нельзя конвертировать в тип double, то оператор >> не может выполнить извлечение. На этом
этапе случаются две вещи: a остается в буфере, а std::cin переходит в «режим отказа». Как только установлен этот режим, то
все последующие запросы на извлечение данных будут проигнорированы.
К счастью, мы можем определить, удачно ли прошло извлечение или нет.Если нет, то мы можем исправить ситуацию
следующим образом:

1 if (std::cin.fail()) // если предыдущее извлечение было неудачным,
2 {
3 	std::cin.clear(); // то возвращаем cin в'обычный' режим работы
4 	std::cin.ignore(32767,'\n'); // и удаляем значения предыдущеговводаиз входного буфера
5 }

Вот так! Теперь давайте интегрируем это в нашу функцию getValue():
1 double getValue()
2 {
3 	while (true)// цикл продолжается до тех пор,покапользователь невведет корректное значение
4 	{
5 		std::cout << "Entera double value:";
6 		double a;
7 		std::cin >> a;
8
9 		if(std::cin.fail()) // если предыдущее извлечение оказалось неудачным,
10 		{
11 			std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
12 			std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
13 		}
14 		else // если всё хорошо,то возвращаем a
15 			return a;
16 	}
17 }


Ошибка No 4: Извлечение выполняется успешно, но пользователь ввел слишком большое числовое
значение

Рассмотрим следующий код:

1 #include <iostream>
2 #include <cstdint>
3
4 int main()
5 {
6 	std::int16_t x { 0 }; // переменная x занимает 16 бит, её диапазон значений: от -32768 до 32767
7 	std::cout << "Enter a number between -32768 and 32767: ";
8 	std::cin >> x;
9
10 	std::int16_t y { 0 }; // переменная y занимает 16 бит, её диапазон значений: от -32768 до 32767
11 	std::cout << "Enter another number between -32768 and 32767: ";
12 	std::cin >> y;
13
14 	std::cout <<"The sum is: " << x +y << '\n';
15 	return 0;
16 }

Что случится, если пользователь введет слишком большое число (например, 40000)?
Enter a number between -32768 and 32767: 40000
Enter another number between -32768 and 32767: The sum is: 32767

В вышеприведенном примере std::cin немедленно перейдет в «режим отказа», и значение небудет присвоено переменной x.
Следовательно, переменной x присваивается максимально возможное значение типа данных (в этомслучае, 32767). Все
следующие данные ввода будут проигнорированы, а y останется с инициализированным значением 0. 
Решение такое же, как и вслучае с неудачным извлечением (см.ошибка No 3).


Объединяем всё вместе

1 #include <iostream>
2
3 double getValue()
4 {
5 	while (true)// цикл продолжается до тех пор,покапользователь невведет корректное значение
6 	{
7 		std::cout << "Entera double value:";
8 		double a;
9 		std::cin >> a;
10
11 		// Проверка на предыдущее извлечение
12 		if(std::cin.fail()) // если предыдущее извлечение оказалось неудачным,
13 		{
14 			std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
15 			std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
16 			std::cout<< "Oops, that input is invalid. Please try again.\n";
17 		}
18 		else
19 		{
20 		std::cin.ignore(32767,'\n'); //удаляем лишние значения
21
22 		return a;
23 		}
24 	}
25 }
26
27 char getOperator()
28 {
29 	while (true)// цикл продолжается до тех пор,покапользователь невведет корректное значение
30 	{
31 		std::cout << "Enterone of thefollowing:+, -, *, or /: ";
32 		char sm;
33 		std::cin >> sm;
34
35 		// Переменные типа char могут принимать любые символы из пользовательского ввода, поэтому нам не стоит беспокоиться по поводу возникновения неудачного извлечения
36
37 		std::cin.ignore(32767,'\n'); // удаляем лишнийбалласт
38
39 		//Выполняем проверку пользовательского ввода
40 		if(sm == '+'|| sm== '-' || sm =='*' || sm == '/')
41 			return sm; // возвращаем обратно в caller
42 		else // в противном случае, сообщаем пользователю что что-то пошло не так
43 		std::cout<< "Oops, that input is invalid. Please try again.\n";
44 	}
45 }
46
47 void printResult(double a, char sm, double b)
48 {
49 	if (sm== '+')
50 		std::cout << a << "+ " << b << " is " << a + b << '\n';
51 	else if (sm == '-')
52 		std::cout << a << "- " << b << " is " << a - b << '\n';
53  	else if (sm == '*')
54 		std::cout << a << "* " << b << " is " << a * b << '\n';
55 	else if (sm == '/')
56      	std::cout << a << "/ " << b << " is " <<a / b << '\n';
57 	else
58 		std::cout << "Something went wrong: printResult() got an invalid operator.";
59
60 }
61
62 int main()
63 {
64 	double a = getValue();
65 	char sm = getOperator();
66 	double b = getValue();
67
68 	printResult(a, sm, b);
69
70  return 0;
71 }


Заключение

При написании программ, всегда думайте о том, как пользователи могут злоупотребить ими или использовать не по
назначению, особенно то, что касаетсяв вода данных. Подумайте:
 Может ли извлечение не выполниться?
 Может ли пользователь ввести значение больше ожидаемого?
 Может ли пользователь ввести бессмысленные значения?
 Может ли ввод пользователя привести к переполнению переменных?

Используйтеветвление if и логические переменные для проверки пользовательского ввода.
Следующий код осуществляет проверку пользовательского ввода и исправляет проблемы с переполнением или неудачным
извлечением данных:

1 if (std::cin.fail()) // если предыдущее извлечение не выполнилось или произошло переполнение,
2 {
3  	std::cin.clear(); // то возвращаем cin в'обычный' режим работы
4 	std::cin.ignore(32767,'\n'); // и удаляем значения предыдущеговводаиз входного буфера
5 }

Примечание: Проверка пользовательского ввода очень важна и полезна, но она, к сожалению, приводит к усложнению
кода, что, в свою очередь, затрудняет его понимание. Поэтому на следующих уроках мы небудем её использовать, дабы
всё оставалось максимально простым и доступным.
