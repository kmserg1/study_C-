Урок No23. Header guards и #pragma once

Наэтомуроке мы рассмотрим, чтотакоеheaderguardsи #pragma once в языкеC++, атакже зачемони нужны икак их
правильноиспользовать.

Оглавление:
1. Проблема дублирования объявлений
2. Header guards
3. #pragma once
4. Тест


Проблема дублирования объявлений

Как мы уже знаем из урока о предварительных объявлениях, идентификатор может иметь только одно объявление. Таким
образом, программа с двумя объявлениями одной переменной получит ошибку компиляции:

1 int main()
2 {
3 int x; // это объявление идентификатора 
4 int x; // ошибка компиляции: дублирование объявлений
5
6 return 0;
7 }

То же самое касается и функций:

1 #include <iostream>
2
3 int boo()
4 {
5 return 7;
6 }
7
8 int boo() // ошибка компиляции: дублирование определений
9 {
10 return 7;
11 }
12
13 int main()
14 {
15 std::cout<< boo();
16 return 0;
17 }

Хотя выше приведенные ошибки легко исправить (достаточно просто удалить дублирование), с заголовочными файлами
дела обстоят несколько иначе. Довольно легко можно попасть в ситуацию, когда определения одних и тех же заголовочных
файлов будут подключаться больше одного раза в файл .cpp. Очень часто это случается при подключении одного
заголовочного файла другим.

Рассмотрим следующую программу:

math.h:
1 int getSquareSides()
2 {
3 return 4;
4 }

geometry.h:
1 #include "math.h"

main.cpp:
1 #include"math.h"
2 #include"geometry.h"
3
4 int main()
5 {
6 return 0;
7 }

Эта, казалось бы, невинная программа, не скомпилируется! Проблема кроется в определении функции в файле math.h. 
Давайте детально рассмотрим, чтоздесь происходит:
 Сначала main.cpp подключает заголовочный файл math.h, вследствие чего определение функции getSquareSides
копируетсяв main.cpp.
 Затем main.cpp подключает заголовочный файл geometry.h, который, в свою очередь, подключает math.h.
 В geometry.h находится копия функции getSquareSides() (из файлаmath.h), которая уже во второй раз копируется 
в main.cpp.
Таким образом, после выполнения всех директи в #include, main.cpp будет выглядеть следующим образом:

1 int getSquareSides() // из math.h
2 {
3 return 4;
4 }
5
6 int getSquareSides() // из geometry.h
7 {
8 return 4;
9 }
10
11 int main()
12 {
13 return 0;
14 }

Мы получим дублирование определений и ошибку компиляции. Если рассматривать каждый файл по отдельности, то ошибок
нет. Однако в main.cpp, который подключает сразу два заголовочных файла с одним и темже определением функции, мы
столкнемся с проблемами. Если для geometry.h нужна функция getSquareSides(), а для main.cpp нужен как geometry.h, так и
math.h, то какое же решение?


Header guards

На самом деле решение простое — использовать header guards (защиту подключения вязыке C++). Header guards — это
директивы условной компиляции, которые состоят из следующего:

1 #ifndef SOME_UNIQUE_NAME_HERE
2 #define SOME_UNIQUE_NAME_HERE
3
4 //Основная часть кода
5
6 #endif

Если подключить этот заголовочный файл, то первое, что он сделает — это проверит, был ли ранее определен идентификатор
SOME_UNIQUE_NAME_HERE. Если мы впервые подключаем этот заголовок, то SOME_UNIQUE_NAME_HERE еще не был определен.
Следовательно, мы определяем SOME_UNIQUE_NAME_HERE (с помощью директивы #define) и выполняется основная часть
заголовочного файла. Если же мы раньше подключали этот заголовочный файл, то SOME_UNIQUE_NAME_HERE уже был
определен. В таком случае, при подключении этого заголовочного файла во второй раз, его содержимое будет
проигнорировано.
Все ваши заголовочные файлы должны иметь header guards. SOME_UNIQUE_NAME_HERE может быть любым идентификатором,
но, как правило, в качестве идентификатора используется имя заголовочного файла с окончанием _H . Например, в файле
math.h идентификатор будет MATH_H:

math.h:
1 #ifndef MATH_H
2 #define MATH_H
3
4 int getSquareSides()
5 {
6
 return 4;
7 }
8
9 #endif

Даже заголовочные файлы из Стандартной библиотеки С++ используют header guards. Если бы вы взглянули на содержимое
заголовочного файла iostream, то вы бы увидели:

1 #ifndef _IOSTREAM_
2 #define _IOSTREAM_
3
4 //основная часть кода
5
6 #endif

Но сейчас вернемся к нашему примеру с math.h, где мы попытаемся исправить ситуацию с помощью header guards:

math.h:
1 #ifndef MATH_H
2 #define MATH_H
3
4 int getSquareSides()
5 {
6 return 4;
7 }
8
9 #endif

geometry.h:
1 #include"math.h"

main.cpp:
1 #include"math.h"
2 #include"geometry.h"
3
4 int main()
5 {
6 return 0;
7 }

Теперь, при подключении в main.cpp заголовочного файла math.h, препроцессор увидит, что MATH_H не был определен,
следовательно, выполнится директива определения MATH_H и содержимое math.h скопируется в main.cpp. Затем main.cpp
подключает заголовочный файл geometry.h, который, в свою очередь, подключает math.h. Препроцессор видит, что MATH_H
уже был ранее определен и содержимое geometry.h не будет скопировано в main.cpp.
Вот так можно бороться с дублированием определений с помощью header guards.

#pragma once
Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву #pragma:
1 #pragma once
2
3 //основная часть кода

#pragma once используется в качестве header guards, но имеет дополнительные преимущества — она короче и менее
подвержена ошибкам.
Однако, #pragma once не являетсяо фициальной частью языка C++, и не все компиляторы её поддерживают (хотя
большинство современных компиляторов поддерживают).

Я же рекомендую использовать header guards, чтобы сохранить максимальную совместимость вашего кода.

Тест
Добавьте header guards к следующему заголовочному файлу:

add.h:
1 int add(int x,int y);


#ifndef ADD_H
#define ADD_H
int add(int x,int y);
#endif


Ответ 


#ifndef ADD_H
#define ADD_H
 
int add(int x, int y);
 
#endif
