Урок No 154. Базовое наследование

Теперь,когдамы уже поговорили о наследовании в абстрактном ключе, давайте поговорим о том,как это используется в
языке C++ на практике.

Оглавление:
1. Наследование в С++
2. Класс Human
3. Класс BasketballPlayer
4. Делаем класс BasketballPlayer дочерним
5. Дочерний класс Employee
6. Цепочка наследований
7. Почему наследование является полезным?
8. Заключение


Наследование в С++

Наследование в C++ происходит между классамии имеет тип отношений «является». Класс, от которого наследуют,
называется родительским (или «базовым», «суперклассом»), а класс, который на следует, называется дочерним (или
«производным», «подклассом»).
В диаграмме, представленной выше, Фрукт является родительским классом, а Яблоко и Банан — дочерними классами.

                        ┌────────────────────┐
                        │       Фрукт        │
                        └┬──────────────────┬┘
             ┌───────────┤                  ├───────────┐
             │  Яблоко   │                  │   Банан   │
             └───────────┘                  └───────────┘

В следующей диаграмме Треугольник является дочерним классом (родитель— Фигура ) и родительским (для Правильного
треугольника ) одновременно.
                              ┌────────────┐
              ┌───────────────┤   Фигура   ├──────────┐
              │               └────────────┘          │
      ┌───────┴──────┐                       ┌────────┴──────────┐
      │ Треугольник  │                       │  Четырехугольник  │
      └───────┬──────┘                       └────────┬──────────┘
      ┌───────┴─────────────────┐           ┌─────────┴─────────────┐
      │ Правильный треугольник  │           │   Прямоугольник       │
      └─────────────────────────┘           └─────────┬─────────────┘
                                             ┌────────┴────────┐
                                             │  Квадрат        │
                                             └─────────────────┘

Дочерний класс наследует как поведение (методы), так и свойства (переменные-члены) от родителя (с учетом некоторых
ограничений доступа, которые мы рассмотрим чуть позже). Эти методы и переменные становятся членами дочернего класса.
Поскольку дочерние классы являются полноценными классами, то они могут (конечно) иметь и свои собственные члены.
Сейчас мы этовсё рассмотрим детально.


Класс Human

Вот простой класс Human для представления Человека:

1 #include <string>
2
3 class Human
4 {
5 public:
6 	std::string m_name;
7 	int m_age;
8
9 	Human(std::string name = "", int age = 0)
10 		: m_name(name), m_age(age)
11 	{
12 	}
13
14 	std::string getName() const { return m_name; }
15 	int getAge() const { return m_age; }
16
17 };

В этом классе мы определили только те члены, которые являются общими для всех объектов этого класса. Каждый Человек
(независимо от пола, профессии и т.д.) имеет Имя и Возраст.

Обратите внимание, в примере, приведенном выше, мы сделали все переменные-члены и методы класса открытыми. Это
сделано ради простоты примера. Обычно переменные-члены нужно делать private. О средствах контроля доступа и о том, как
это работает в наследовании, мы поговорим на соответствующих уроках.


Класс BasketballPlayer

Предположим, что нам нужно написать программу, которая будет отслеживать информацию о баскетболистах. Мы можем
сохранять средний уровень игры баскетболиста и количество очков.
Вот наш незавершенный класс BasketballPlayer:

1 class BasketballPlayer
2 {
3 public:
4 	double m_gameAverage;
5 	int m_points;
6
7 	BasketballPlayer(double gameAverage = 0.0, int points = 0)
8 		: m_gameAverage(gameAverage), m_points(points)
9 	{
10 	}
11 };

Также нам нужно знать Имя и Возраст баскетболиста, а эта информация уже у нас есть: она хранится в классе Human.
У нас есть три варианта добавления Имени и Возраста в BasketballPlayer:

 Добавить Имя и Возраст в класс BasketballPlayer непосредственно в качестве членов. Это плохой вариант,так как
произойдет дублирование кода, который уже существует в классе Human. Любые обновления в Human также должны быть
продублированы и в BasketballPlayer.

 Добавить класс Human в качестве члена в класс BasketballPlayer, используя композицию. Но возникает вопрос: «Может
ли BasketballPlayer иметь Human?». Нет, это некорректно.

 Сделать так, чтобы BasketballPlayerу наследовал необходимые атрибуты от Human. Помните,что тип отношений в
наследовании — «является». Является ли BasketballPlayer Human-ом (т.е. Человеком)? Конечно! Поэтому наш выбор —
наследование.


Делаем класс BasketballPlayer дочерним

Чтобы класс BasketballPlayer унаследовал информацию от класса Human, нам нужно после объявления BasketballPlayer (class
BasketballPlayer) использовать двоеточие, ключевое слово public и имя класса, от которого мы хотим унаследовать. Это
называется открытым наследованием:

1 // BasketballPlayer открыто наследует Human
2 class BasketballPlayer : public Human
3 {
4 public:
5 	double m_gameAverage;
6 	int m_points;
7
8 	BasketballPlayer(double gameAverage = 0.0, int points = 0)
9 		: m_gameAverage(gameAverage), m_points(points)
10 	{
11 	}
12 };

Проиллюстрируем:

Когда BasketballPlayer наследует свойства класса Human, то BasketballPlayer приобретает методы и переменные-члены класса
Human. Кроме того, BasketballPlayer имеет еще два своих собственных члена: m_gameAverage и m_points . Здесь есть смысл,
так как эти свойства специфичны только для BasketballPlayer, а не для каждого Human-а.

Таким образом, объекты BasketballPlayer будут иметь 4 члена:
 m_gameAverage и m_points отBasketballPlayer;
 m_name и m_age отHuman.

Полный код программы:
1 #include <iostream>
2 #include <string>
3
4 class Human
5 {
6 public:
7 	std::string m_name;
8 	int m_age;
9
10 	Human(std::string name = "", int age = 0)
11 		: m_name(name), m_age(age)
12 	{
13 	}
14
15 	std::string getName() const { return m_name; }
16 	int getAge() const { return m_age; }
17
18 };
19
20 // BasketballPlayer открыто наследует Human
21 class BasketballPlayer : public Human
22 {
23 public:
24 	double m_gameAverage;
25 	int m_points;
26
27 	BasketballPlayer(double gameAverage = 0.0, int points = 0)
28 		: m_gameAverage(gameAverage), m_points(points)
29 	{
30 	}
31 };
32
33 int main()
34 {
35 	// Создаем нового Баскетболиста
36 	BasketballPlayer anton;
37 	// Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
38 	anton.m_name = "Anton";
39 	// Выводим имя Баскетболиста
40 	std::cout << anton.getName() << '\n'; // используем метод getName(), который мы унаследовали от класса Human
41
42 	return 0;
43 }

Результат выполнения программы:
Anton

Это работает, так как anton является объектом класса BasketballPlayer, а все объекты класса BasketballPlayer имеют
переменную-член m_name и метод getName(), унаследованные от класса Human.


Дочерний класс Employee

Теперь напишемеще один класс, который также будет наследовать свойства Human. Например, класс Employee (Работник).
Работник «является» Человеком, поэтому использовать наследование здесь уместно:

1 // Employee открыто наследует Human
2 class Employee: public Human
3 {
4 public:
5 	int m_wage;
6 	long m_employeeID;
7
8 	Employee(int wage = 0, long employeeID = 0)
9 		: m_wage(wage), m_employeeID(employeeID)
10 	{
11 	}
12
13 	void printNameAndWage() const
14 	{
15 		std::cout << m_name << ": " << m_wage << '\n';
16 	}
17 };

Работникнаследует m_name и m_age от Human-а (а также два метода) и имеет еще две собственные переменные-члены и
один метод. Обратите внимание, метод printNameAndWage() использует переменные как из класса, к которому принадлежит
( Employee::m_wage ), так и с родительского класса (Human::m_name).

Проиллюстрируем:

                        ┌────────────────────┐
                        │       Human        │
                        └┬──────────────────┬┘
             ┌───────────┴──────┐          ┌┴───────────┐
             │ BasketballPlayer │          │  Employee  │
             └──────────────────┘          └────────────┘

Обратите внимание, классы Employee и BasketballPlayer не имеют прямых отношений, хотя оба наследуют свойства класса Human.
Вотполный код:

1 #include <iostream>
2 #include <string>
3
4 class Human
5 {
6 public:
7 	std::string m_name;
8 	int m_age;
9
10 	std::string getName() const { return m_name; }
11 	int getAge() const { return m_age; }
12
13 	Human(std::string name = "", int age = 0)
14 		: m_name(name), m_age(age)
15 	{
16 	}
17 };
18
19 // Employee открыто наследует Human
20 class Employee: public Human
21 {
22 public:
23 	int m_wage;
24 	long m_employeeID;
25
26      Employee(int wage = 0, long employeeID = 0)
27              : m_wage(wage), m_employeeID(employeeID)
28 	{
29 	}
30
31 	void printNameAndWage() const
32 	{
33 		std::cout << m_name << ": " << m_wage << '\n';
34 	}
35 };
36
37 int main()
38 {
39 Employee ivan(350, 787);
40 ivan.m_name = "Ivan"; // мы можем это сделать, так как m_name является public
41
42 ivan.printNameAndWage();
43
44 return 0;
45 }

Результат выполнения программы:
Ivan: 350


Цепочка наследований

Можно наследовать от класса, который сам наследует от другого класса. При этом ничего примечательного или чего-нибудь
особенного не происходит — всё аналогично тому, что мы рассмотрели выше. Например, напишем класс Supervisor
(Супервайзер). Супервайзер — это Работник, который «является» Человеком. Мы уже написали класс Employee, поэтому будем
его использовать в качестве родительского класса:

1 class Supervisor: public Employee
2 {
3 public:
4 	// Этот Супервайзер может наблюдать максимум за 5-тью Работниками
5 	long m_nOverseesIDs[5];
6
7 	Supervisor()
8 	{
9 	}
10
11 };

Смотрим:
Все объекты Supervisor наследуют методы и переменные от Employee и Human, а также имеют свою собственную переменную-
член m_nOverseesIDs.
Построив такие цепочки наследований, мы можем создать набор повторно используемых классов, которые будутиметь общие
свойства вверху и становиться всё более специфичными на каждом последующем уровне наследования.


Почему наследование является полезным?

Использование наследования означает, что нам не нужно переопределять информацию из родительских классов в дочерних.
Мы автоматически получаем методы и переменные-члены суперкласса через наследование, а затем просто добавляем
специфичные методы или переменные-члены, которые хотим. Это не только экономит время и усилия, но также является
очень эффективным: если мы когда-либо обновим или изменим базовый класс (например, добавим новые функции или
исправим ошибку), то все наши производные классы автоматически унаследуют эти изменения!
Например, если мы добавим новый метод в Human, то Employee и Supervisor автоматически получат доступ к нему. Если мы
добавим новую переменную в Employee, Supervisor также получит доступ к ней. Это позволяет создавать новые классы более
простым, интуитивно-понятным способом!


Заключение

Наследование позволяет повторно использовать классы путем наследования членов этих классов другими классами. На
следующих урокахмы будем разбираться детально,как это всё работает.
