Урок No116. Конструкторы


На этомуроке мы рассмотрим конструкторы в языке С++.

Оглавление:
1. Конструкторы
2. Конструкторы по умолчанию
3. Конструкторы с параметрами
4. Копирующая инициализация
5. Уменьшение количества конструкторов
6. Неявно генерируемый конструктор по умолчанию
7. Классы, содержащие другие классы
8. Тест


Конструкторы

Когда все членыкласса (или структуры) являются открытыми, то мы можем инициализировать
класс (или структуру) напрямую, используя список инициализаторов или uniform-
инициализацию (в C++11):

1 class Boo
2 {
3 public:
4 int m_a;
5 int m_b;
6 };
7
8 int main()
9 {
10 Booboo1={ 7, 8 }; //список инициализаторов
11 Booboo2{9,10}; // uniform-инициализация (C++11)
12
13  return 0;
14 }

Однако, как только мы сделаем какие-либо переменные-члены класса закрытыми, то больше не
сможем инициализировать их напрямую. Здесь есть смысл: есливы не можете напрямую
обращаться к переменной (потому что она закрыта), то вы и не должны иметь возможность
напрямую её инициализировать.
Как тогда инициализировать класс с закрытыми переменными-членами? 
Использовать конструкторы.

Конструктор — это особый тип метода класса, который автоматически вызывается при создании
объекта этого же класса. Конструкторы обычно используются для инициализации переменных-
членов класса значениями, которые предоставлены по умолчанию/пользователем, или для
выполнения любых шагов настройки, необходимых для используемого класса (например, открыть
определенный файл или базуданных).              
В отличие от обычных методов, конструкторы имеютопределенные правила их именования:

 конструкторы всегда должны иметь то же имя, чтои класс (учитываются верхний и нижний регистры);
 конструкторы не имеют типа возврата (даже void).

Обратите внимание, конструкторы предназначены только для выполнения инициализации. Не
следует пытаться вызывать конструктор для повторнойин ициализации существующего объекта.
Хотя этоможет скомпилироваться без ошибок, результаты могут получиться неожиданные
(компилятор создаст временный объект, а затем удалит его).


Конструкторы по умолчанию

Конструктор, который не имеет параметров (или содержит параметры, которыевсе имеют
значения по умолчанию), называется конструктором по умолчанию. Он вызывается, если
пользователем не указаны значения для инициализации. Например:

1 #include <iostream>
2
3 class Fraction
4 {
5 private:
6 int m_numerator;
7 int m_denominator;
8
9 public:
10 	Fraction() //конструктор по умолчанию
11 	{
12 		m_numerator = 0;
13 		m_denominator = 1;
14 	}
15
16 	int getNumerator() { return m_numerator; }
17 	int getDenominator() { return m_denominator; }
18 	double getValue() { returnstatic_cast<double>(m_numerator) / m_denominator; }
19 };
20
21 int main()
22 {
23  	Fraction drob; // так как нет никаких аргументов, то вызывается конструктор поумолчанию Fraction()
24  	std::cout << drob.getNumerator() << "/" << drob.getDenominator() << '\n';
25
26  	return 0;
27 }

Этот класс содержит дробь в виде отдельных значений типа int. Конструктор по умолчанию
называется Fraction (как и класс). Поскольку мы создали объект класса Fraction без аргументов, то
конструктор по умолчанию сработал сразу же после выделенияпамяти для объекта, и
инициализировал наш объект.

Результат выполнения программы:
0/1

Обратите внимание, наш числитель (m_numerator) и знаменатель (m_denominator) были
инициализированы значениями, которыемы задали в конструкторе по умолчанию! Это настолько
полезная особенность, что почти каждый класс имеетсвой конструктор поумолчанию. Без него
значениями нашего числителя и знаменателя был бы мусор до техпор, пока мы явно не
присвоили бы им нормальные значения.


Конструкторы с параметрами

Хотя конструктор по умолчанию отлично подходит для обеспечения инициализации наших
классов значениями по умолчанию, часто может быть нужно, чтобы экземпляры нашего класса
имели определенные значения, которые мы предостав им позже. К счастью, конструкторы также
могут быть объявлены с параметрами. Вот пример конструктора, который имеет два
целочисленных параметра, которые используются для инициализации числителя и знаменателя:

1 #include <cassert>
2
3 class Fraction
4 {
5 private:
6 int m_numerator;
7 int m_denominator;
8
9 public:
10 Fraction() //конструктор поумолчанию
11 {
12 	m_numerator=0;
13 	m_denominator= 1;
14 }
15
16 // Конструктор с двумя параметрами, один из которых имеет значение по умолчанию
17 Fraction(int numerator, int denominator=1)
18 {
19 	assert(denominator != 0);
20 	m_numerator = numerator;
21 	m_denominator = denominator;
22 }
23
24 	int getNumerator(){ return m_numerator; }
25 	int getDenominator() { return m_denominator; }
26 	double getValue() { returnstatic_cast<double>(m_numerator) /m_denominator;}
27 };

Обратите внимание, теперь у нас есть два конструктора: конструктор по умолчанию, который
будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который
будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно
сосуществовать в одном классе благодаря перегрузке функций. Фактически, вы можете
определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры
(учитывается их количество и тип).
Как использовать конструктор с параметрами? Всё просто! Прямая инициализация:

1 int a(7); // прямая инициализация
2 Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)

Здесь мы инициализировали нашу дробь числами 4 и 5,результат — 4/5 !

В C++11 мы также можем использовать uniform-инициализацию:
1 int a{ 7 }; // uniform-инициализация
2 Fraction drob{4, 5}; // uniform-инициализация, вызывается конструктор Fraction(int, int)

Мы также можем указать только один параметр для конструктора с параметрами, а второе
значение будет значением по умолчанию:

1 Fraction seven(7); // вызывается конструктор Fraction(int,int), второй параметр использует значение 1

Значения по умолчанию для конструкторов работают точно так же, как и для любой другой
функции, поэтому в вышеприведенном примере, когда мы вызываем seven(7), вызывается
Fraction(int,int), второй параметр которого равен1  (значение поу молчанию).

Правило: Используйтеп рямую инициализацию или uniform-инициализацию с объектами
ваших классов.


Копирующая инициализация

Подобно обычным переменным, классы также можно инициализировать, используя копирующую
инициализацию:

1 int a= 7; //копирующая инициализация
2 Fraction eight = Fraction(8); // копирующаяи нициализация,вызывается Fraction(8,1)
3 Fraction nine=9; // копирующая инициализация. Компилятор будет  искать путико нвертации 9 в Fract

Однако рекомендуется избегать этой формы инициализации классов, так как она может быть
менее эффективной. Хотя uniform-инициализация, прямая и копирующая инициализации
работают одинаково с фундаментальными типами данных, с классами это не совсем так (хотя
конечный результат частос овпадает). Мыр ассмотрим этот момент более подробно на следующих
уроках.

Правило:Неиспользуйтекопирующуюинициализациюсобъектамиваших классов.


Уменьшение количества конструкторов

В примере с классом Fraction и двумя конструкторами (по умолчанию и с параметрами),
конструктор по умолчанию на самом деле лишний. Мы моглибы упростить этот класс следующим
образом:

1 #include <cassert>
2
3 class Fraction
4 {
5 private:
6 int m_numerator;
7 int m_denominator;
8
9 public:
10 // Конструктор по умолчанию
11 Fraction(int numerator=0, int denominator=1)
12 {
13 assert(denominator != 0);
14 m_numerator = numerator;
15 m_denominator = denominator;
16 }
17
18 intgetNumerator(){ return m_numerator; }
19 intgetDenominator() { return m_denominator; }
20 double getValue() { returnstatic_cast<double>(m_numerator) /m_denominator;}
21 };

Хотя этот конструктор по-прежнему является конструктором по умолчанию, он теперь определен
таким образом, что может принимать одно или двазначения, предоставленные пользователем:

1 Fraction drob; // вызов Fraction(0, 1)
2 Fraction seven(7); //вызов Fraction(7, 1)
3 Fraction sixTwo(6,2); // вызов Fraction(6,2)

На практике старайтесь сокращать количество конструкторов вашего класса.


Неявно генерируемый конструктор по умолчанию

Если вашкласс неимеет конструкторов, то язык C++ автоматически сгенерирует для вашего
класса открытый конструктор поу молчанию. Его иногда называют неявным конструктором (или
«неявно сгенерированным конструктором»). Рассмотрим следующий класс:

1 classDate
2 {
3 private:
4 int m_day=12;
5 int m_month= 1;
6 int m_year = 2018;
7 };

Уэтого класса нет конструктора, поэтомук омпилятор сгенерирует следующий конструктор:

1 class Date
2 {
3 private:
4 intm_day = 12;
5 intm_month =1;
6 intm_year= 2018;
7
8 public:
9 	Date() // неявно генерируемый конструктор
10 	{
11 	}
12 };

Этот конструктор позволяет создавать объекты класса, но не выполняет их инициализацию и не
присваивает значения членам класса.
Хотя вы неможете увидеть неявно сгенерированный конструктор, но его существование можно
доказать:

1 class Date
2 {
3 private:
4 int m_day = 12;
5 int m_month =1;
6 int m_year= 2018;
7
8 // Не было предоставлено конструктора, поэтому C++ автоматически создаст открытый конструктор
9 };
10
11 int main()
12 {
13 Date date; //вызов неявного конструктора
14
15 return 0;
16 }

Вышеприведенный код скомпилируется, поскольку в объекте date сработает неявный
конструктор (который является открытым). Если ваш класс имеет другие конструкторы, то неявно
генерируемый конструктор создаваться не будет. Например:

1 class Date
2 {
3 private:
4 int m_day = 12;
5 int m_month =1;
6 int m_year= 2018;
7
9 Date(int day,int month, int year) // обычный конструктор (непо умолчанию)
8 public:
10 {
11 m_day = day;
12 m_month = month;
13 m_year = year;
14 }
15
16 // Неявный конструктор не создастся, так как мы уже определили свой конструктор
17 };
18
19 int main()
20 {
21 Date date; // ошибка: Невозможно создать объект, так как конструктор по умолчанию не существует
22 Date today(14, 10,2020); // инициализируем объект today
23
24 return 0;
25 }

Рекомендуется всегда создавать по крайней мере один конструктор в классе. Это позволит вам
контролировать процесс создания объектов вашего класса, и предотвратит возникновение
потенциальных проблем после добавления других конструкторов.

Правило: Создавайте хотя бы один конструктор в классе, даже если этопустой конструктор по умолчанию.


Классы, содержащие другие классы

Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при
создании внешнего класса, для переменных-членов будут вызываться конструкторы по
умолчанию. Это произойдет до того, как тело конструктора выполнится. Это можно
продемонстрировать следующим образом:

1 #include <iostream>
2
3 class A
4 {
5 public:
6 A(){std::cout <<"A\n"; }
7 };
8
9 class B
10 {
11 private:
12 A m_a; // B содержит A,как переменную-член
13
14 public:
15 B(){std::cout <<"B\n"; }
16 };
17
18 int main()
19 {
20 B b;
21 return 0;
22 }

Результат выполнения программы:
A
B

При создании переменной b вызывается конструктор B(). Прежде чем тело конструктора
выполнится, m_a инициализируется, вызывая конструктор по умолчанию класса A. Таким
образом выведется A. Затем управление возвратится обратно к конструктору B, и тело
конструктора B начнет свое выполнение.
Здесь есть смысл, так как конструктор B() может захотеть использовать переменную m_a, поэтому
сначала нужно инициализировать m_a!

Тест

Задание No1

a)Напишите класс Ball, который должен иметь следующие две закрытые переменные-члены со
значениями по умолчанию:

 m_color (Red );
 m_radius(20.0).

В классе Ball должныбыть следующие конструкторы:
 для установления значения только для m_color ;
 дляустановления значения только для m_radius;
 дляустановления значений и для m_radius, и для m_color;
 для установления значений, когда значения не предоставлены вообще.

Не используйте параметры по умолчанию для конструкторов. Напишитееще одну функцию для
вывода цвета (m_color ) и радиуса ( m_radius ) шара (объекта класса Ball).

Следующий кодфункции main():
1 int main()
2 {
3 Ball def;
4 def.print();
5
6 Ball black("black");
7 black.print();
8
9 Ball thirty(30.0);
10 thirty.print();
11
12 Ball blackThirty("black", 30.0);
13 blackThirty.print();
14
15 return 0;
16 }

Должен выдавать следующий результат:
color:red, radius: 20
color: black, radius: 20
color: red, radius:30
color: black, radius: 30

Ответ No 1.а)

b) Теперь обновите ваш код из предыдущего задания с использованием конструкторов с
параметрами по умолчанию. Постарайтесь использовать как можно меньше конструкторов.

Ответ No 1.b)


Задание No 2
Что произойдет, если не объявить конструктор по умолчанию?

Ответ No 2
