Урок No 167. Виртуальные таблицы

Для реализации виртуальных функций язык C++ использует специальную форму позднего связывания — виртуальные
таблицы.

Оглавление:
1. Виртуальные таблицы
2. Как заполняются виртуальные таблицы?
3. Заключение


Виртуальные таблицы

Виртуальная таблица в языке С++ — это таблица поиска функций для выполнения вызовов функций в режиме позднего
(динамического) связывания. Виртуальную таблицу еще называют «vtable», «таблицей виртуальных функций» или
«таблицей виртуальных методов».

Виртуальная таблица на самом деле довольно-таки проста, хотя её сложно описать словами.

Во-первых, любой класс, который использует виртуальные функции (или дочерний класс, родительский класс которого
использует виртуальные функции), имеет свою собственную виртуальную таблицу. Это обычный статический массив, который
создается компилятором во время компиляции. Виртуальная таблица содержит по одной записи на каждую виртуальную
функцию, которая может быть вызвана объектами класса. Каждая запись в этой таблице — это указатель на функцию,
указывающий на наиболее дочерний метод, доступный объекту этого класса.

Во-вторых, компилятор также добавляет скрытый указатель на родительский класс, который мы будем называть
*__vptr. Этот указатель автоматически создается при создании объекта класса и указывает на виртуальную таблицу этого
класса. В отличие от скрытого указателя *this, который фактически является параметром функции, используемым
компилятором для «указания на самого себя», *__vptr является реальным указателем. Следовательно, размер каждого
объекта увеличивается на размер этого указателя. *__vptr также наследуется дочерними классами.
Сейчас вы, скорее всего, немного удивлены и, возможно, задаетесь вопросом: «Как это всё вместе работает?». 
Поэтому давайте рассмотрим следующий простой пример:

1 class Parent
2 {
3 public:
4 	virtual void function1() {};
5 	virtual void function2() {};
6 };
7
8 class C1: public Parent
9 {
10 public:
11 	virtual void function1() {};
12 };
13
14 class C2: public Parent
15 {
16 public:
17 	virtual void function2() {};
18 };

Здесь у нас есть 3 класса. Соответственно, компилятор создаст 3 виртуальные таблицы: одна для Parent, одна для C1 и одна для
C2.
Компилятор также добавит скрытый указатель на главный родительский класс с виртуальными функциями. Хотя компилятор
делает это автоматически, мы покажем,где этот указатель добавляется:

1 class Parent
2 {
3 public:
4 	FunctionPointer *__vptr; // здесь
5 	virtual void function1() {};
6 	virtual void function2() {};
7 };
8
9 class C1: public Parent
10 {
11 public:
12 	virtual void function1() {};
13 };
14
15 class C2: public Parent
16 {
17 public:
18 	virtual void function2() {};
19 };

При создании объектов классов Parent, C1 или C2, *__vptr будет указывать на виртуальную таблицу класса Parent, C1 или C2
(соответственно).


Как заполняются виртуальные таблицы?

В примере, приведенном выше, у нас есть только две виртуальные функции, поэтому каждая виртуальная таблица будет иметь
две записи (одна для function1() и одна для function2()). Помните, что при заполнении виртуальных таблиц выбираются
наиболее дочерние методы, доступ к которым имеют объекты.

Виртуальная таблица для объектов класса Parent проста. Объект класса Parent имеет доступ только к членам класса Parent, он
не имеет доступ к членам классов C1 и C2. Следовательно, запись function1 будет указывать на Parent::function1(), а запись
function2 будет указывать на Parent::function2().

Виртуальная таблица для C1 уже немного сложнее. Объект класса C1 имеет доступ как к членам C1,так и кчленам Parent.
Однако C1 имеет переопределение function1(), что делает C1::function1() более дочерним методом, нежели Parent::function1().
Следовательно, запись function1 будет указывать на C1::function1(). C1 не переопределяет function2(), поэтому запись function2
остается указывать на Parent::function2().

В виртуальной таблице для C2 запись function1 будет указывать на Parent::function1(), а запись function2 будет указывать на
C2::function2().
Смотрим файл /home/kmserg/studying/c++/ravesli/167-virtual-tables/virtual-table.jpg или ниже

              
             ┌───────────────────────────┐
             │  Parent                   │                 ┌─────────────────────┐
             │  *__vptr;─────────────────┼────────────────│ Parent VTable       │
      ┌──────┼─virtual function1(); ←───┼─────────────────┼─virtual function1() │
      │   ┌──┼─virtual function2(); ←───┼─────────────────┼─virtual function2() │
      │   │  └───────────────────────────┘                 └─────────────────────┘
      │   │
      │   └─────────────────────────────────────────┐
      │                                             │
      │      ┌───────────────────────────┐          │
      │      │  C1: public Parent        │          │       ┌───────────────────┐
      │      │  *__vptr; (унаследован)───┼──────────┼──────│С1 VTable          │
      │      │  virtual function1();←────┼──────────┼───────┤virtual function1()│
      │      │                           │          └───────┤virtual function2()│
      │      └───────────────────────────┘                  └───────────────────┘
      └───────────────────────────────────────────────┐
                                                      │
                                                      │
             ┌───────────────────────────┐            │
             │  C2: public Parent        │            │     ┌───────────────────┐
             │  *__vptr; (унаследован)───┼────────────┼────│С2 VTable          │
             │  virtual function2();←────┼─────────┐  └─────┤virtual function1()│
             │                           │         └────────┤virtual function2()│
             └───────────────────────────┘                  └───────────────────┘
                                          



Хотя здесь же можно удивиться во второй раз, всё, на самом деле, очень просто: *__vptr каждого класса указывает на
виртуальную таблицу этого же класса. Записи в виртуальной таблице указывают на наиболее дочерние методы
(переопределения), доступ к которым имеют объекты.

Рассмотрим, что произойдет при создании объекта класса C1:

1 int main()
2 {
3 	C1 c1;
4 }

Поскольку c1 является объектом класса C1, то он имеет свой *__vptr, который указывает на виртуальную таблицу класса C1.
Теперь создадим указатель класса Parent на объект c1:

1 int main()
2 {
3 	C1 c1;
4 	Parent *cPtr = &c1;
5 }

Поскольку cPtr является указателем класса Parent, то он указывает только на часть Parent объекта c1 . 
Однако, *__vptr тоже находится в части Parent, поэтому cPtr имеет доступ к этому указателю.
 
Наконец, cPtr->__vptr будет указывать на виртуальную таблицу C1, поскольку cPtr указываетна объект класса C1! 
Даже если cPtr являетсяуказателем класса Parent, он всё равно имеет доступ к виртуальной таблице C1.

Поэтому, что произойдет, если мы попытаемся вызвать cPtr->function1() ?

1 int main()
2 {
3 	C1 c1;
4 	Parent *cPtr = &c1;
5 	cPtr->function1();
6 }

Во-первых, компилятор распознает, что function1() является виртуальной функцией. Во-вторых, он будет использовать 
cPtr->__vptr для перехода к виртуальной таблице C1. В-третьих, он будет искать, какую версию function1() вызывать
в виртуальной таблице C1. Он найдет C1::function1(). Следовательно, cPtr->function1() будет вызывать C1::function1()!
Теперь вы можете спросить: «А если бы cPtr указывал на объект класса Parent вместо объекта класса C1? 
Вызывал бы он по-прежнему C1::function1()?». 
Ответ: «Нет, не вызывал бы!».

1 int main()
2 {
3 	Parent p;
4 	Parent *pPtr = &p;
5 	pPtr->function1();
6 }

В этом случае, при создании объекта p, *__vptr указывает на виртуальную таблицу класса Parent вместо C1. Следовательно,
pPtr->__vptr также будет указывать на виртуальную таблицу класса Parent. Запись function1() в виртуальной таблице класса
Parent будет указывать на Parent::function1(). Таким образом, pPtr->function1() будет вызывать Parent::function1(), который
является наиболее дочерним методом, доступ к которомуимеет объект p.

С помощью виртуальных таблиц компилятор и программа могут гарантировать, что вызовы функций будут вызывать
соответствующие виртуальные функции/переопределения, даже если вы будете использовать только указатель или ссылку на
родительский класс!

Вызов виртуальной функции происходит медленнее, чем вызов невиртуальной функции из-за следующего:
 Во-первых, мы должны использовать *__vptr для перехода к соответствующей виртуальной таблице.
 Во-вторых, мы должны индексировать виртуальную таблицу, чтобы найти правильную функцию для вызова.
 И толькотеперь мы сможем выполнить вызов функции.

В результате мы делаем 3 операции, чтобы вызвать функцию, в отличие от двух операций для обычного непрямого вызова
функции или одной операции для прямого вызова функции. Однако для современных компьютеров затраченное
дополнительное время не является значительным.

Заключение
Любой класс, который использует виртуальные функции, имеет свой *__vptr, и размер каждого объекта этого класса
увеличивается на размер этого указателя. Виртуальные функции мощные, но цена этому — производительность.
