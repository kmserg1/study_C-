Урок No 120. Деструкторы


На этом уроке мы рассмотрим, что такое деструкторы в языке С++, зачем они нужны, как их использовать и нюансы,
которые могут возникнуть при их использовании.

Оглавление:
1. Деструкторы
2. Имена деструкторов
3. Пример использования деструктора напрактике
4. Выполнение конструкторов и деструкторов
5. Идиома программирования RAII
6. Предупреждение офункции exit()
7. Заключение


Деструкторы

Деструктор — это специальный тип метода класса,к оторый выполняется при удалении объекта класса. Вто время как
конструкторы предназначены для инициализации класса, деструкторы предназначены для очистки памяти после него.

Когда объект автоматически выходит из области видимости или динамически выделенный объект явно удаляется с
помощью ключевого слова delete, вызывается деструктор класса (если он существует) для выполнения необходимой
очистки до того, как объект будет удален из памяти. Для простых классов (тех, которые только инициализируют значения
обычных переменных-членов) деструктор не нужен, так как C++ автоматически выполнит очистку самостоятельно.
Однако, если объект класса содержит любые ресурсы (например, динамически выделенную память или файл/базу данных),
или, если вам необходимо выполнить какие-либо действия до того, как объект будет уничтожен, деструктор является
идеальным решением, поскольку он производит последние действия с объектом перед его окончательным уничтожением.


Имена деструкторов

Так же, как и конструкторы, деструкторы имеют свои правила, которые касаются их имен:
 деструктор должен иметь то же имя, что и класс, со знаком тильда( ~ ) в самом начале;
 деструктор не может принимать аргументы;
 деструктор не имеет типа возврата.

Из второго правила вытекает еще одно правило: для каждого класса может существовать только один деструктор, так как
нет возможности перегрузить деструкторы, как функции, и отличаться друг от друга аргументами они не могут.

Пример использования деструктора на практике
Рассмотрим простой класс с деструктором:

1 #include <iostream>
2 #include <cassert>
3
4 class Massiv
5 {
6 private:
7 	int *m_array;
8 	int m_length;
9
10 public:
11 	Massiv(int length) // конструктор
12 	{
13 		assert(length > 0);
14
15 		m_array = new int[length];
16 		m_length = length;
17 	}
18 
19 	~Massiv() // деструктор
20 	{
21 		// Динамически удаляем массив, который выделили ранее
22 		delete[] m_array ;
23 	}
24
25 	void setValue(int index, int value) { m_array[index] = value; }
26 	int getValue(int index) { return m_array[index]; }
27
28 	int getLength() { return m_length; }
29 };
30
31 int main()
32 {
33 	Massiv arr(15); // выделяем 15 целочисленных значений
34 	for (int count=0; count < 15; ++count)
35 		arr.setValue(count, count+1);
36
37 	std::cout << "The value of element 7 is " << arr.getValue(7);
38
39 	return 0;
40 } // объект arr удаляется здесь, поэтому деструктор ~Massiv() вызывается тоже здесь

Результат выполнения программы:
The value of element 7 is 8

В первой строке функции main() мы создаем новый объект класса Massiv с именем arr и передаем длину (length) 15. Это
приводит к вызову конструктора, который динамически выделяет память для массива класса ( m_array ). Мы должны здесь
использовать динамическое выделение, поскольку на момент компиляции мы не знаем длину массива (это значениенам
передает caller).
В конце функции main() объект arr выходит из области видимости. Это приводит к вызову деструктора ~Massiv() и к
удалению массива, который мы выделили ранее в конструкторе!


Выполнение конструкторов и деструкторов

Как мыуже знаем, конструктор вызывается при создании объекта, а деструктор — при его уничтожении. В следующем
примере мы будем использовать стейтменты с cout внутри конструктора и деструктора для отображения их времени
выполнения:

1 #include <iostream>
2
3 class Another
4 {
5 private:
6 	int m_nID;
7
8 public:
9 	Another(int nID)
10 	{
11 		std::cout << "Constructing Another " << nID << '\n';
12 		m_nID = nID;
13 	}
14
15 	~Another()
16 	{
17 		std::cout << "Destructing Another " << m_nID << '\n';
18 	}
19
20 	int getID() { return m_nID; }
21 };
22
23 int main()
24 {
25 	// Выделяем объект класса Another из стека
26 	Another object(1);
27 	std::cout << object.getID() << '\n';
28
29 	// Выделяем объект класса Another динамически из кучи
30 	Another *pObject = new Another(2);
31 	std::cout << pObject->getID() << '\n';
32 	delete pObject;
33
34 	return 0;
35 } // объект object выходит из области видимости здесь

Результат выполнения программы:
Constructing Another 1
1
Constructing Another 2
2
Destructing Another 2
Destructing Another 1

Обратите внимание, Another 1 уничтожается после Another 2 , так как мы удалили pObject до завершения выполнения
функции main(), тогда как объект object не был удален до конца main().


Идиома программирования RAII

Идиома RAII (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация») — это идиома объектно-
ориентированного программирования, при которой использование ресурсов привязывается к времени жизни объектов с
автоматической продолжительностью жизни. В языке C++ идиома RAII реализуется через классыс конструкторами и
деструкторами. Ресурс (например, память, файл или база данных) обычно приобретается в конструкторе объекта (хотя этот
ресурс может быть получен и после создания объекта, если в этом есть смысл). Затем этот ресурс можно использовать, пока
объект жив. Ресурс освобождается в деструкторе при уничтожении объекта. Основным преимуществом RAII является то,
что это помогает предотвратить утечку ресурсов (например, памяти, которая не была освобождена), так как все объекты,
содержащие ресурсы, автоматически очищаются.

В рамках идиомы программирования RAII объекты, располагающие ресурсами, не должны быть динамически
выделенными, так как деструкторы вызываются только при уничтожении объектов. Для объектов, выделенных из стека,
это происходит автоматически, когда объект выходит из области видимости, поэтому нет необходимости беспокоиться о
том, что ресурс в конечном итоге не будет очищен. Однако за очистку динамически выделенных объектов, которые
выделяются из кучи, уже пользователь несет ответственность: если он забыл её выполнить, деструктор вызываться не
будет, и память как для объекта класса, так и для управляемого ресурса будет потеряна — произойдет утечка памяти!
Класс Massiv из программы, приведенной вначале этого урока, является примером класса, который реализует принципы
RAII: выделение в конструкторе, освобождение в деструкторе. std::string и std::vector — это примеры классов из
Стандартной библиотеки С++, которые следуют принципам RAII: динамическая память выделяется при инициализации и
автоматически освобождается при уничтожении.

Правило: Используйте идиому программирования RAII и не выделяйте объекты вашего класса динамически.

Предупреждение о функции exit()
Если вы используете функцию exit(), то ваша программа завершится, и никакие деструкторы не будут вызваны. Будьте
осторожны, если в таком случае вы полагаетесь на свои деструкторы для выполнения необходимой работы по очистке
(например, перед тем, как выйти, вы записываете что-нибудьв лог-файл или в базу данных).


Заключение

Используя конструкторы и деструкторы, ваши классы могут выполнять инициализацию и очистку после себя автоматически
без вашего участия! Это уменьшает вероятность возникновения ошибок и упрощает процесс использования классов.
