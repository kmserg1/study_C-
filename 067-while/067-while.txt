Урок No 67. Цикл while

Оглавление:
1.Цикл while
2.Бесконечные циклы
4.Итерации
3.Счетчик цикла while
5.Вложенные циклы while
6.Тест      


Цикл while

Цикл while является самым простым из четырех циклов, которые есть в языке C++.
Он очень похож на ветвление if/else:

while(условие)
 тело цикла;

Цикл while объявляется с использованием ключевого слова while. В начале цикла
обрабатывается условие. Если его значением является true (любое ненулевое значение),
то тогда выполняется тело цикла.

Однако, в отличие отоператора if, после завершения выполнения тела цикла управление возвращается  обратно к while
и процесс проверки условия повторяется. Если условие опять является true, то тогда тело цикла выполняется еще раз.
Например, следующая программа выводит все числаот 0 до 9:

1 #include <iostream>
2
3 int main()
4 {
5  int count = 0;    
6  while (count<10)
7 	{ 
8 	 std::cout << count <<  " ";
9 	 ++count;
10  	}
11  std::cout<<"done!";
12  
13 return 0;
14 }

Результат выполнения программы:
0 1 2 3 4 5 6 7 8 9 done!

Рассмотрим детально эту программу. 
Во-первых, инициализируется переменная: int count = 0;. Условие 0<10 имеет
значение true, поэтому выполняется тело цикла. В первом стейтменте мы выводим 0, а во втором — выполняем
инкремент переменной count.
Затем управление возвращается к началу цикла while для повторной проверки условия.
Условие 1< 10 имеет значение true, поэтому тело цикла выполняется еще раз.
Тело цикла будет повторно выполняться до тех пор, пока переменная count не будет равна 10;
только в том случае, когда результат условия 10 < 10 будет false, цикл завершится.

Тело цикла while может и вообще не выполняться, например

1 #include<iostream>
2
3 int main()
4 {
5 int count=15;
6 while (count<10)
7 {
8 	std::cout << count <<  " ";
9	++count;
10 }
11 std::cout<<"done!";
12
13 return 0;
14 }

Условие 15 < 10 сразу принимает значение false, и тело цикла пропускается. Единственное, что выведет эта программа:
done!


Бесконечные циклы

С другой стороны, если условие цикла всегда принимает значение true, то и сам цикл будет выполняться бесконечно.
Этон азывается бесконечным циклом. Например:

1 #include <iostream>
2 
3 int main()
4 {
5     int count = 0;
6     while (count < 10) // это условие никогда не будет false
7         std::cout << count << " "; // поэтому эта строка будет выполняться постоянно
8 
9     return 0; // а эта строка никогда не выполнится 
10 }

Поскольку переменная count не увеличивается на единицу в этой программе, то условие count <10 всегдабудет true.

Следовательно, цикл никогда не будет завершен, и программа будет постоянно выводить 00000....
Мы можем преднамеренно объявить бесконечный циклследующим образом:

1 while (1) // или while (true)
2 {
3  // Этот цикл будет выполняться бесконечно 
4 }

Единственный способ выйти из бесконечного цикла — использовать операторы return, break, goto, выбросить
исключение или воспользоваться функцией exit().

Программы, которые работают до тех пор, пока пользователь не решит остановить их, иногда преднамеренно используют
бесконечные циклы вместе с операторами return, break или функцией exit() для завершения цикла.
Распространена такая практика в серверных веб-приложениях, которые работают непрерывно и постоянно обслуживают веб-запросы.


Счетчик цикла while

Часто нам нужно будет, чтобы цикл выполнялся определенное количество раз. Для этого обычно используется 
переменная в виде счетчика цикла. Счетчик цикла — это целочисленная переменная, которая объявляется с 
единственнойцелью: считать, сколько раз выполнился цикл.
В вышеприведенных примерах переменная count является счетчиком цикла.

Счетчикам цикла часто дают простые имена, такие как i,j или k. Однако в этих именах есть одна серьезная проблема.
Если вы захотите узнать, где в вашей программе используется счетчик цикла и воспользуетесь функцией поиска символов
i, j или k, то в результате получите половину своей программы, так как i, j или k используются во многих именах.
Следовательно, лучше использовать iii, jjj или kkk в качестве имен для счетчиков. Они более уникальны, их
значительно проще найти, и они выделяются в коде. А еще лучше использовать «реальные» имена для переменных,
например, count или любое другое имя, которое предоставляет контекст использования этой переменной.

Также для счетчиков цикла лучше использовать тип signed int. Использование unsigned int может привести к неожиданным
результатам. Например:
1 #include <iostream>
2
3 int main()
4 {
5 unsigned int count = 10;
6 
7  //Считаем от 10 к 0
8  while (count >= 0)
9 	{                       
10 	if(count==0)
11 		std::cout << "blastoff!";
12 	else
13      	std::cout << count << "";
14	--count;
15 	}
16
17 return 0;
18 }

Взгляните на эту программу еще раз и постарайтесь найти ошибку.

Оказывается, эта программа представляет собой бесконечный цикл. Она начинается с вывода 10 9 8 7 6 5 4 3 2 1 blastoff!, 
как и предполагалось, но затем «сходит с рельсов» и начинает отсчет с 4294967295. Почему? 
Потому что условие цикла count >= 0 никогда не будет ложным! Когда count = 0, то и условие 0 >= 0 имеет значение true, выводится blastoff, 
а затем выполняется декремент переменной count, происходит переполнение и значением переменной становится 4294967295. 
И так как условие 4294967295 >= 0 является истинным, то программа продолжает свое выполнение. 
А поскольку счетчик цикла является типа unsigned, то он никогда не сможет быть отрицательным, а так как он никогда не сможет быть 
отрицательным, то цикл никогда не завершится.

Правило: Всегда используйте тип signed int для счетчиков цикла.


Итерации

Каждое выполнение цикла называется итерацией (или «повтором»).
Поскольку тело цикла обычно является блоком, и поскольку этот блок выполняется по новой с каждым 
повтором, то любые переменные, объявленные внутри тела цикла, создаются, а затеми уничтожаются по новой. 
В следующем примере переменная z создается и уничтожается 6 раз:

1 #include <iostream>
2
3 intmain()
4 {
5 int count = 1;
6 int result = 0; //переменная result определена здесь, поскольку она нам понадобится позже (вне тела цикла)
7
8 while (count<= 6) // итераций будет 6
9 	{
10  	int z; // z создается здесьпо новой с каждой итерацией
11
12  	std::cout << "Enter integer #" << count << ':';
13 	std::cin >> z;
14	
15	result +=z;   	
16 
17 	// Увеличиваем значение счетчика цикла на единицу
18	++count;
19 } // z уничтожается здесь по новой с каждой итерацией
20
21  std::cout << "The sum of all numbers entered is: "<< result;
22
23 return 0;
24 }


Для фундаментальных типов переменных это нормально. Для нефундаментальных типов переменных (таких как структуры или 
классы) это может сказаться на производительности. Следовательно, нефундаментальные типы переменных лучше определять перед циклом.

Обратите внимание, переменная count объявлена вне тела цикла. Это важно и необходимо, поскольку нам нужно, чтобы значение 
переменной сохранялось на протяжении всех итераций (не уничтожалось по новой с каждым повтором цикла).

Иногда нам может понадобиться выполнить что-то при достижении определенного количества итераций, например, вставить символ 
новой строки. Это легко осуществить, используя оператор остатка от деления со счетчиком цикла:

1 #include <iostream>
2  
3 int main()
4 {
5     int count = 1;
6     while (count <= 50)
7     {
8         // Выводим числа до 10 (перед каждым числом добавляем 0)
9         if (count < 10)
10            std::cout << "0" << count << " ";
11        else
12            std::cout << count << " "; // выводим остальные числа 
13 
14        // Если счетчик цикла делится на 10 без остатка, то тогда вставляем символ новой строки
15        if (count % 10 == 0)
16            std::cout << "\n";
17 
18        // Увеличиваем значение счетчика цикла на единицу 
19        ++count;
20    }
21 
22    return 0;
23 }

Результат выполнения программы:

01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50


Вложенные циклы while

Также одни циклы while могут быть вложены внутри других циклов while. В следующем примере внутренний 
и внешний циклы имеют свои собственные счетчики. Однако, обратите внимание, условие внутреннего 
цикла использует счетчик внешнего цикла!

1 #include <iostream>
2 
3 int main()
4 {
5     int outer = 1;
6     while (outer <= 5)
7    {
8         int inner = 1;
9         while (inner <= outer)
10             std::cout << inner++ << " ";
11  
12          // Вставляем символ новой строки в конце каждого ряда
13         std::cout << "\n";
14         ++outer;
15     }
16  
17     return 0;
18 }
Результат выполнения программы:

1
1 2
1 2 3
1 2 3 4
1 2 3 4 5


Тест

Задание No 1
Почему в программе, приведенной выше, переменная inner объявлена внутриблока while, а не сразу после объявления в 
переменной outer (вне блока while)?

Можно и вне блока while, толко в начале блока присваивать ей значение 1.

Ответ No 1
Переменная inner объявлена внутри блока while так, чтобы она была восстановлена (и повторно инициализирована значением 1) 
каждый раз, когда выполняется внешний цикл. Если бы переменная inner была объявлена вне внешнего цикла while, то её 
значение никогда не было бы сброшено до 1, или нам бы пришлось это сделать самостоятельно с помощью операции присваивания. 
Кроме того, поскольку переменная inner используется только внутри внешнего цикла while, то имеет смысл объявить её именно там. 
Помните, что переменные нужно объявлять максимально близко к их первому использованию!


Задание No 2

Напишите программу, которая выводит буквы английского алфавитаот a до z вместе с кодами из ASCII-таблицы.
Подсказка: Чтобы выводить символы как целые числа — используйте оператор static_cast.

#include <iostream>

int main(){
char symb{'a'};
while (symb<='z'){
	std::cout << symb << '\t' << static_cast<int>(symb)<< '\n';
	++symb;
	}
return 0;
}

ОтветNo2
#include <iostream>
 
int main()
{
    char mychar = 'a';
    while (mychar <= 'z')
    {
        std::cout << mychar  << " " << static_cast<int>(mychar) << "\n";
        ++mychar;
    }
 
    return 0;
}


ЗаданиеNo3
Измените программу из последнего подраздела «Вложенные циклы while» так, чтобы она выводила следующее:
5 4 3 2 1
4 3 2 1
3 2 1
2 1
1
 

#include <iostream>
 
 int main()
 {
     int outer = 5;
     
     while (outer > 0)
	    {
        	 int inner = 1;
	         while (inner <= outer){
        	    std::cout << outer-inner+1 << " ";
                ++inner;
             }
	         // new string here
        	 std::cout << "\n";
	         --outer;
	     }
  
     return 0;
 }


Ответ No 3

#include <iostream>
 
int main()
{
    int outer = 5;
    while (outer >= 1)
    {
        int inner = 5;
        while (inner >= 1)
            std::cout << inner-- << " ";
 
        // Вставляем символ новой строки в конце каждого ряда
        std::cout << "\n";
        --outer;
        }
 
    return 0;
}


Задание No 4
Теперь сделайте так, чтобы цифры выводились следующим образом (используя программу из предыдущего задания):
        1
      2 1
    3 2 1
  4 3 2 1
5 4 3 2 1


Подсказка: Разберитесь сначала, как вывести числа следующим образом:

X X X X 1
X X X 2 1
X X 3 2 1
X 4 3 2 1
5 4 3 2 1


#include <iostream>
 
int main()
{
    int outer = 5;
    while (outer >= 1)
    {
        int inner = 5;
        while (inner >= 1){
            if(6-outer<inner)
                std::cout << ' ' << ' ';
            else
                std::cout << inner << ' ';
            --inner;
            }
        // Вставляем символ новой строки в конце каждого ряда
        std::cout << "\n";
        --outer;
        }
 
    return 0;
}


Ответ No 4

#include <iostream>
 
int main()
{
	// Цикл с 1 до 5
	int outer = 1;
 
	while (outer <= 5)
	{
		// Числа в рядах появляются в порядке убывания, поэтому цикл начинаем с 5 и до 1
		int inner = 5;
 
		while (inner >= 1)
		{
			// Первое число в любом ряде совпадает с номером этого ряда,
			// поэтому числа должны выводиться только если <= номера ряда (в противном случае, выводится пробел)
			if (inner <= outer)
				std::cout << inner << " ";
			else
				std::cout << "  "; // вставляем дополнительные пробелы
 
			--inner;
		}

