Урок No70. Операторы break и continue

Хотя вы ужевидели оператор break в связке с оператором switch, все же он заслуживает большего внимания, поскольку
может использоваться и с циклами. Оператор break приводит к завершению выполнения циклов do, for или while.

Оглавление:
1. break и switch
2. break и циклы
3. break и return
4. Оператор continue
5. break и continue

break и switch

В контексте оператора switch оператор break обычно используется в конце каждого кейса для его завершения
(предотвращая fall-through):

1 switch (op)
2 {
3 case '+':
4 	doAddition(a, b);
5 	break;
6 case '-':
7 	doSubtraction(a, b);
8 	break;
9 case '*':
10 	doMultiplication(a, b);
11 	break;
12 case '/':
13 	doDivision(a, b);
14 	break;
15 }


break и циклы

В контексте циклов оператор break используется для завершения работы цикла раньше времени:

1  #include <iostream>
2
3  int main()
4  {
5  	int sum = 0;
6 
7 	// Разрешаем пользователю ввести до 10 чисел
8 	for (int count=0; count < 10; ++count)
9 	{
10 		std::cout << "Enter a number to add, or 0 to exit: ";
11 		int val;
12 		std::cin >> val;
13
14 		// Выходим из цикла, если пользователь введет 0
15 		if (val == 0)
16 			break;
17
18 		// В противном случае, добавляем число к общей сумме
19 		sum += val;
20 	}
21
22 	std::cout << "The sum of all the numbers you entered is " << sum << "\n";
23
24 	return 0;
25 }

Эта программа позволяет пользователю ввести до 10 чисел и в конце подсчитывает их сумму. Если пользователь 
введет 0, то выполнится break и цикл завершится (не важно,сколько чисел в этот момент успел ввести пользователь).
Обратите внимание, оператор break может использоваться и для выхода из бесконечного цикла:

1  #include <iostream>
2
3  int main()
4  {
5  while (true) // бесконечный цикл
6  {
7  std::cout << "Enter 0 to exit or anything else to continue: ";
8  int val;
9  std::cin >> val;
10
11 // Выходим из цикла, если пользователь ввел 0
12 if (val == 0)
13 break;
14 }
15
16 std::cout << "We're out!\n";
17
18 return 0;
19 }


break и return

Новички часто путают или не понимают разницы между операторами break и return. Оператор break завершает работу
switch или цикла, а выполнение кода продолжается с первого стейтмента, который находитсясразу же после этого switch
или цикла. Оператор return завершает выполнение всей функции, в которой находится цикл, а выполнение продолжается в
точке после вызова функции:

1  #include <iostream>
2
3 int breakOrReturn()
4 {
5 	while (true) // бесконечный цикл
6 	{
7 		std::cout << "Enter 'b' to break or 'r' to return: ";
8 		char sm;
9 		std::cin >> sm;
10
11 		if (sm == 'b')
12 		break; // выполнение кода продолжится с первого стейтмента после цикла
13
14 		if (sm == 'r')
15 		return 1; // выполнение return приведет к тому, что управление сразу возвратится в caller (в этом случае, в фун
16 	}
17
18 	// Использование оператора break приведет к тому, что выполнение цикла продолжится здесь
19
20 	std::cout << "We broke out of the loop\n";
21
22 	return 0;
23 }
24
25 int main()
26 {
27 	int returnValue = breakOrReturn();
28 	std::cout << "Function breakOrContinue returned " << returnValue << '\n';
29
30 	return 0;
31 }


Оператор continue

Оператор continue позволяет сразу перейти в конец тела цикла, пропуская весь код, который находится под ним. Это
полезно в тех случаях, когдамы хотим завершить текущую итерацию раньше времени. Например:

1 #include <iostream>
2
3 int main()
4 {
5	 for (int count = 0; count < 20; ++count)
6	 {
7	 	// Если число делится нацело на 4, то пропускаем весь код в этой итерации после continue
8	 	if ((count % 4) == 0)
9			continue; // пропускаем всё и переходим в конец тела цикла
10
11 		// Если число не делится нацело на 4, то выполнение кода продолжается
12      	std::cout << count << std::endl;
13
14 		// Точка выполнения после оператора continue перемещается сюда
15	 }
16
17 return 0;
18 }

Этапрограмма выведет всечисла от 0 до 19, которые не делятся нацело на 4.
В случае с циклом for часть инкремента/декремента счетчика по-прежнему выполняется даже после выполнения continue
(так как инкремент/декремент происходит вне тела цикла).

Будьте осторожны при использовании оператора continue с циклами while или do while. Поскольку в этих циклах
инкремент счетчиков выполняется непосредственно в теле цикла, то использование continue может привести к тому, что
цикл станет бесконечным! Например:

1 #include <iostream>
2
3 int main()
4 {
5 int count(0);
6 while (count < 10)
7 {
8 if (count == 5)
9 continue; // переходим в конец тела цикла
10 std::cout << count << " ";
11 ++count;
12
13 // Точка выполнения после оператора continue перемещается сюда
14 }
15
16 return 0;
17 }

Предполагается, чтопрограмма выведетвсечислаот 0 до 9, за исключением 5. Но на самом деле:
0 1 2 3 4
А затем циклстанет бесконечным. Когда значением count становится 5, то условие оператора if станет true, затем
выполнится continue и мы, минуя вывод числа и инкремент счетчика, перейдем к следующей итерации. Переменная count
так ине увеличится. Как результат, в следующей итерации переменная count по-прежнему останется со значением 5 , а
оператор if по-прежнему останется true, и цикл станет бесконечным.

А вот правильное решение, но с использованием цикла do while:

1 #include <iostream>
2
3 int main()
4 {
5 int count(0);
6 do
7 {
8 if (count == 5)
9 continue; // переходим в конец тела цикла
10 std::cout << count << " ";
11
12 // Точка выполнения после оператора continue перемещается сюда
13 } while (++count < 10); // этот код выполняется, так как он находится вне тела цикла
14
15 return 0;
16 }

Результат выполнения программы:
0 1 2 3 4 6 7 8 9


break и continue

Многие учебники рекомендуют не использовать операторы break и continue, поскольку они приводят к произвольному
перемещению точки выполнения программы по всему коду, что усложняет понимание и следование логике выполнения
такого кода.
Тем не менее, разумное использование операторов break и continue может улучшить читабельность циклов в программе,
уменьшив при этомколичество вложенных блоков и необходимость наличия сложной логики выполнения циклов.
Например, рассмотрим следующую программу:

1 #include <iostream>
2
3 int main()
4 {
5 	int count(0); // считаем количество итераций цикла
6 	bool exitLoop(false); // контролируем завершение выполнения цикла
7 	while (!exitLoop)
8 	{
9 		std::cout << "Enter 'e' to exit this loop or any other key to continue: ";
10 		char sm;
11  		std::cin >> sm;
12
13  		if (sm == 'e')
14  			exitLoop = true;
15  		else
16  		{
17 	 		++count;
18  			std::cout << "We've iterated " << count << " times\n";
19  		}
20 	}
21
22 	return 0;
23 }

Эта программа использует логическую переменную для выхода из цикла, а также вложенный блок, который запускается
только в том случае, если пользователь не использует символ выхода.
А вот более читабельная версия, но с использованием оператора break:

1 #include <iostream>
2
3 int main()
4 {
5 	int count(0); // считаем количество итераций цикла
6 	while (true) // выполнение цикла продолжается, если его не завершит пользователь
7 	{
8 		std::cout << "Enter 'e' to exit this loop or any other key to continue: ";
9 		char sm;
10 		std::cin >> sm;
11
12 		if (sm == 'e')
13 		break;
14
15 		++count;
16 		std::cout << "We've iterated " << count << " times\n";
17 	}
18
19 	return 0;
20 }

Здесь (с одним оператором break) мы избежали использования как логической переменной (а также понимания того, зачем
она и где используется), так и оператора else с вложенным блоком.
Уменьшение количества используемых переменных и вложенных блоков улучшают читабельность и понимание кода
намного больше, чем операторы break или continue могут нанести вред. По этой причине считается приемлемым их
разумное использование.