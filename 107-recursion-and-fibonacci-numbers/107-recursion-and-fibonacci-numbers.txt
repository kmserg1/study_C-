Урок No 107. Рекурсия и Числа Фибоначчи

На этом уроке мы рассмотрим, что такое рекурсия в языке C++ и зачем её использовать, а также последовательность
Фибоначчи и факториал целого числа.

Оглавление:
1. Рекурсия
2. Условие завершения рекурсии
3. Рекурсивные алгоритмы
4. Числа Фибоначчи
5. Рекурсия vs. Итерации
6. Тест


Рекурсия

Рекурсивная функция (или просто «рекурсия») в языке C++ — это функция,к оторая вызывает сама себя. Например:

1 #include <iostream>
3 void countOut(int count)
2
4 {
5 std::cout<< "push"<< count<< '\n';
6 countOut(count-1); // функция countOut() вызывает рекурсивно сама себя
7 }
8
9 int main()
10 {
11 countOut(4);
12
13  return0;
14 }

При вызове функции countOut(4) на экран выведется push 4 , а затем вызывается countOut(3). 
countOut(3) выведет push 3 и вызывает countOut(2). 
Последовательность вызова countOut(n) других функций countOut(n-1) повторяется бесконечное
количество раз (аналог бесконечного цикла). Попробуйте запустить у себя.

На уроке о стеке и куче в С++ мы узнали, что при каждом вызове функции, определенные данные помещаются в стек
вызовов. Поскольку функция countOut() никогда ничего не возвращает (она просто снова вызывает countOut()), то данные
этой функции никогда не вытягиваются из стека! Следовательно, в какой-то момент, память стека закончится и произойдет
переполнение стека.


Условие завершения рекурсии

Рекурсивные вызовы функций работают точно так же, как и обычные вызовы функций. Однако, программа, приведенная
выше, иллюстрирует наиболее важное отличие простых функций от рекурсивных: вы должны указать условие завершения
рекурсии, в противном случае — функция будетвыполняться «бесконечно» (фактически до тех пор, пока не закончится
память в стеке вызовов).

Условие завершения рекурсии — это условие, которое, при его выполнении, остановит вызов рекурсивной функции
самой себя. В этом условии обычно используется оператор if.
Вот пример функции, приведенной выше, но уже с условием завершения рекурсии (и еще с одним дополнительным
выводом текста):

1 #include <iostream>
2
3 void countOut(int count)
4 {
5 std::cout<< "push"<< count<< '\n';
6
7 if(count>1) // условие завершения
8 countOut(count-1);
9
10 std::cout << "pop " << count <<'\n';
11 }
12
13 int main()
14 {
15  countOut(4);
16  return 0;
17 }

Когда мы запустим эту программу, то countOut() начнет выводить:
push 4
push 3
push 2
push 1

Если сейчас посмотреть на стеквызовов, то увидим следующее:
countOut(1)
countOut(2)
countOut(3)
countOut(4)
main()

Из-за условия завершения, countOut(1) не вызовет countOut(0): условие if не выполнится, и поэтому выведется pop 1 и
countOut(1) завершит свое выполнение. На этом этапе countOut(1) вытягивается из стека, и управление возвращается к
countOut(2). countOut(2) возобновляет выполнение в точке после вызова countOut(1), и поэтому выведется pop 2, а затем
countOut(2) завершится. Рекурсивные вызовы функций countOut() постепенно вытягиваются из стека дотех пор, пока не
будут удалены все экземпляры countOut().

Таким образом, результат выполнения программы, приведенной выше:
push 4
push 3
push 2
push 1
pop 1
pop 2
pop 3
pop 4

Стоит отметить, что push выводится в порядкеубывания, а pop — в порядке возрастания. Дело в том,что push
выводится до вызова рекурсивной функции, а pop выполняется (выводится) после вызова рекурсивной функции, когда все
экземпляры countOut()в ытягиваются из стека (это происходит в порядке, обратном тому, в котором эти экземпляры были
введены в стек).
Теперь, когда мы обсудили основной механизм вызова рекурсивных функций, давайте взглянем на несколько другой тип
рекурсии, который более распространен:

1 // Возвращаем сумму всех чисел между 1 и value
2 int sumCount(int value)
3 {
4 if(value<= 0)
5 	return 0; // базовый случай (условие завершения)
6 elseif (value == 1)
7 	return 1; // базовый случай (условие завершения)
8 else
9 return sumCount(value -1) + value; //рекурсивный вызов функци
10 }

Рассмотреть рекурсию с первого взгляданакод не так уж и легко. Лучшим вариантом будет посмотреть, что произойдет
при вызове рекурсивной функции с определенным значением. Например, посмотрим, что произойдет при вызове
вышеприведенной функциис value = 4 :

sumCount(4). 4 > 1, поэтому возвращается sumCount(3) + 4
sumCount(2). 2 > 1, поэтому возвращается sumCount(1) + 2
sumCount(3). 3 > 1, поэтому возвращается sumCount(2) + 3
sumCount(1). 1 = 1, поэтому возвращается 1. Это условие завершения рекурсии

Теперь посмотрим на стек вызовов:
sumCount(1)возвращает 1
sumCount(2) возвращает sumCount(1) + 2, т.е. 1 + 2 = 3
sumCount(3) возвращает sumCount(2) + 3, т.е. 3 + 3 = 6
sumCount(4) возвращает sumCount(3) + 4, т.е. 6 + 4 = 10

На этом этапе уже легче увидеть,что мы просто добавляем числа между 1 и значением, которое предоставил caller. На
практике рекомендуется указывать комментарии возле рекурсивных функций, дабы облегчить жизнь не только себе, но,
возможно, и другим людям, которые будут смотреть ваш код.


Рекурсивные алгоритмы

Рекурсивные функции обычно решают проблему, с начала найдя решение для подмножеств проблемы (рекурсивно), а затем
модифицируя это «подрешение», дабы добраться уже до верного решения. В вышеприведенном примере, алгоритм
sumCount(value) сначала решает sumCount(value-1), а затем добавляет значение value, чтобы найти решение для
sumCount(value).

Во многих рекурсивных алгоритмах некоторые данные ввода производят предсказуемые данные вывода. Например,
sumCount(1) имеет предсказуемый вывод 1 (вы можете легко это вычислить и проверить самостоятельно). Случай, когда
алгоритм при определенных данных ввода производит предсказуемые данныев ывода, называется базовым случаем.
Базовые случаи работают как условия для завершения выполнения алгоритма. Их часто можно идентифицировать,
рассматривая результаты вывода для следующих значений ввода: 0, 1, « » или null.


Числа Фибоначчи
Одним из наиболее известных математических рекурсивных алгоритмов является последовательность Фибоначчи.
Последовательность Фибоначчи можно увидеть даже в природе: ветвление деревьев, спираль ракушек, плоды ананаса,
разворачивающийся папоротник и т.д.

Спираль Фибоначчи выглядит следующим образом:

См. SpiralFibonacci.jpg



Каждое из чисел Фибоначчи — это длина стороны квадрата, в которой находится данное число. Математически числа
Фибоначчи определяются следующим образом:
F(n) = 0, если n = 0
F(1) = 1, если n = 1
F(n) = F(n-1) + F(n-2), если n >1

Следовательно, довольно просто написать рекурсивную функцию для вычисления n-го числа Фибоначчи:

1 #include <iostream>
2
3 int fibonacci(intnumber)
4 {
5 if(number ==0)
6 return 0; // базовый случай (условие завершения)
7 if(number ==1)
8 	return 1; // базовый случай (условие завершения)
9 return fibonacci(number-1) + fibonacci(number-2);
10 }
11
12 // Выводим первые 13 чисел Фибоначчи
13 int main()
14 {
15  for (int count=0; count < 13;++count)
16  	std::cout << fibonacci(count) << " ";
17
18 return 0;
19 }

Результат выполнения программы:
0 1 1 2 3 5 8 13 21 34 55 89 144

Заметили? Это те же числа, что и в спирали Фибоначчи.


Рекурсия vs. Итерации

Наиболее популярный вопрос, который задают о рекурсивных функциях: «Зачем использовать рекурсивную функцию, если
задание можно выполнить и спомощью итераций (используя цикл for или цикл while)?». Оказывается, вы всегда можете
решить рекурсивную проблему итеративно. Однако, для нетривиальных случаев, рекурсивная версия часто бывает
намного проще как для написания, так и для чтения. Например, функцию вычисления n-го числа Фибоначчи можно
написать и сп омощью итераций, ноэто будет сложнее! (Попробуйте!)

Итеративные функции( те, которые используют циклы for или while) почти всегда более эффективны, чем их рекурсивные
аналоги. Это связано с тем, что каждый раз, при вызове функции, расходуется определенное количество ресурсов, которое
тратится на добавление и вытягивание фреймов из стека. Итеративные функции расходуют намного меньше этих ресурсов.
Это не значит, что итеративные функции всегда являются лучшим вариантом. Иногда рекурсивная реализация может быть
чище и проще, а некоторые дополнительные расходы могут быть более чем оправданы, сведя к минимуму трудности при
будущей поддержке кода, особенно, если алгоритм не требует слишком много времени для поиска решения.

В общем, рекурсия является хорошим выбором, если выполняется большинство из следующих утверждений:
 рекурсивный код намного проще реализовать;
 глубина рекурсии может быть ограничена;
 итеративная версия алгоритма требует управления стеком данных;
 это не критическая часть кода, которая напрямую влияет на производительность программы.

Совет: Если рекурсивный алгоритм проще реализовать, то имеет смысл начать с рекурсии, а затем уже
оптимизировать код в итеративный алгоритм.

Правило: Рекомендуется использовать итерацию, вместо рекурсии, но в тех случаях, когда это действительно
практичнее.


Тест

Задание No 1

Факториал целого числа N определяется как умножение всех чисел между 1 и N (0!=1).
Напишите рекурсивную функцию factorial(), которая возвращает факториал ввода. 
Протестируйте её с помощью первых 8 чисел.

Подсказка: Помните, что x * y = y * x, поэтому умножение всех чисел между 1 и N — это то же самое, что и
умножение всех чисел между N и 1.

#include <iostream>

int factorial(int n){
	    return ((n>1) ? factorial(n-1)*n : n);
}

int main(){
	int n{8};
	std::cout << factorial(n)<<std::endl;
}



Ответ No 1


#include <iostream>
 
int factorial(int n)
{
	if (n < 1)
		return 1;
	else
		return factorial(n - 1) * n;
}
 
int main()
{
	for (int count = 0; count < 8; ++count)
		std::cout << factorial(count) << '\n';
}




Задание No 2

Напишите рекурсивную функцию, которая принимает целое число в качестве входных данных и возвращает сумму всех
чисел этого значения (например, 482 = 4 + 8 + 2 = 14). Протестируйте вашу программу, используя число 83569
(результатом должнобыть 31).

// sum all figures of noumber

#include <iostream>

int sumFigures(int n){
int sum {0};
if(n>0)
    sum=n%10+sumFigures(n/10);
return sum;
}

int main(){
	int inp;
	std::cout << "Введіть ціле число: ";
	std::cin >> inp;
	std::cout << sumFigures(inp) << "\n";
    return 0;
}


Ответ No 2


#include <iostream>
 
int sumNumbers(int x)
{
	if (x < 10)
		return x;
	else
		return sumNumbers(x / 10) + x % 10;
}
 
int main()
{
	std::cout << sumNumbers(83569) << std::endl;
}



Задание No 3

Это уже немного сложнее. Напишите программу, которая просит пользователя ввести целое число, а затем использует
рекурсивную функцию для вывода бинарного представления этого числа (см.урок No 44). Предполагается,что число,
которое введет пользователь, является положительным.

Подсказка: Используя способ No 1 для конвертации чисел из десятичной системы в двоичную, вам нужно будет
выводить биты «снизу вверх» (т.е. в обратном порядке), для этого ваш стейтмент вывода должен находиться после
вызова рекурсии.

// conversion decimal to bin

#include <iostream>

int decimal2bin(int n){
    int res;
	if(n>0){
		res=decimal2bin(n/2);
		(n%2)?std::cout << '1':std::cout << '0';
		}
	else
		res=0;
    return res;
}

int main(){
	int inp;
	std::cout << "Введіть ціле число: ";
	std::cin >> inp;
	decimal2bin(inp);
	std::cout << "\n";
    //std::cout << 1/2 << "\n";
    return 0;
}



Ответ No 3


#include <iostream>
 
void printBinary(int x)
{
        // Условие завершения
        if (x == 0)
            return;
	
	// Рекурсия к следующему биту
	printBinary(x / 2);
 
	// Выводим остаток (в обратном порядке)
	std::cout << x % 2;
}
 
int main()
{
	int x;
	std::cout << "Enter an integer: ";
	std::cin >> x;
 
	printBinary(x);
}





Задание No 4

Используя программу из задания No 3, обработайте случай, когда пользователь ввел 0 или отрицательное число,
например:

Enter an integer: -14
11111111111111111111111111110010

Подсказка: Вы можете конвертировать отрицательное целое число в положительное, используя оператор static_cast
для конвертации в unsigned int.


// conversion decimal to bin

#include <iostream>


int decimal2bin(unsigned int n){
    int res;
	if(n>0){
		res=decimal2bin(n/2);
		(n%2)?std::cout << '1':std::cout << '0';
		}
	else
		res=0;

    return res;
}


int main(){
	int inp;
	std::cout << "Введіть ціле число: ";
	std::cin >> inp;
	decimal2bin(static_cast<unsigned int>(inp));
	std::cout << "\n";
    //std::cout << 1/2 << "\n";
    return 0;
}



Ответ No 4

#include <iostream>
 
void printBinaryDigits(unsigned int n)
{
	// Условие завершения
	if (n == 0)
		return;
 
	printBinaryDigits(n / 2);
 
	std::cout << n % 2;
}
 
void printBinary(int n)
{
	if (n == 0)
		std::cout << '0'; // выводим "0", если n == 0
	else	
		printBinaryDigits(static_cast<unsigned int>(n));
}
 
int main()
{
	int x;
	std::cout << "Enter an integer: ";
	std::cin >> x;
 
	printBinary(x);
}