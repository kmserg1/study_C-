Урок No 79. Строки C-style


На уроке No 57 мы определили термин «строка», как набор последовательных символов (например, Hello, world! ). Строки —
это основной способ работы с текстомв языке C++, а std::string упрощает этот способ работы.
Современный C++ поддерживает два разных типа строк:

 std::string (как часть Стандартной библиотеки С++);
 строки C-style (изначально унаследованные от языка Cи).

std::string реализован с помощью строк C-style.

Оглавление:
1. Строки C-style
2. Строки C-style и std::cin
3. Управление строками C-style
4. Стоит ли использовать строки C-style?


Строки C-style

Строка C-style — это простой массив символов, который использует нуль-терминатор. Нуль-терминатор — это специальный
символ (ASCII-кодкоторого равен 0), используемый для обозначения конца строки. Строка C-style еще называется «нуль-
терминированной строкой».
Для её определения нужно просто объявить массив типа charи инициализировать его литералом (например, string):

1 char mystring[] = "string";

Хотя string имеет только 6 букв, C++ автоматически добавляет нуль-терминатор в конец строки (нам не нужно добавлять его
вручную). Следовательно, длина массива mystring на самом деле равна7!
В качестве примера рассмотрим следующую программу, которая выводит длину строки, а затем ASCII-коды всех символов
литерала string:

1 #include <iostream>
2
3 int main()
4 {
5 	char mystring[] = "string";
6 	std::cout << mystring << " has " << sizeof(mystring) << " characters.\n";
7 	for (int index = 0; index < sizeof(mystring); ++index)
8 		std::cout << static_cast<int>(mystring[index]) << " ";
9
10 	return 0;
11 }

Результат выполнения программы:
string has 7 characters.
115 116 114 105 110 103 0

Нуль в конце является ASCII-кодом нуль-терминатора, который был добавлен в конец строки.
При таком объявлении строк рекомендуется использовать квадратные скобки [] , чтобы позволить компилятору определить
длину массива самому. Таким образом, если вы измените строку позже, вам не придетсявручную изменять значение длины
массива.
Важно отметить, что строки C-style следуют всем тем же правилам, что и массивы. Это означает, что вы можете
инициализировать строку при создании, но после этого не сможете присваивать ей значения с помощью оператора
присваивания:

1 char mystring[] = "string"; // ок
2 mystring = "cat"; // не ок!

Это тожесамое,как если бы мысделали следующее:

1 int array[] = { 4, 6, 8, 2 }; // ок
2 array = 7; // что это значит?

Поскольку строки C-style являются массивами, то вы можете использовать оператор [] для изменения отдельных символов в
строке:

1 #include <iostream>
2
3 int main()
4 {
5 	char mystring[] = "string";
6 	mystring[1] = 'p';
7 	std::cout << mystring;
8
9 	return 0;
10 }

Результат выполнения программы:
spring

Привыводе строки C-style объект std::coutвы водит символы до тех пор,пока не встретит нуль-терминатор. Еслибы вы
случайно перезаписали нуль-терминаторв конце строки (например, присвоив что-либо для mystring[6] ), то от std::cout вы
бы получили не только все символы строки, но и всё, что находится в соседних ячейках памяти до тех пор, пока непопался 
бы 0!
Обратите внимание, это нормально, если длина массива больше строки, которую он хранит:

1 #include <iostream>
2
3 int main()
4 {
5 	char name[15] = "Max"; // используется только 4 символа (3 буквы + нуль-терминатор)
6 	std::cout << "My name is: " << name << '\n';
7
8 	return 0;
9 }

В этом случае строка Max будет выведена, а std::cout остановится нануль-терминаторе. Остальные символы в массиве будут
проигнорированы.


Строки C-style и std::cin

Есть многослучаев, когда мы не знаем заранее, насколько длинной будет наша строка. Например, рассмотрим проблему
написания программы, где мы просим пользователя ввести свое имя. Насколько длинным оно будет? Этонеизвестно до тех
пор, пока пользователь его не введет!
В таком случаемы можем объявить массив размером больше, чем намнужно:

1 #include <iostream>
2
3 int main()
4 {
5 	char name[255]; // объявляем достаточно большой массив (для хранения 255 символов)
6 	std::cout << "Enter your name: ";
7 	std::cin >> name;
8 	std::cout << "You entered: " << name << '\n';
9
10 	return 0;
11 }

В программе, приведенной выше, мы объявили массив из 255 символов, предполагая, что пользователь не введет имя
длиннее 255символов. Хоть это и распространенная практика, но она не очень эффективна, так как пользователю ничего не
мешает ввести имя, содержащее более 255 символов (случайно или намеренно).
Намноголучше сделать следующим образом:

1 #include <iostream>
2
3 int main()
4 {
5 char name[255]; // объявляем достаточно большой массив (для хранения 255 символов)
6 std::cout << "Enter your name: ";
7 std::cin.getline(name, 255);
8 std::cout << "You entered: " << name << '\n';
9
10 return 0;
11 }

Вызов cin.getline() будет принимать до 254 символов в массив name (оставляя место для нуль-терминатора!). Любые
лишние символы будут проигнорированы. Таким образом, мы можем гарантировать, что массив не будет переполнен!


Управление строками C-style

Язык C++ предоставляет множество функцийдля управления строками C-style, которые подключаются с помощью
заголовочного файла cstring. Вот несколько самых полезных функций:

Функция strcpy_s()позволяет копировать содержимое одной строки в другую.Чаще всего этоиспользуется для присваивания
значений строке:

1 #include <iostream>
2 #include <cstring>
3
4 int main()
5 {
6 	char text[] = "Print this!";
7 	char dest[50];
8	 strcpy_s(dest, text);
9 	std::cout << dest; // выводим "Print this!"
10
11 	return 0;
12 }

Тем не менее, использование функции strcpy_s() может легко вызвать переполнение массива, если не быть осторожным! 
В следующей программе длина массива dest меньше длины копируемой строки, поэтому в результате мыполучим
переполнение массива:

1 #include <iostream>
2 #include <cstring>
3
4 int main()
5 {
6 	char text[] = "Print this!";
7 	char dest[5]; // обратите внимание, длина массива dest всего 5 символов!
8 	strcpy_s(dest, text); // переполнение!
9 	std::cout << dest;
10
11 	return 0;
12 }

Еще одной полезной функцией управления строками является функция strlen(), которая возвращает длину строки C-style (без
учета нуль-терминатора):
1 #include <iostream>
2 #include <cstring>
3
4 int main()
5 {
6 char name[15] = "Max"; // используется только 4 символа (3 буквы + нуль-терминатор)
7 std::cout << "My name is " << name << '\n';
8 std::cout << name << " has " << strlen(name) << " letters.\n";
9 std::cout << name << " has " << sizeof(name) << " characters in the array.\n";
10
11 return 0;
12 }

Результат выполнения программы:
My name is Max
Max has 3 letters.
Max has 15 characters in the array.

Обратите внимание на разницу между функцией strlen() и оператором sizeof. Функция strlen() выводит количествосимволов до
нуль-терминатора, тогда как оператор sizeof возвращает размер целого массива, независимо от того, что в нем находится.
Вот еще полезные функции для управления строками C-style:

 функция strcat() —добавляет одну строку к другой (опасно);
 функция strncat() — добавляет однустрокукдругой (спроверкой размера места назначения);
 функция strcmp() — сравнивает две строки (возвращает 0 , если они равны);
 функция strncmp() — сравнивает две строки до определенного количества символов (возвращает 0 , если до
  указанного символа не было различий).

Например:

1 #include <iostream>
2 #include <cstring>
3
4 int main()
5 {
6 	// Просим пользователя ввести строку
7 	char buffer[255];
8 	std::cout << "Enter a string: ";
9 	std::cin.getline(buffer, 255);
10
11 	int spacesFound = 0;
12 	// Перебираем каждый символ, который ввел пользователь
13 	for (int index = 0; index < strlen(buffer); ++index)
14 	{
15 		// Подсчитываем количество пробелов
16 		if (buffer[index] == ' ')
17 		spacesFound++;
18 	}
19
20 	std::cout << "You typed " << spacesFound << " spaces!\n";
21 
22 	return 0;
23 }


Стоит ли использовать строки C-style?

Знать о строках C-style стоит,так как они используются не так уж и редко, но использовать их без веской на то причины не
рекомендуется. Вместо строк C-style используйте std::string (подключая заголовочный файл string), так как он проще,
безопаснее и гибче.

Правило: Используйтеstd::string вместо строк C-style.
