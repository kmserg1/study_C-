Урок No 172. Вывод объектов классов через оператор вывода

На этом уроке мы рассмотрим, как выводить объекты классов через оператор вывода в языке С++.

Оглавление:
1. Проблема с переопределением operator <<
2. Можем ли мы сделать operator << виртуальным?
3. Решение


Проблема с переопределением operator <<

Рассмотрим следующую программу:
1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	Parent() {}
7
8 	virtual void print() const { std::cout << "Parent"; }
9 };
10
11 class Child: public Parent
12 {
13 public:
14 	Child() {}
15
16 	virtual void print() const override { std::cout << "Child"; }
17 };
18
19 int main()
20 {
21 	Child ch;
22 	Parent &p = ch;
23 	p.print(); // вызывается Child::print()
24
25 	return 0;
26 }

Здесь понятно, что p.print() вызывает Child::print() (поскольку p ссылается на объект класса Child, то Parent::print() является
виртуальной функцией, а Child::print() является переопределением).
Такой способ вывода неплохой, но с std::cout не очень хорошо сочетается:

1 int main()
2 {
3 	Child ch;
4 	Parent &p = ch;
5
6 	std::cout << "p is a ";
7 	p.print(); // разрываем стейтмент cout ради функции print(). Не дело!
8 	std::cout << '\n';
9
10 	return 0;
11 }

На этом уроке мы рассмотрим, как переопределить оператор вывода << для классов с наследованием, чтобы иметь
возможность использовать оператор << следующим образом:

1 std::cout << "p is a " << p << '\n'; // гораздо лучше

Начнем с обычной перегрузки оператора вывода <<:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	Parent() {}
7
8 	virtual void print() const { std::cout << "Parent"; }
9
10 	friend std::ostream& operator<< (std::ostream &out, const Parent &p)
11 	{
12 		out << "Parent";
13 		return out;
14 	}
15 };
16
17 class Child: public Parent
18 {
19 public:
20 	Child() {}
21
22 	virtual void print() const override { std::cout << "Child"; }
23
24 	friend std::ostream& operator<<(std::ostream &out, const Child &ch)
25 	{
26 		out << "Child";
27 		return out;
28 	}
29
30 };
31
32 int main()
33 {
34 	Parent p;
35 	std::cout << p << '\n';
36
37 	Child ch;
38 	std::cout << ch << '\n';
39
40 	return 0;
41 }

Поскольку здесь нет виртуальных функций, то всё довольно-таки просто и ясно:
Parent
Child

Теперь заменим функцию main() на следующую:
1 int main()
2 {
3 	Child ch;
4 	Parent &pref = ch;
5 	std::cout << pref << '\n';
6
7 	return 0;
8 }

Результат:
Parent

А это уже не то, что нам нужно. Поскольку перегрузка оператора << для объектов класса Parent не является виртуальной, то
std::cout << pref вызывает версию оператора << , которая работает только с объектами класса Parent. В этом и суть проблемы.


Можем ли мы сделать operator << виртуальным?

Нет, и на это есть ряд причин.

Во-первых, только методы могут быть виртуальными. Это логично, так как только классы могут наследовать другие классы, и
переопределить функцию, которая находится вне тела класса — невозможно (мы можем перегрузить функции, которые не
являются методами, но не можем переопределить их). Поскольку оператор << обычно перегружается через
дружественную функцию, а дружественные функции не являются методами, то дружественная функция operator << не
можетбыть переопределена.

Во-вторых, даже если бы мы могли сделать operator<< виртуальной функцией, то проблема заключается в том,что параметры
Parent::operator<< и Child::operator<< отличаются (версия Parent принимает в качестве параметра объект класса Parent, а
версия Child — объект класса Child). Следовательно, версия Child не может считаться переопределением версии Parent и
вызываться в качестве переопределения тоже не может.
Что остается делать программисту?

Решение
Ответ на удивление прост. Сначала мы делаем operator<< дружественной функцией классу Parent. Но вместо того, чтобы operator<< производил вывод
самостоятельно, мы делегируем эту задачу обычному методу, который является виртуальной функцией!

Рассмотрим это на практике:
1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	Parent() {}
7
8 	// Перегрузка оператора вывода <<
9 	friend std::ostream& operator<<(std::ostream &out, const Parent &p)
10 	{
11 		// Делегируем выполнение операции вывода методу print()
12 		return p.print(out);
13 	}
14
15 	// Делаем метод print() виртуальным
16 	virtual std::ostream& print(std::ostream& out) const
17 	{
18 		out << "Parent";
19 		return out;
20 	}
21 };
22
23 class Child: public Parent
24 {
25 public:
26 	Child() {}
27
28 	// Переопределение метода print() для работы с объектами класса Child
29 	virtual std::ostream& print(std::ostream& out) const override
30 	{
31 		out << "Child";
32 		return out;
33 	}
34 };
35
36 int main()
37 {
38 	Parent p;
39 	std::cout << p << '\n';
40
41 	Child ch;
42 	std::cout << ch << '\n'; // обратите внимание, всё работает даже без наличия перегрузки оператора вывода в классе Child
43
44 	Parent &pref = ch;
45 	std::cout << pref << '\n';
46
47 	return 0;
48 }

Вышеприведенная программа работает во всех трех случаях:
Parent
Child
Child

Рассмотрим детально.

В случае с объектом класса Parent, мы вызываем operator<<, который вызывает виртуальную функцию print(). Поскольку мы
ссылаемся на объект класса Parent, то p.print() вызывает Parent::print(), который и выполняет вывод на экран. Здесь всё
просто.
В случае с объектом класса Child, компилятор сначала смотрит, есть ли operator<<, который принимает объект класса Child. Он
ничего не находит (так как мы это не определили), затем смотрит, есть ли operator<<, который принимает объект класса Parent.
Есть, компилятор находит и выполняет неявное преобразование (повышающее приведение) объекта класса Child (ссылки на
объект класса Child) в ссылку класса Parent и вызывает виртуальную функцию print(), которая,в свою очередь, вызывает
переопределение Child::print().
Обратите внимание, нам не нужно записывать перегрузку operator<< в каждом дочернем классе! Перегрузка,которая
находится в классе Parent, отлично работает как с объектами класса Parent, таки с объектами любого дочернего класса
(который наследует класс Parent). 
В последнем случае компилятор сопоставляет ссылку pref с operator<< класса Parent. Вызывается виртуальная функция print().
Поскольку ссылка pref фактически указывает на объект класса Child, то вызывается переопределение Child::print(), как мы и
предполагали.

Проблема решена.
