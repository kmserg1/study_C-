Урок No 119. Делегирующие конструкторы

На этом уроке мы рассмотрим, что такое делегирующие конструкторы в языке С++, зачем они были придуманы и как их
использовать.

Оглавление:
1. Проблема
2. Решение в C++11
3. Использование отдельного метода
4. Делегирующие конструкторы в C++11
5. Несколько заметок о делегирующих конструкторах


Проблема

При создании нового объекта класса, компилятор C++ неявно вызывает конструктор этого объекта. Не редкость встретить
класс с несколькими конструкторами, которые частично выполняют одно и тоже, например:

1 class Boo
2 {
3 public:
4 	Boo()
5 	{
6 		// Часть кода X
7 	}
8
9 	Boo(int value)
10 	{
11 		// Часть кода X
12 		// Часть кода Y
13 	}
14 };

Здесь есть 2 конструктора: конструктор по умолчанию и конструктор, который принимает целочисленное значение.
Поскольку Часть кода X требуется обоим конструкторам, то она дублируется в каждомиз них.
А как вы уже могли догадаться, дублирование кода — это то, чего следует избегать, поэтому давайте рассмотрим
возможные решения этой проблемы.


Решение в C++11

Неплохо было бы, чтобы конструктор Boo(int) вызывал конструктор Boo() для выполнения Часть кода X :

1 class Boo
2 {
3 public:
4 	Boo()
5 	{
6 		// Часть кода X
7 	}
8
9 	Boo(int value)
10 	{
11 		Boo(); // используем конструктор, указанный выше, для выполнения части кода X
12 		// Часть кода Y
13 	}
14 };

Или:

1 class Boo
2 {
3 public:
4 	Boo()
5 	{
6 		// Часть кода X
7 	}
8
9 	Boo(int value): Boo() // используем конструктор, указанный выше, для выполнения части кода X
10 	{
11 		// Часть кода Y
12 	}
13 };

Однако, если ваш компилятор не совместим с C++11, и вы попытаетесь вызвать один конструктор внутри другого
конструктора, то это скомпилируется, но будет работать не так, как выо жидаете.
До C++11 явный вызов одного конструктора из другого приводит к созданию временного объекта, который затем
инициализируется с помощью конструктора этого объекта и отбрасывается, оставляя исходный объект неизменным.


Использование отдельного метода

Конструкторам разрешено вызывать другие методы класса, которые не являются конструкторами. Хотя у вас может
возникнуть соблазн скопировать код из первого конструктора во второй конструктор, наличие дублированного кода
сделает ваш класс более трудным для понимания и более обременительным для поддержки. Лучшим решением будет
создание отдельного метода (не конструктора), который будет выполнять общую инициализацию, и оба конструктора будут
вызывать этот метод. Например:

1 class Boo
2 {
3 private:
4 	void DoX()
5 	{
6 		// Часть кода X
7 	}
8
9 public:
10 	Boo()
11 	{
12 		DoX();
13 	}
14
15 	Boo(int nValue)
16 	{
17 		DoX();
18 		// Часть кода Y
19 	}
20
21 };

Здесь мы свели дублирование кода к минимуму.
Кроме того, вы можете оказаться в ситуации, когда вам нужно будет написать метод для повторной инициализации класса
обратно до значений по умолчанию. Поскольку у вас, вероятно, уже есть конструктор, который это делает, то у вас может
возникнуть соблазн попытаться вызвать этот конструктор из вашего метода. Однако это приведет к неожиданным
результатам. Многие разработчики просто копируют код из конструктора в функцию инициализации — это сработает, но
приведет также к дублированию кода. Лучшим решением будет переместить код из конструктора в вашу новую функцию и
заставить конструктор вызывать вашу новую функцию для выполнения инициализации:

1 class Boo
2 {
3 public:
4 	Boo()
5 	{
6 		Init();
7 	}
8
9 	Boo(int value)
10 	{
11 		Init();
12 		// Делаем что-либо с value
13 	}
14
15 	void Init()
16 	{
17 		// Код инициализации Boo
18 	}
19 };

Здесь мы подключаем функцию Init() для инициализации переменных-членов обратно значениями по умолчанию, а затем
каждый конструктор вызывает функцию Init() перед своим фактическим выполнением. Это сокращает дублирование кода до
минимума и позволяет явно вызывать Init() из любого места в программе.


Делегирующие конструкторы в C++11

Начиная с C++11, конструкторам разрешено вызывать другие конструкторы. Этот процесс называется делегированием
конструкторов (или «цепочкой конструкторов»). Чтобы один конструктор вызывал другой, нужно просто сделать вызов
этого конструктора в списке инициализации членов. Например:

1 class Boo
2 {
3 private:
4
5 public:
6 	Boo()
7 	{
8 		// Часть кода X
9 	}
10
11 	Boo(int value): Boo() // используем конструктор по умолчанию Boo() для выполнения части кода X
12 	{
13 		// Часть кода Y
14 	}
15
16 };

Всё работает как нужно. Убедитесь, что вы вызываете конструктор из списка инициализации членов, а не из тела
конструктора.
Вот еще один пример использования делегирующих конструкторов для сокращения дублированного кода:

1 #include <iostream>
2 #include <string>
3
4 class Employee
5 {
6 private:
7 	int m_id;
8 	std::string m_name;
9
10 public:
11 	Employee(int id=0, const std::string &name=""):
12 	m_id(id), m_name(name)
13 	{
14 		std::cout << "Employee " << m_name << " created.\n";
15 	}
16
17 	// Используем делегирующие конструкторы для сокращения дублированного кода
18 	Employee(const std::string &name) : Employee(0, name) { }
19 };
20
21 int main()
22 {
23 Employee a;
24 Employee b("Ivan");
25
26 return 0;
27 }

Этот класс имеет 2 конструктора (один из которых вызывает другой). Таким образом, количество дублированного кода
сокращено (нам нужно записать только одно определение конструктора вместо двух).


Несколько заметок о делегирующих конструкторах

Во-первых, конструктору, который вызывает другой конструктор, не разрешается выполнять какую-либо инициализацию
членов класса. Поэтому конструкторы могут либо вызывать другие конструкторы, либо выполнять инициализацию, но не
всё сразу.

Во-вторых, один конструктор может вызывать другой конструктор, в коде которого может находиться вызов первого
конструктора. Это создаст бесконечный цикл и приведет к тому, что память стека закончится и произойдет сбой. Вы
можете избежать этого, убедившись, что в конструкторе, который вызывается, нет вызова первого (и вообще любого
другого) конструктора. Будьте аккуратны и не используйте вложенные вызовы конструкторов.
