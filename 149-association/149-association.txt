Урок No 149. Ассоциация


На предыдущих уроках мы рассмотрели два подтипа композиции объектов: композицию и агрегацию. Композиция объектов
используется для моделирования отношений, в которых сложный объект (целое) состоит из нескольких более простых
объектов (частей).
На этом уроке мы рассмотрим следующий тип отношений между двумяне связанными объектами — ассоциацию. В отличие от
композиции объектов, в ассоциации нет отношений «частей-целого».

Оглавление:
1. Ассоциация
2. Реализация ассоциаций
3. Рефлексивная ассоциация
4. Ассоциации могут быть косвенными
5. Композиция vs. Агрегация vs. Ассоциация


Ассоциация

В ассоциации два несвязанных объекта должны соответствовать следующим отношениям:
 Первый объект (член) не связан со вторым объектом (классом).
 Первый объект (член) может принадлежать одновременно сразу нескольким объектам (классам).
 Первый объект (член) существует, не управляемый вторым объектом (классом).
 Первый объект (член) может знать или не знать о существовании второго объекта (класса).

В отличие от композиции или агрегации, где часть является частью целого, в ассоциации объекты между собой никак не
связаны. Подобно агрегации, первый объект может принадлежать сразу нескольким объектам одновременно и не управляется
ими. Однако, в отличие от агрегации, где отношения однонаправленные, в ассоциации отношения могут быть как
однонаправленными, так и двунаправленными (когда оба объекта знают о существовании друг друга).
Отношения между врачами и пациентами — это отличный пример ассоциации. Врач связан с пациентом, но эти отношения
нельзя назвать отношениями «части-целого». Врач может принимать десятки пациентов в день, а пациент может обращаться
к нескольким врачам.
Мы можем сказать, что типом отношений в ассоциации является «использует». Врач «использует» пациента для получения
дохода. Пациент «использует» врача, чтобы вылечить болезнь или улучшить свое самочувствие.


Реализация ассоциаций

Ассоциации реализизуются по-разному. Однако чаще всего они реализованы через указатели, где классы указывают на
объекты друг друга.
В следующем примере мы реализуем двунаправленную связь между Врачом и Пациентом, так как Врач должен знать своих
Пациентов в лицо, а Пациенты могут обращаться к разным Врачам:

1 #include <iostream>
2 #include <string>
3 #include <vector>
4
5 // Поскольку отношения между этими классами двунаправленные, то для класса Doctor здесь нужно использовать предварительное объ
6 class Doctor;
7
8 class Patient
9 {
10 private:
11 	std::string m_name;
12 	std::vector<Doctor *> m_doctor; // благодаря вышеприведенному предварительному объявлению Doctor, эта строка не вызовет ош
13
14 	// Мы объявляем метод addDoctor() закрытым, так как не хотим его публичного использования.
15 	// Вместо этого доступ к нему будет осуществляться через Doctor::addPatient().
16 	// Мы определим этот метод после определения класса Doctor, так как нам сначала нужно определить Doctor, чтобы использоват
17 	void addDoctor(Doctor *doc);
18
19 public:
20 	Patient(std::string name)
21 		: m_name(name)
22 	{
23 	}
24
25 	// Мы реализуем перегрузку оператора вывода ниже определения класса Doctor, так как он как раз и требуется для реализации
26 	friend std::ostream& operator<<(std::ostream &out, const Patient &pat);
27
28 	std::string getName() const { return m_name; }
29
30 	// Мы делаем класс Doctor дружественным, чтобы иметь доступ к закрытому методу addDoctor().
31 	// Примечание: Мы бы хотели сделать дружественным только один метод addDoctor(), но мы не можем это сделать, так как Docto
32 	friend class Doctor;
33 };
34
35 class Doctor
36 {
37 private:
38 	std::string m_name;
39 	std::vector<Patient *> m_patient;
40
41 public:
42 	Doctor(std::string name):
43 		m_name(name)
44 	{
45 	}
46
47 	void addPatient(Patient *pat)
48 	{
49 	// Врач добавляет Пациента
50 	m_patient.push_back(pat);
51
52 	// Пациент добавляет Врача
53 	pat->addDoctor(this);
54 	}
55
56
57 	friend std::ostream& operator<<(std::ostream &out, const Doctor &doc)
58 	{
59 		unsigned int length = doc.m_patient.size();
60 		if (length == 0)
61 		{
62 			out << doc.m_name << " has no patients right now";
63 			return out;
64 		}
65
66 	out << doc.m_name << " is seeing patients: ";
67 	for (unsigned int count = 0; count < length; ++count)
68 		out << doc.m_patient[count]->getName() << ' ';
69
70 	return out;
71 	}
72
73 	std::string getName() const { return m_name; }
74 };
75
76 void Patient::addDoctor(Doctor *doc)
77 {
78 	m_doctor.push_back(doc);
79 }
80
81 std::ostream& operator<<(std::ostream &out, const Patient &pat)
82 {
83 	unsigned int length = pat.m_doctor.size();
84 	if (length == 0)
85 	{
86 		out << pat.getName() << " has no doctors right now";
87 		return out;
88 	}
89
90 	out << pat.m_name << " is seeing doctors: ";
91 	for (unsigned int count = 0; count < length; ++count)
92 		out << pat.m_doctor[count]->getName() << ' ';
93
94 	return out;
95 }
96
97
98 int main()
99 {
100 	// Создаем Пациентов вне области видимости класса Doctor
101 	Patient *p1 = new Patient("Anton");
102 	Patient *p2 = new Patient("Ivan");
103 	Patient *p3 = new Patient("Derek");
104
105 	// Создаем Докторов вне области видимости класса Patient
106 	Doctor *d1 = new Doctor("John");
107 	Doctor *d2 = new Doctor("Tom");
108
109 	d1->addPatient(p1);
110
111 	d2->addPatient(p1);
112 	d2->addPatient(p3);
113
114 	std::cout << *d1 << '\n';
115 	std::cout << *d2 << '\n';
116 	std::cout << *p1 << '\n';
117 	std::cout << *p2 << '\n';
118 	std::cout << *p3 << '\n';
119
120 	delete p1;
121 	delete p2;
122 	delete p3;
123
124 	delete d1;
125 	delete d2;
126
127 	return 0;
128 }

Результат выполнения программы:

John is seeing patients: Anton
Tom is seeing patients: Anton Derek
Anton is seeing doctors: John Tom
Ivan has no doctors right now
Derek is seeing doctors: Tom

Если говорить в общем, толучше избегать двунаправленных ассоциаций, если для решения задания подходит и
однонаправленная связь, так как двунаправленную связь написать сложнее (с учетом возникновения возможных ошибок) и
она усложняет логику программы.


Рефлексивная ассоциация

Иногда объекты могути меть отношения с другими объектами тогоже типа. Это называется рефлексивной ассоциацией.
Хорошим примером рефлексивной ассоциации являются отношения между университетским курсом и его минимальными
требованиями для студентов.
Рассмотрим упрощенный случай, когда Курс может иметь только одно Требование:

1 #include <string>
2
3 class Course
4 {
5 private:
6 	std::string m_name;
7 	Course *m_condition;
8
9 public:
10 	Course(std::string &name, Course *condition=nullptr):
11 		m_name(name), m_condition(condition)
12 	{
13 	}
14
15 };

Это может привести к цепочке ассоциаций (курс имеет необходимое условие, выполнение которого включает еще одно
условие и т.д.).


Ассоциации могут быть косвенными

В примерах, приведенных выше, мы использовали указатели для связывания объектов. Однако в ассоциации это не является
обязательным условием. Можноиспользовать любые данные, которые позволяют связать два объекта. В следующем примере
мы покажем, как класс Водитель может иметь однонаправленную связь с классом Автомобиль без переменной-члена в виде
указателя на объект класса Автомобиль:

1 #include <iostream>
2 #include <string>
3
4 class Car
5 {
6 private:
7 	std::string m_name;
8 	int m_id;
9
10 public:
11 	Car(std::string name, int id)
12 		: m_name(name), m_id(id)
13 	{
14 	}
15
16 	std::string getName() { return m_name; }
17 	int getId() { return m_id; }
18 };
19
20 // Наш CarLot, по сути, является статическим массивом, содержащим Автомобили, и имеет функцию для "выдачи" Автомобилей.
21 // Поскольку массив является статическим, то нам не нужно создавать объекты для использования класса CarLot
22 class CarLot
23 {
24 private:
25 	static Car s_carLot[4];
26
27 public:
28 	CarLot() = delete;
29
30 	static Car* getCar(int id)
31 	{
32 		for (int count = 0; count < 4; ++count)
33 			if (s_carLot[count].getId() == id)
34 				return &(s_carLot[count]);
35
36 		return nullptr;
37 	}
38 };
39
40 Car CarLot::s_carLot[4] = { Car("Camry", 5), Car("Focus", 14), Car("Vito", 73), Car("Levante", 58) };
41
42 class Driver
43 {
44 private:
45 	std::string m_name;
46 	int m_carId; // для связывания классов, вместо указателя, используется Идентификатор (целочисленное значение)
47
48 public:
49 	Driver(std::string name, int carId)
50 		: m_name(name), m_carId(carId)
51 	{
52 	}
53
54 	std::string getName() { return m_name; }
55 	int getCarId() { return m_carId; }
56
57 };
58
59 int main()
60 {
61 	Driver d("Ivan", 14); // Ivan использует машину с ID 14
62
63 	Car *car = CarLot::getCar(d.getCarId()); // получаем этот Автомобиль из CarLot
64
65 	if (car)
66 		std::cout << d.getName() << " is driving a " << car->getName() << '\n';
67 	else
68 		std::cout << d.getName() << " couldn't find his car\n";
69
70 	return 0;
71 }

Результат выполнения программы:
Ivan is driving a Focus

В примере, приведенном выше, у нас есть CarLot (Гараж) в котором находятся наши автомобили. Водитель, которому нужен
Автомобиль, не имеет указателя на этот Автомобиль — вместо этого у него есть Идентификатор Автомобиля, который он может
использовать для получения Автомобиля из Гаража, когда ему это нужно.

Конкретно в этом примере реализация выглядит несколько глупо, так как получение Автомобиля из Гаража требует
дополнительного выполнения процессов (было бы быстрее, если бы существовал указатель, соединяющий напрямую два
класса). Тем не менее, есть и преимущества привязки объектов к Идентификаторам вместо использования указателя.
Например, вы можете ссылаться на объекты, которые сейчас не находятся в памяти (возможно, они находятся в файле или в
базе данных и могут быть загружены по запросу).


Композиция vs. Агрегация vs. Ассоциация

Вот таблица, которая поможет вам быстро разобраться/вспомнить различия между композицией, агрегацией и ассоциацией:
----------------------------------------------------------------------------------------------------
Свойства			Композиция	 	Агрегация		Ассоциация
----------------------------------------------------------------------------------------------------
Отношения			Части-целое	 	Части-целое		Объекты не связаны 
										между собой

Члены могут принадлежать	Нет			Да			Да
одновременно сразу
нескольким классам

Существование членов 		Да			Нет			Нет
управляется классами

Вид отношений			Однонаправленные       Однонаправленные		Однонаправленные или
										Двунаправленные

Тип отношений			«Часть чего-то»		«Имеет»			«Использует»
----------------------------------------------------------------------------------------------------



