Урок No 159. Переопределение методов родительского класса


Дочерние классы по умолчанию наследуют все методы родительского класса. На этом уроке мы рассмотрим, как это
происходит, а также то, как можно изменить методы родительских классов в дочерних классах.

Оглавление:
1. Вызов методов родительского класса
2. Переопределение методов родительского класса
3. Расширение функционала родительских методов


Вызов методов родительского класса

При вызове метода черезо бъект дочернего класса, компилятор сначала смотрит, существует ли этот метод в дочернем классе.
Если нет, то он начинает продвигаться по цепочке наследования вверх и проверяет, был ли этот метод определен в любом
из родительских классов. Компилятор будет использовать первое найденное определение. Например:

1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		: m_value(value)
11 	{
12 	}
13
14 	void identify() { std::cout << "I am a Parent!\n"; }
15 };
16
17 class Child : public Parent
18 {
19 public:
20 	Child(int value)
21 		: Parent(value)
22 	{
23 	}
24 };
25
26 int main()
27 {
28 	Parent parent(6);
29 	parent.identify();
30
31 	Child child(8);
32 	child.identify();
33
34 	return 0;
35 }

Результат выполнения программы:
I am a Parent!
I am a Parent!

При вызове child.identify() , компилятор смотрит, определен ли метод identify() в классе Child. Нет, поэтому компилятор
переходитк классу Parent. В классе Parent есть определение метода identify(), поэтому компилятор использует именно это
определение.


Переопределение методов родительского класса

Однако, если бы мы определили метод identify() в классе Child, то использовалось бы именно это определение. Это означает,
что мы можем заставить родительские методы работать по-другому с нашими дочерними классами, просто переопределяя их
в дочерних классах!

Выше приведенный пример станет лучше, если child.identify() будет выводить "I am a Child!". Давайте изменим метод
identify() в классе Child так, чтобы он возвращал правильный ответ.
Переопределение родительского метода в дочернем классе происходит, как обычное определение метода:

1 class Child : public Parent
2 {
3 public:
4 	Child(int value)
5 		: Parent(value)
6 	{
7 	}
8
9 	int getValue() { return m_value; }
10
11 	// Вот наш изменяемый метод родительского класса
12 	void identify() { std::cout << "I am a Child!\n"; }
13 };

Вот тот же код main(), что и в примере, приведенном выше, но уже с внесенными изменениями в класс Child:

1 int main()
2 {
3 	Parent parent(6);
4 	parent.identify();
5
6 	Child child(8);
7 	child.identify();
8
9 	return 0;
10 }

Результат:
I am a Parent!
I am a Child!

Обратите внимание, когда мы переопределяем родительский метод в дочернем классе, то дочерний метод не наследует
спецификатор доступа родительского метода с тем же именем. Используется тот спецификатор доступа, который указан в 
дочернем классе. Таким образом, метод, определенный как private в родительском классе, может быть переопределен как
public в дочернем классе, или наоборот!

1 #include <iostream>
2
3 class Parent
4 {
5 private:
6 	void print()
7 	{
8 		std::cout << "Parent!";
9 	}
10 };
11
12 class Child : public Parent
13 {
14 public:
15 	void print()
16 	{
17 		std::cout << "Child!";
18 	}
19
20 };
21
22
23 int main()
24 {
25 	Child child;
26 	child.print(); // вызов child::print(), который является public
27 	return 0;
28 }


Расширение функционала родительских методов

Могут быть случаи, когда нам не нужно полностью заменять метод родительского класса, но нужно просто расширить его
функционал. 
Обратите внимание, в примере, приведенном выше, метод Child::identify() полностью перекрывает Parent::identify()! 
Возможно, это не то, что нам нужно. Мы можемвызвать метод родительского класса с тем же именем в методе
дочернего класса (для повторного использования кода), а затем добавить дополнительносвой код.
Чтобы метод дочернего класса вызывал метод родительского класса с тем же именем, нужно просто выполнить обычный
вызов функции, но с добавлением имени родительского класса и оператора разрешения области видимости. В следующем
примере мы выполним переопределение identify() в классе Child, вызывая сначала Parent::identify(), а затем добавляя уже свой
код:

1 class Child : public Parent
2 {
3 public:
4 	Child(int value)
5 		: Parent(value)
6 	{
7 	}
8
9 	int GetValue() { return m_value; }
10
11 	void identify()
12 	{
13 		Parent::identify(); // сначала выполняется вызов Parent::identify()
14 		std::cout << "I am a Child!\n"; // затем уже вывод этого текста
15 	}
16 };

Вместе с:
1 int main()
2 {
3 	Parent parent(6);
4 	parent.identify();
5
6 	Child child(8);
7 	child.identify();
8
9 	return 0;
10 }

Дает результат:
I am a Parent!
I am a Parent!
I am a Child!

При выполнении child.identify() выполняется вызов Child::identify(). В Child::identify() мы сначала вызываем
Parent::identify(), который выводит "I am a Parent!". Когда Parent::identify() завершает свое выполнение, 
Child::identify() продолжает свое выполнение и выводит "I am a Child!".

Всё просто. Зачем тогда нужно использовать оператор разрешения области видимости ( :: )? А затем, что, если бы мы
определили Child::identify() следующим образом:
1 class Child : public Parent
2 {
3 public:
4 	Child(int value)
5 		: Parent(value)
6 	{
7 	}
8
9 	int GetValue() { return m_value; }
10
11 	void identify()
12 	{
13 		identify(); // нет оператора разрешения области видимости!
14 		std::cout << "I am a Child!";
15 	}
16 };

То вызов метода identify() без указания оператора разрешения области видимости привел бы к вызову identify() в текущем
классе, т.е. Child::identify(). Затем сновавызов Child::identify(), и ура — унас получился бесконечный цикл. Поэтому
использование оператора разрешения области видимости является обязательным условием при изменении методов
родительского класса.
