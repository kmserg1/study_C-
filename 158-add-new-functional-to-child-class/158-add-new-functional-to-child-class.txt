Урок No 158. Добавление нового функционала в дочерний класс


На уроке No 153 мы говорили о том, что одним из самых больших преимуществ использования дочерних классов является
возможность повторного использования уже написанного кода. Мы можем наследовать функционал родительского класса, а
затем добавить свой функционал/изменить существующий функционал/скрыть ненужные части родительского функционала.
На этом и следующих уроках мы подробно рассмотрим, как это всё сделать.

Во-первых, начнем с класса Parent:
1 #include <iostream>
2
3 class Parent
4 {
5 protected:
6 	int m_value;
7
8 public:
9 	Parent(int value)
10 		: m_value(value)
11 	{
12 	}
13
14 	void identify() { std::cout << "I am a Parent\n"; }
15 };

Теперь создадим дочерний класс, который будет наследовать класс Parent. Поскольку мы хотим иметь возможность установить
значение m_value при инициализации объектов дочернего класса, то сделаем так, чтобы конструктор класса Child вызывал
конкретный конструктор класса Parent в списке инициализации (детально об этом мы говорили на уроке No 156):

1 class Child: public Parent
2 {
3 public:
4 	Child(int value)
5 		: Parent(value)
6 	{
7 	}
8 };


Добавление нового функционала в дочерний класс

В примере, приведенном выше, поскольку мы имеем доступ к исходному коду класса Parent, то мы можем добавить новый
функционал непосредственно в класс Parent, если захотим.

Однако, есть случаи, когда мы имеем доступ к родительскому классу, но не хотим его изменять. Например, мы только что купили
библиотеку кода у стороннего поставщика, но нам нужен дополнительный функционал. Мы можем добавить его в исходный
код библиотеки, но это будет не лучшим решением. Что, если придет обновление? После обновления нам заново придется
вручную перенести весь код, что займет время и, кроме того, после обновления остается риск, что наш старый код уже не
будет работать так, как нужно с кодом библиотеки.

Также есть случаи, когда изменить родительский класс невозможно. Например, мы не можем изменить код, который является
частью Стандартной библиотеки C++. Но мы можем унаследовать классы из этой библиотеки, а затем добавить нужный нам
функционал в наши дочерние классы. То же самое касается сторонних библиотек, где нам предоставлены заголовочные
файлы, но код поставляется предварительно скомпилированным.
В любом случае лучшим решением является написание собственного родительского класса и добавление нужного нам
функционала в наши дочерние классы.

Один нюанс с классом Parent заключается в доступе других объектов к m_value . Мы можем это исправить, добавив функцию
доступа в класс Parent, но, ради примера, добавим геттер в класс Child. Поскольку m_value объявлен как protected в классе
Parent, то Child имеет прямой доступ к нему.

Добавление нового функционала в дочерний класс выполняется как обычно:
1 class Child: public Parent
2 {
3 public:
4 Child(int value)
5 	: Parent(value)
6 	{
7 	}
8
9 	int getValue() { return m_value; }
10 };

Теперь другие объекты извне смогут вызывать getValue() через объект класса Child для доступа к m_value :

1 int main()
2 {
3 	Child child(7);
4 	std::cout << "child has value " << child.getValue() << '\n';
5
6 	return 0;
7 }

Результат:
child has value 7

Это очевидно, что объекты класса Parent не имеют доступ к методу getValue() в Child. Следующее не сработает:

1 int main()
2 {
3 Parent parent(7);
4 std::cout << "parent has value " << parent.getValue() << '\n';
5
6 return 0;
7 }

Это связано с тем, что в классе Parent нет метода getValue(). Метод getValue() принадлежит классу Child. А, поскольку Child
является дочерним от класса Parent, то Child имеет доступ к членам Parent, а Parent не имеет доступа ни к чему в классе Child.
