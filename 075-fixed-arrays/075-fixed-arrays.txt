Урок №75. Фиксированные массивы

Этот урок является продолжением предыдущего урока о массивах в языке C++.

Оглавление:
1. Инициализация фиксированных массивов
2. Длина массива
3. Массивы и перечисления
4. Массивы и классы enum
5. Передача массивов в функции
6. Оператор sizeof и массивы
7. Определение длины фиксированного массива
8. Индексирование массива вне диапазона
9. Тест

Инициализация фиксированных массивов

Элементы массива обрабатываются также, как и обычные переменные, поэтому они не инициализируются при создании.
Одним из способов инициализации массиваявляется присваивание значений каждому элементу поочерёдно:

1 int array[5]; // массив содержит 5 простых чисел
2 array[0] = 4;
3 array[1] = 5;
4 array[2] = 8;
5 array[3] = 9;
6 array[4] = 12;

Однако это не совсе мудобно, особенно когда массив большой.
К счастью, язык C++ поддерживает более удобный способ инициализации массивов с помощью списка инициализаторов.
Следующий пример эквивалентен примеру выше:

1 int array[5] = { 4, 5, 8,9, 12 }; // используется список инициализаторов для инициализации фиксированного массива

Если в этом списке инициализаторов больше, чем может содержать массив, то компилятор выдаст ошибку.
Однако, если в списке инициализаторов меньше, чем может содержать массив, то остальные элементы будут
проинициализированы значением 0. Например:                                                       
1 #include <iostream>
2
3 int main()
4 {
5 int array[5]= {5, 7, 9}; // инициализируемтолько первые 3 элемента
6
7 std::cout <<array[0] <<'\n';
8 std::cout <<array[1] <<'\n';
9 std::cout <<array[2] <<'\n';
10 std::cout <<array[3] <<'\n';
11 std::cout <<array[4] <<'\n';
12
13 return 0;
14 }

Результат выполнения программы:

5
7
9
0
0

Следовательно, чтобы инициализировать все элементы массива значением 0, нужно:

1 // Инициализируем все элементы массива значением 0
2 int array[5] = { };

В C++11 вместо этого мы можем воспользоваться синтаксисом uniform-инициализации:
1 int array[5] { 4, 5, 8, 9, 12}; // используем uniform-инициализацию для инициализации фиксированного массива


Длина массива

Если вы инициализируете фиксированный массив с помощью списка инициализаторов, то компилятор может определить длину 
массива вместо вас, и вам уже не потребуется её объявлять.

Следующие две строки выполняют одно и то же:

int array[5] = { 0, 1, 2, 3, 4 }; // явно указываем длину массива
int array[] = { 0, 1, 2, 3, 4 }; // список инициализаторов автоматически определит длину массива

Это не только сэкономит время, но также вам не придется обновлять длину массива, если вы захотите добавить или удалить элементы позже.


Массивы и перечисления

Одна из основных проблем при использовании массивов состоит в том, что целочисленные индексы не предоставляют никакой информации 
программисту об их значении. Рассмотрим класс из 5 учеников:

const int numberOfStudents(5);
int testScores[numberOfStudents];
testScores[3] = 65;

Кто представлен элементом testScores[3]? Непонятно!

Это можно решить, используя перечисление, в котором перечислители сопоставляются каждому из возможных индексов массива:

enum StudentNames
{
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5
};
 
int main()
{
    int testScores[MAX_STUDENTS]; // всего 5 студентов
    testScores[JOHN] = 65;
 
    return 0;
}
Вот теперь понятно, что представляет собой каждый из элементов массива. Обратите внимание, добавлен дополнительный перечислитель 
с именем MAX_STUDENTS. Он используется во время объявления массива для гарантирования того, что массив имеет корректную длину 
(она должна быть на единицу больше самого большого индекса). Это полезно как для подсчета элементов, так и для возможности автоматического 
изменения длины массива, если добавить еще один перечислитель:

enum StudentNames
{
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MISHA, // 5
    MAX_STUDENTS // 6
};
 
int main()
{
    int testScores[MAX_STUDENTS]; // всего 6 студентов
    testScores[JOHN] = 65; // всё работает
 
    return 0;
}

Обратите внимание, этот трюк работает только в том случае, если вы не изменяете значения перечислителей вручную!


Массивы и классы enum

Классы enum не имеют неявного преобразования в целочисленный тип, поэтому, если вы попробуете сделать следующее:

enum class StudentNames
{
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MISHA, // 5
    MAX_STUDENTS // 6
};
 
int main()
{
    int testScores[StudentNames::MAX_STUDENTS]; // всего 6 студентов
    testScores[StudentNames::JOHN] = 65;
}

То получите ошибку от компилятора. Это можно решить, используя оператор static_cast для конвертации перечислителя в целое число:

int main()
{
    int testScores[static_cast<int>(StudentNames::MAX_STUDENTS)]; // всего 6 студентов
    testScores[static_cast<int>(StudentNames::JOHN)] = 65;
}

Однако, это также не очень удобно, поэтому лучше использовать стандартное перечисление внутри пространства имен:

namespace StudentNames
{
    enum StudentNames
    {
        SMITH, // 0
        ANDREW, // 1
        IVAN, // 2
        JOHN, // 3
        ANTON, // 4
        MISHA, // 5
        MAX_STUDENTS // 6
    };
}
 
int main()
{
    int testScores[StudentNames::MAX_STUDENTS]; // всего 6 студентов
    testScores[StudentNames::JOHN] = 65;
}


Передача массивов в функции
Хотя передача массива в функцию на первый взгляд выглядит так же, как передача обычной переменной, 
но «под капотом» C++ обрабатывает массивы несколько иначе.

Когда обычная переменная передается по значению, то C++ копирует значение аргумента в параметр функции. Поскольку 
параметр является копией, то изменение значения параметра не изменяет значение исходного аргумента.

Однако, поскольку копирование больших массивов — дело трудоёмкое, то C++ не копирует массив при его передаче в функцию. 
Вместо этого передается фактический массив. И здесь мы получаем побочный эффект, позволяющий функциям напрямую изменять 
значения элементов массива!

Следующий пример хорошо иллюстрирует эту концепцию:

#include <iostream>
 
void passValue(int value) // здесь value - это копия аргумента
{
    value = 87; // изменения value здесь не повлияют на фактическую переменную value
}
 
void passArray(int array[5]) // здесь array - это фактический массив
{
    array[0] = 10; // изменения array здесь изменят исходный массив array
    array[1] = 8;
    array[2] = 6;
    array[3] = 4;
    array[4] = 1;
}
 
int main()
{
    int value = 1;
    std::cout << "before passValue: " << value << "\n";
    passValue(value);
    std::cout << "after passValue: " << value << "\n";
 
    int array[5] = { 1, 4, 6, 8, 10 };
    std::cout << "before passArray: " << array[0] << " " << array[1] << " " << array[2] << " " << array[3] << " " << array[4] << "\n";
    passArray(array);
    std::cout << "after passArray: " << array[0] << " " << array[1] << " " << array[2] << " " << array[3] << " " << array[4] << "\n";
 
    return 0;
}

Результат выполнения программы:

before passValue: 1
after passValue: 1
before passArray: 1 4 6 8 10
after passArray: 10 8 6 4 1

В примере, приведенном выше, значение переменной value не изменяется в функции main(), так как параметр value в функции passValue() 
был лишь копией фактической переменной value. Однако, поскольку массив в параметре функции passArray() является фактическим массивом, 
то passArray() напрямую изменяет значения его элементов!
                                                                                                                                        +-
Примечание: Если вы не хотите, чтобы функция изменяла значения элементов массива, переданного в нее в качестве параметра, то нужно сделать 
массив константным:

// Даже если array является фактическим массивом, внутри этой функции он должен рассматриваться как константный
void passArray(const int array[5])
{
    // Поэтому каждая из следующих строк вызовет ошибку компиляции!
    array[0] = 11;
    array[1] = 7;
    array[2] = 5;                       
    array[3] = 3;
    array[4] = 2;
}


Оператор sizeof и массивы

Оператор sizeof можно использовать и с массивами: он возвращает общий размер массива (длина массива умножена на размер одного элемента) в байтах. 
Обратите внимание, из-за того, как C++ передает массивы в функции, следующая операция не будет корректно выполнена с массивами, переданными в функции:

#include <iostream>
 
void printSize(int array[])
{
    std::cout << sizeof(array) << '\n'; // выводится размер указателя (об этом поговорим на соответствующем уроке), а не массива
}
 
int main()
{
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    std::cout << sizeof(array) << '\n'; // выводится размер массива
    printSize(array);
 
    return 0;
}

Результат выполнения программы:

32
4

По этой причине будьте осторожны при использовании оператора sizeof с массивами!


Определение длины фиксированного массива

Чтобы определить длину фиксированного массива, поделите размер всего массива на размер одного элемента массива:

#include <iostream>
 
int main()
{
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
 
    return 0;
}

Результат выполнения программы:

The array has 8 elements

Как это работает? Во-первых, размер всего массива равен длине массива, умноженной на размер одного элемента. 
Формула: размер_массива = длина_массива * размер_одного_элемента.

Используя алгебру, мы можем изменить это уравнение: длина_массива = размер_массива / размер_одного_элемента. 
sizeof(array) — это размер массива, а sizeof(array [0]) — это размер одного элемента массива. Соответственно, 
длина_массива = sizeof(array) / sizeof(array[0]). Обычно используется нулевой элемент в качестве элемента массива в уравнении, 
так как только он является единственным элементом, который гарантированно существует в массиве, независимо от его длины.

Это работает только если массив фиксированной длины, и вы выполняете эту операцию в той же функции, в которой объявлен массив.

Примечание: На следующих уроках мы будем использовать термин «длина» для обозначения общего количества элементов в массиве, 
и термин «размер», когда речь будет идти о байтах.


Индексирование массива вне диапазона

Помните, что массив длиной N содержит элементы от 0 до N-1. Итак, что произойдет, если мы попытаемся получить доступ к индексу 
массива за пределами этого диапазона? Рассмотрим следующую программу:

int main()
{
    int array[5]; // массив содержит 5 простых чисел
    array[5] = 14;
 
    return 0;
}

Здесь наш массив имеет длину 5, но мы пытаемся записать значение в 6-й элемент (индекс 5).

Язык C++ не выполняет никаких проверок корректности вашего индекса. Таким образом, в вышеприведенном примере значение 14 будет помещено 
в ячейку памяти, где 6-й элемент существовал бы (если бы вообще был). Но, как вы уже догадались, это будет иметь свои последствия. 
Например, произойдет перезаписывание значения другой переменной или вообще сбой программы.

Хотя это происходит реже, но C++ также позволяет использовать отрицательный индекс, что тоже приведет к нежелательным результатам.

Правило: При использовании массивов убедитесь, что ваши индексы корректны и соответствуют диапазону вашего массива.

Тест
Задание №1
Объявите массив для хранения температуры (дробное число) каждого дня в году (всего 365 дней). Проинициализируйте массив значением 0.0 для каждого дня.
double temp[365] = {};

Ответ №1

Задание №2
Создайте перечисление со следующими перечислителями: chicken, lion, giraffe, elephant, duck и snake. Поместите перечисление в пространство имен. 
Объявите массив, где элементами будут эти перечислители и, используя список инициализаторов, инициализируйте каждый элемент соответствующим 
количеством лап определенного животного. В функции main() выведите количество ног у слона, используя перечислитель.

namespace animals
{
enum animal {
	chicken, 
	lion, 
	giraffe, 
	elephant, 
	duck,  
	snake,
	num_animals
};
}

int const paws[num_animals]={2,4,4,4,2,0};

int main(){
	std::cout << "Слон має " << paws[lion] << " лап\n";
}



Ответ №2

