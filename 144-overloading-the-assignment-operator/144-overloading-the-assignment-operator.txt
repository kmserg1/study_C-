Урок No 144. Перегрузка оператора присваивания


Оператор присваивания ( = ) используется для копирования значений из одного объекта в другой (уже существующий)
объект.

Оглавление:
1. Присваиваниеvs. Конструктор копирования
2. Перегрузка оператора присваивания
3. Самоприсваивание
4. Обнаружениеи обработка самоприсваивания
5. Операторприсваивания по умолчанию


Присваивание vs. Конструктор копирования

Конструктор копирования и оператор присваивания выполняют почти идентичную работу: оба копируют значения из
одного объекта в значения другого объекта. Однако конструктор копирования используется при инициализации новых
объектов, тогда как оператор присваивания заменяет содержимое уже существующих объектов. Всё просто:

 Если новый объект создан перед выполнением операции копирования, то используется конструктор копирования
(передача или возврат объектов выполняются по значению).

 Если создания нового объекта не было, а работа ведется с уже существующим объектом, то используется оператор
присваивания.


Перегрузка оператора присваивания

Перегрузка оператора присваивания ( = ) довольно-таки проста и выполняется через метод класса, но есть один нюанс:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &copy) :
20 		m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)
21 	{
22 		// Нет необходимости выполнять проверку denominator здесь, так как эта проверка уже осуществлена в конструкторе по
23 		std::cout << "Copy constructor worked here!\n"; // просто, чтобы показать, что это работает
24 	}
25
26 	// Перегрузка оператора присваивания
27 	Drob& operator= (const Drob &drob)
28 	{
29 		// Выполняем копирование значений
30 		m_numerator = drob.m_numerator;
31 		m_denominator = drob.m_denominator;
32
33 		// Возвращаем текущий объект, чтобы иметь возможность связать в цепочку выполнение нескольких операций присваивания
34 		return *this;
35 	}
36
37 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
38
39 };
40
41 std::ostream& operator<<(std::ostream& out, const Drob &d1)
42 {
43 	out << d1.m_numerator << "/" << d1.m_denominator;
44 	return out;
45 }
46
47 int main()
48 {
49 	Drob sixSeven(6, 7);
50 	Drob d;
51 	d = sixSeven; // вызывается перегруженный оператор присваивания
52 	std::cout << d;
53
54 	return 0;
55 }

Результат выполнения программы:
6/7

До этого момента всё ок.Функция перегрузки operator=() возвращает скрытый указатель *this, и мы даже можем связать
выполнение нескольких операций присваиванияв месте:

1 int main()
2 {
3 	Drob d1(6,7);
4 	Drob d2(8,3);
5 	Drob d3(10,4);
6
7 	d1 = d2 = d3; // цепочка операций присваивания
8
9 	return 0;
10 }


Самоприсваивание

Здесь уже становится интереснее. Самоприсваивание — это тот нюанс, о котором упоминалось выше. Язык C++ позволяет
выполнять самоприсваивание:

1 int main()
2 {
3 	Drob d1(6,7);
4 	d1 = d1; // самоприсваивание
5
6 	return 0;
7 }

В примере, приведенном выше, самоприсваивание не приведет к изменению состояния чего-либо и будет лишь пустой
тратой времени и ресурсов. В большинстве случаев самоприсваивание не следует выполнять вообще.
Кроме того, в случаях, когда используется динамическое выделение памяти, самоприсваивание может быть даже
опасным:

1 #include <iostream>
2
3 class SomeString
4 {
5 private:
6 	char *m_data;
7 	int m_length;
8
9 public:
10 	SomeString(const char *data="", int length=0) :
11 		m_length(length)
12 	{
13 		if (!length)
14 			m_data = nullptr;
15 		else
16 			m_data = new char[length];
17
18 		for (int i=0; i < length; ++i)
19 			m_data[i] = data[i];
20 	}
21
22
23 	SomeString& operator= (const SomeString &str);
24
25 	friend std::ostream& operator<<(std::ostream& out, const SomeString &s);
26 };
27
28 std::ostream& operator<<(std::ostream& out, const SomeString &s)
29 {
30 	out << s.m_data;
31 	return out;
32 }
33
34 // Перегрузка оператора присваивания (плохой вариант перегрузки)
35 SomeString& SomeString::operator= (const SomeString &str)
36 {
37 	// Если m_data уже имеет значение, то удаляем это значение
38 	if (m_data) delete[] m_data;
39
40 	m_length = str.m_length;
41
42 	// Копируем значение из str в m_data неявного объекта
43 	m_data = new char[str.m_length];
44 	for (int i=0; i < str.m_length; ++i)
45 		m_data[i] = str.m_data[i];
46
47 	// Возвращаем текущий объект
48 	return *this;
49 }
50
51 int main()
52 {
53 	SomeString anton("Anton", 7);
54 	SomeString employee;
55 	employee = anton;
56 	std::cout << employee;
57
58 	return 0;
59 }

Запустите программу, и вы увидите, что выведется Anton, как и ожидалось.

Теперь замените функцию main() на следующую:
1 int main()
2 {
3 	SomeString anton("Anton", 7);
4 	anton = anton;
5 	std::cout << anton;
6
7 	return 0;
8 }

В результате вы получите либо значение-мусор, либо сбой.

Рассмотрим, что происходит при выполнении операции присваивания, когда неявный и переданный в качестве аргумента
объекты являются объектом anton. В этомслучае m_data равно str.m_data (т.е. Anton). Первое,что произойдет —
функция перегрузки проверит, является ли уже значением неявного объекта строка Anton . Если является,то произойдет
удаление этого значения, чтобы не случилась утечка памяти. Т.е.значение m_data неявного объекта удаляется, но дело в
том, что str.m_data имеет тот же адрес памяти (значение которого удаляется)! Это означает, что str.m_data станет
висячим указателем.
Позже, когда мыбудем копировать данные из параметра str функции перегрузки в наш неявный объект, мы будем
обращаться к висячему указателю str.m_data. Это приведет к тому, что мы либо скопируем данные-мусор, либо
попытаемся получить доступ к памяти, которую наше приложение больше не имеет в распоряжении (произойдет сбой).


Обнаружение и обработка самоприсваивания

К счастью, мы можем обнаружить выполнение самоприсваивания. Это делается с помощью достаточно простой проверки в
функции перегрузки operator=():

1 // Перегрузка оператора присваивания (хороший вариант, его и используйте)
2 Drob& Drob::operator= (const Drob &drob)
3 {
4  	// Проверка на самоприсваивание
5 	if (this == &drob)
6 		return *this;
7
8 	// Выполняем копирование значений
9 	m_numerator = drob.m_numerator;
10 	m_denominator = drob.m_denominator;
11
12 	// Возвращаем текущий объект
13 	return *this;
14 }

Проверяя, является ли наш неявный объект тем же, что и передаваемый в качестве параметра, мы сможем сразу же
возвратить его без выполнения какого-либо кода.

Обратите внимание, нет необходимости выполнять проверку на самоприсваивание в конструкторе копирования. Это
связано с тем, что конструктор копирования вызывается только при создании новых объектов, а способа присвоить только
что созданный объектсамому себе, чтобы вызвать конструктор копирования нет.


Оператор присваивания по умолчанию

В отличие от других операторов, компилятор автоматически предоставит открытый оператор присваивания по
умолчанию для вашего класса при его использовании, если вы не предоставите его самостоятельно. В операторе
присваивания по умолчанию выполняется почленное присваивание (которое является аналогичным почленной
инициализации, используемой в конструкторах копирования, предоставляемых языком C++ по умолчанию).
Как и с другими конструкторами и операторами, вы можете запретить выполнение операции присваивания с объектами
ваших классов, сделав оператор присваивания закрытым или используя ключевое слово delete:

1 #include <iostream>
2 #include <cassert>
3
4 class Drob
5 {
6 private:
7 	int m_numerator;
8 	int m_denominator;
9
10 public:
11 	// Конструктор по умолчанию
12 	Drob(int numerator=0, int denominator=1) :
13 		m_numerator(numerator), m_denominator(denominator)
14 	{
15 		assert(denominator != 0);
16 	}
17
18 	// Конструктор копирования
19 	Drob(const Drob &copy) = delete;
20
21 	// Перегрузка оператора присваивания
22 	Drob& operator= (const Drob &drob) = delete; // нет созданию копий объектов через операцию присваивания!
23
24 	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);
25
26 };
27
28 std::ostream& operator<<(std::ostream& out, const Drob &d1)
29 {
30 	out << d1.m_numerator << "/" << d1.m_denominator;
31 	return out;
32 }
33
34 int main()
35 {
36 	Drob sixSeven(6, 7);
37	Drob d;
38 	d = sixSeven; // ошибка компиляции, operator= был удален
39 	std::cout << d;
40
41 	return 0;
42 }
