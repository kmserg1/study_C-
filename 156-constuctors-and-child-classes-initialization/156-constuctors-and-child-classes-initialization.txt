Урок No 156. Конструкторы и инициализация дочерних классов

На предыдущих уроках мы изучили основы наследования в языке C++ и порядок инициализации дочерних классов. На
этом уроке мы подробнее рассмотрим роль конструкторов в инициализации дочерних классов.

Оглавление:
1. Конструкторы и инициализация
2. Инициализация членов родительского класса
3. Теперь мы можем сделать наши члены private
4. Еще один пример
5. Цепочки наследований
6. Деструкторы
7. Заключение
8. Тест


Конструкторы и инициализация

А помогать нам в этом будут классы Parent и Child:
1 class Parent
2 {
3 public:
4 	int m_id;
5
6 	Parent(int id=0)
7 		: m_id(id)
8 	{
9 	}
10
11 	int getId() const { return m_id; }
12 };
13
14 class Child: public Parent
15 {
16 public:
17 	double m_value;
18
19 	Child(doublevalue=0.0)
20 		: m_value(value)
21 	{
22 	}
23
24 	double getValue() const { return m_value; }
25 };

С обычными (не дочерними) классами конструктору нужно заморачиваться только с членами своего класса. Например,
объект класса Parent создается следующи мобразом:

1 int main()
2 {
3 	Parent parent(7); // вызываетсяконструкторParent(int)
4
5 	return 0;
6 }

Вот что на самом деле происходит при инициализации объекта parent :
 выделяется память для объекта parent ;
 вызывается соответствующий конструктор класса Parent;
 список инициализации инициализирует переменные;
 выполняется тело конструктора;
 точка выполнения возвращается обратно в caller.

Всё довольно-таки просто. С дочерними классами дела обстоят несколькосложнее:
1 int main()
2 {
3 	Child child(1.5); // вызываетсяконструкторChild(double)
4
5 	return 0;
6 }

Вот что происходит при инициализации объекта child :
 выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта
класса Child);
 вызывается соответствующий конструктор класса Child;
 создается объект класса Parent с использованием соответствующего конструктора класса Parent. Если такой конструктор
программистом не предоставлен, то будет использоваться конструктор по умолчанию класса Parent;
 список инициализации инициализирует переменные;
 выполняется тело конструктора класса Child;
 точка выполнения возвращается обратно в caller.

Единственное различие между инициализацией объектов обычного и дочернего класса заключается в том, что при
инициализации объекта дочернего класса, сначала выполняется конструктор родительского класса (для инициализации части
родительского класса) и только потом уже выполняется конструктор дочернего класса.


Инициализация членов родительского класса

Одним из недостатков нашего дочернего класса Child является то, что мы не можем инициализировать m_id при создании
объекта класса Child. Что, если мы хотим задать значение как для m_value (части Child), так и для m_id (частиParent)?
Новички часто пытаются решить эту проблему следующим образом:

1 class Child: public Parent
2 {
3 public:
4 	double m_value;
5
6 	Child(double value=0.0, int id=0)
7 	// Не сработает
8 		: m_value(value),m_id(id)
9 	{
10 	}
11
12 	double getValue() const { return m_value; }
13 };

Этохорошая попытка и почти правильная идея. Нам определенно нужно добавить еще один параметр в наш конструктор,
иначе C++ не будет понимать, каким значением мы хотим инициализировать m_id.
Однако C++ запрещает дочерним классам инициализировать наследуемые переменные - члены родительского класса в списке
инициализации своего конструктора. 
Другими словами, значение переменной может быть задано только в списке инициализации конструктора, принадлежащего 
тому же классу,что и переменная-член.

Почему C++ так делает? Ответ связан с константными переменными и ссылками. Подумайте, что произошло бы, если бы
m_id был const. Поскольку константы должны быть инициализированы значениями при создании, то конструктор
родительского класса должен установить это значение при создании переменной-члена. В тоже время конструктор дочернего
класса выполняется только после выполнения конструкторов родительского класса. Каждый дочерний класс имел бы тогда
возможность инициализировать эту переменную, потенциально изменяя её значение! Ограничивая инициализацию
переменных конструктором класса, к которому принадлежат эти переменные, язык C++ гарантирует, что все переменные будут
инициализированы только один раз.

Конечным результатом выполнения кода, приведенного выше, является ошибка, так как m_id у наследован от класса Parent, а
только ненаследуемые переменные-члены могут быть изменены в списке инициализации конструктора класса Child.
Однако наследуемые переменные могут по-прежнему изменять свои значения в теле констру кторачерез операцию
присваивания. Следовательно, новички часто пытаются сделать следующее:

1 class Child: publicParent
2 {
3 public:
4 	doublem_value;
5
6 	Child(doublevalue=0.0, intid=0)
7 		: m_value(value)
8 	{
9 		m_id = id;
10 	}
11
12 	doublegetValue() const { return m_value; }
13 };

Хотя подобное действительно сработает в данном случае, но это не сработает, если m_id будет константой или ссылкой
(поскольку константы и ссылки должны быть инициализированы в списке инициализации конструктора). Кроме того, это
неэффективно, так как для m_id присваивают значение дважды: первый раз в списке инициализации конструктора класса
Parent, а затем в теле конструктора класса Child. И, наконец, что, если классу Parent необходим доступ к этому значению во
время инициализации?

Итак, как правильно инициализировать m_id при создании объекта класса Child?

Во всех наших примерах, при создании объекта класса Child, вызывался конструктор поу молчанию класса Parent.
Почему так? Потому что мы не указывали иначе!

К счастью, язык C++ предоставляет нам возможность явно выбирать конструктор класса Parent для выполнения
инициализации части Parent! Для этого нам необходимо просто добавить вызов нужного нам конструктора в списке
инициализации конструктора дочернего класса:

1 class Child: public Parent
2 {
3 public:
4 	double m_value;
5
6 	Child(double value=0.0, int id=0)
7 		: Parent(id), // вызывается конструктор Parent(int) со значением id!
8 	m_value(value)
9 	{
10 	}
11
12 	double getValue() const { return m_value; }
13 };

Теперь при выполнении следующего кода:

1 int main()
2 {
3 	Child child(1.5,7); // вызывается конструктор Child(double, int)
4 	std::cout << "ID: "<< child.getId() << '\n';
5 	std::cout << "Value: " << child.getValue() << '\n';
6
7 	return 0;
8 }

Конструктор Parent(int) будет использоваться для инициализации m_id значением 7 , а конструктор дочернего класса
будет использоваться для инициализации m_value значением 1.5!

Результат выполнения программы:
ID: 7
Value: 1.5

Рассмотрим детально, что происходит:
 Выделяется память для объекта child.
 Вызывается конструктор Child(double, int),где value = 1.5, а id =7 .
 Компилятор смотрит, запрашиваем ли мы какой-нибудь конкретный конструктор класса Parent. И видит, что
запрашиваем! Поэтому вызывается Parent(int) с параметром id, которому мы до этого присвоили значение 7.
 Список инициализации конструктора класса Parent присваивает для m_id значение 7.
 Выполняется тело конструктора класса Parent, которое ничего не делает.
 Завершается выполнения конструктора класса Parent.
 Список инициализации конструктора класса Child присваивает для m_value значение 1.5 .
 Выполняется тело конструктора класса Child, которое ничего не делает.
 Завершается выполнение конструктора класса Child.

Это может показаться несколько сложным, но на самом деле всё очень просто. Всё, что происходит — это вызов конструктором
класса Child конкретного конструктора класса Parent для инициализации части Parent объекта класса Child. Поскольку m_id
находится в части Parent, то только конструктор класса Parent может инициализировать это значение.
Обратите внимание, не имеет значения, где в списке инициализации конструктора класса Child вызывается конструктор класса
Parent — он всегда будет выполняться первым.


Теперь мы можем сделать наши члены private

Теперь, когда мы знаем о инициализации членов родительского класса, нет никакой необходимости сохранять наши
переменные-члены открытыми. Мы сделаем их private, как и должно быть.

В качестве напоминания: Доступ к членам public открыт для всех. Доступ к членам private открыт только для других
членов этого же класса. Обратите внимание, это означает, что дочерние классы не могут напрямую обращаться к
закрытым членам родительского класса! Дочерним классам нужно использовать геттеры и сеттеры для доступа к этим
членам.
Например:

1 #include <iostream>
2
3 class Parent
4 {
5 private: // наш m_id теперь закрытый
6 	int m_id;
7
8 public:
9 	Parent(int id=0)
10 		: m_id(id)
11 	{
12 	}
13
14 	int getId() const { return m_id; }
15 };
16 class Child: public Parent
17 {
18 private: // наш m_value теперь закрытый
19 	doublem_value;
20
21 public:
22 	Child(double value=0.0, int id=0)
23 		: Parent(id), // вызывается конструктор Parent(int) со значением id!
24 		  m_value(value)
25 	{
26 	}
27
28 	double getValue() const { return m_value; }
29 };
30
31 int main()
32 {
33 	Child child(1.5, 7); // вызывается конструктор Child(double,int)
34 	std::cout<<"ID: " << child.getId()<<'\n';
35 	std::cout<<"Value: " << child.getValue()<<'\n';
36
37 	return0;
38 }

В коде, приведенном выше, мы делаем m_id и m_value закрытыми. Для их инициализации используются соответствующие
конструкторы, а для доступа — открытые функции доступа (геттеры).

Результат выполнения программы:
ID: 7
Value: 1.5

Еще один пример
Рассмотрим еще пару классов,с которыми мы работали ранее:

1 #include <iostream>
2 #include <string>
3
4 class Human
5 {
6 public:
7 	std::string m_name;
8 	int m_age;
9
10 	Human(std::string name ="", int age= 0)
11 		: m_name(name), m_age(age )
12 	{
13 	}
14
15 	std::string getName()const{ returnm_name; }
16 	int getAge()const{ returnm_age; }
17 };
18
19 // BasketballPlayer открыто наследует класс Human
20 class BasketballPlayer: public Human
21 {
22 public:
23 	double m_gameAverage;
24 	int m_points;
25
26 	BasketballPlayer(double gameAverage = 0.0,int points = 0)
27 		: m_gameAverage(gameAverage), m_points(points)
28 	{
29 	}
30 };

Как мы уже знаем, класс BasketballPlayer только инициализирует свои собственные члены и не указывает использование
конкретного конструктора класса Human. Это означает,что каждый созданный объект класса BasketballPlayer будет
использовать конструктор по умолчанию класса Human, который будет инициализировать переменную-член name пустым
значением, а age — значением 0. Поскольку мы хотим назвать нашего BasketballPlayer и указать его возраст при его
создании, то мы должны изменить этот конструктор, добавив необходимые параметры.

Вот наши обновленные классы с членами private и с вызовом конкретного конструктора класса Human:

1 #include <string>
2
3 class Human
4 {
5 private:
6 	std::string m_name;
7 	int m_age;
8
9 public:
10 	Human(std::string name ="", int age= 0)
11 		: m_name(name), m_age(age )
12 	{
13 	}
14
15 	std::string getName()const{ returnm_name; }
16 	int getAge()const{ returnm_age; }
17
18 };
19 // BasketballPlayer открыто наследует класс Human
20 class BasketballPlayer: public Human
21 {
22 private:
23 	double m_gameAverage;
24 	int m_points;
25
26 public:
27 	BasketballPlayer(std::string name= "",int age = 0,
28 	double gameAverage =0.0, intpoints =0)
29 		: Human(name, age), // вызывается Human(std::string, int) для инициализации членов name и age
30 		m_gameAverage(gameAverage), m_points(points)
31 	{
32 	}
33
34 	double getGameAverage() const { return m_gameAverage; }
35 	int getPoints()const { retur nm_points; }
36 };

Теперь мы можем создавать объекты класса BasketballPlayer следующим образом:
1 int main()
2 {
3 	BasketballPlayer anton("Anton Ivanovuch", 45,300, 310);
4
5 	std::cout<<anton.getName() << '\n';
6 	std::cout<<anton.getAge()<<'\n';
7 	std::cout<<anton.getPoints()<<'\n';
8
9 	return 0;
10 }

Результат выполнения программы:
AntonIvanovuch
45
310

Как вы можете видеть, всё корректно инициализировано.


Цепочки наследований

Классы в цепочке наследований работают аналогичным образом:

1 #include <iostream>
2
3 class A
4 {
5 public:
6 	A(int a)
7 	{
8 		std::cout << "A: " << a <<'\n';
9 	}
10 };
11
12 class B: public A
13 {
14 public:
15 	B(int a, double b)
16 		: A(a)
17 	{
18 		std::cout << "B: " << b <<'\n';
19 	}
20 };
21
22 class C: public B
23 {
24 public:
25 	C(int a, double b, char c)
26 		: B(a,b)
27 	{
28 		std::cout << "C: " << c <<'\n';
29 	}
30 };
31
33 {
32 int main()
34 	C c(7, 5.4, 'D');
35
36 return 0;
37 }

В этом примере класс C наследует свойства класса B, который наследует свойства класса A. Что произойдет при создании
объекта класса C? 
А вот что:
 функция main() вызовет C(int, double, char);
 конструктор класса C вызовет B(int, double) ;
 конструктор класса B вызовет A(int);
 поскольку A не наследует никакой класс, то построение начнется именно с этого класса;
 построение A выполнено, выводится значение 7 и выполнение переходит в B;
 класс B построен, выводится значение 5.4 и выполнение переходит в C;
 класс C построен, выводится D и выполнение возвращается обратно в main();
 Финиш!

Таким образом, результат выполнения программы:
A: 7
B: 5.4
C: D

Стоит отметить, что конструкторы дочернего класса могут вызывать конструкторы только того родительского класса,от
которого они напрямую наследуют. Следовательно, конструктор класса C неможет напрямую вызывать или передавать
параметры в конструктор класса A. Конструктор класса C может вызывать только конструктор класса B (который уже, в свою
очередь, вызывает конструктор класса A).


Деструкторы

При уничтожении дочернего класса, каждый деструктор вызывается в порядке обратном построению классов. В примере,
приведенном выше, при уничтожении объекта класса С, сначала вызывается деструктор класса C, затем деструктор класса B, а
затем уже деструктор класса A.


Заключение

При инициализации объектовд очернего класса, конструктор дочернего класса отвечает за то,какой конструктор
родительского класса вызывать. Если этотконструктор явно не указан, то вызывается конструктор по умолчанию
родительского класса. Если же компилятор не может найти конструктор по умолчанию родительского класса (или этот
конструктор не может быть создан автоматически), то компилятор выдаст ошибку.


Тест

Реализуем наш пример с Фруктом, о котором мы говорили на уроке No 153. Создайте родительский класс Fruit, который имеет
два закрытых члена: name (std::string) и color (std::string). Создайте класс Apple, который наследует свойства Fruit. У Apple
должен быть дополнительный закрытый член: fiber (тип double). Создайте класс Banana, который также наследует класс Fruit.
Banana не имеет дополнительных членов.

Следующий код:
1 int main()
2 {
3 	const Apple a("Reddelicious","red", 7.3);
4 	std::cout << a;
5
6 	const Banana b("Cavendish","yellow");
7 	std::cout << b;
8
9 	return 0;
10 }

Должен выдавать следующий результат:
Apple(Red delicious,red,7.3)
Banana(Cavendish, yellow)

Подсказка: Поскольку a и b являются const, то убедитесь, что ваши параметры и функции соответствуют const.

Ответ
