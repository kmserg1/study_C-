Урок No 134. Перегрузка операторов через методы класса


Перегрузка операторов через методы класса очень похожа на перегрузку операторов через дружественные функции.
Но при перегрузке оператора через метод класса левым операндом становится неявный объект, на который указывает
скрытый указатель *this.

Оглавление:
1. Перегрузка операторов через методы классов
2. Не всё может быть перегружено через дружественные функции
3. Не всё может быть перегружено через методы класса
4. Какой способ перегрузки и когда следует использовать?


Перегрузка операторов через методы классов

Вспомним, как выглядит перегрузка оператора через дружественную функцию:

1 #include <iostream>
2
3 class Dollars
4 {
5 private:
6 	int m_dollars;
7
8 public:
9 	Dollars(int dollars) { m_dollars = dollars; }
10
11 	// Выполняем Dollars + int
12 	friend Dollars operator+(const Dollars &dollars, int value);
13
14 	int getDollars() { return m_dollars; }
15 };
16
17 // Примечание: Эта функция не является методом класса!
18 Dollars operator+(const Dollars &dollars, int value)
19 {
20 	return Dollars(dollars.m_dollars + value);
21 }
22
23 int main()
24 {
25 Dollars dollars1(7);
26 Dollars dollars2 = dollars1 + 3;
27 std::cout << "I have " << dollars2.getDollars() << " dollars.\n";
28
29 return 0;
30 }

Конвертация перегрузки через дружественную функцию в перегрузку через метод класса довольно-таки проста:

 Перегружаемый оператор определяется как метод класса, вместо дружественной функции ( Dollars::operator+
вместо friend operator+ ).

 Левый параметр из функции перегрузки вы брасывается, вместо него — неявный объект, на который указывает
указатель *this.

 Внутри тела функции перегрузки все ссылки на левый параметр могут быть удалены (например, dollars.m_dollars
становится m_dollars , который неявно ссылается на текущий объект с помощью указателя *this).
Теперь та же перегрузка оператора + , но уже через метод класса:

1 #include <iostream>
2
3 class Dollars
4 {
5 private:
6 	int m_dollars;
7
8 public:
9 	Dollars(int dollars) { m_dollars = dollars; }
10
11 	// Выполняем Dollars + int
12 	Dollars operator+(int value);
13
14 	int getDollars() { return m_dollars; }
15 };
16
17 // Примечание: Эта функция является методом класса!
18 // Вместо параметра dollars в перегрузке через дружественную функцию здесь неявный параметр, на который указывает указатель
19 Dollars Dollars::operator+(int value)
20 {
21 	return Dollars(m_dollars + value);
22 }
23
24 int main()
25 {
26 	Dollars dollars1(7);
27 	Dollars dollars2 = dollars1 + 3;
28 	std::cout << "I have " << dollars2.getDollars() << " dollars.\n";
29
30 	return 0;
31 }

Обратите внимание, использование оператора + не изменяется (в обоих случаях dollars1 + 3 ), но реализация
отличается. Наша дружественная функция с двумя параметрами становится методом класса с одним параметром, причем
левый параметр в перегрузке через дружественную функцию ( &dollars ), в перегрузке через метод класса становится
неявным объектом, накоторый указывает указатель *this.

Рассмотрим детально, как обрабатывается выражение dollars1 + 3.

В перегрузке через дружественную функцию выражение dollars1 + 3 приводит к вызову функции operator+(dollars1,3). 
Здесь есть два параметра.
В перегрузке через метод класса выражение dollars1 + 3 приводит к вызову dollars1.operator+(3). Обратите
внимание, здесь уже один явный параметр, а dollars1 используется как префикс к operator+ . Этот префикс компилятор
неявно конвертирует в скрытый левый параметр, на который указывает указатель *this. Таким образом,
dollars1.operator+(3) становится вызовом operator+(&dollars1, 3), что почти идентично перегрузке через
дружественную функцию.

Итак, если мы можем перегрузить оператор через дружественную функцию или через метод класса, то что тогда выбрать?
Прежде чем мы дадим ответ на этот вопрос, вам нужно узнать еще несколько деталей.


Не всё может быть перегружено через дружественные функции.

Операторы присваивания ( = ), индекса ( [] ), вызова функции ( () ) и выбора члена ( -> ) перегружаются через методы
класса — это требование языка C++.


Не всё может быть перегружено через методы класса

На уроке о перегрузке операторов ввода и вывода мы перегружали оператор вывода << для класса Point через
дружественную функцию:

1 #include <iostream>
2
3 class Point
4 {
5 private:
6 	double m_x, m_y, m_z;
7
8 public:
9 	Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
10 	{
11 	}
12
13 	friend std::ostream& operator<< (std::ostream &out, const Point &point);
14 };
15
16 std::ostream& operator<< (std::ostream &out, const Point &point)
17 {
18  	// Поскольку operator<<() является другом класса Point, то мы имеем доступ к закрытым членам Point
19 	out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";
20
21 	return out;
22 }
23
24 int main()
25 {
26 Point point1(5.0, 6.0, 7.0);
27
28 std::cout << point1;
29
30 return 0;
31 }

Однако через метод класса перегрузить оператор << мы не сможем. 
Почему? 

Потому что при перегрузке через метод класса в качестве левого операнда используется текущий объект. 

В нашем же случае левым операндом является объект типа std::ostream. std::ostream является частью Cтандартной 
библиотеки C++. Мы не можем использовать std::ostream в качестве левого неявного параметра, на который бы указывал 
скрытый указатель *this, так как указатель *this может указывать только на текущий объект текущего класса, члены 
которого мы можем изменить, поэтому перегрузка оператора << должна осуществляться через дружественную функцию.

Аналогично, хотя мы можем перегрузить operator+(Dollars, int) через метод класса (как мы делали выше), мы не
можем перегрузить operator+(int, Dollars) через метод класса, поскольку int теперь является левым операндом, на
который указатель *this указывать не может.

Перегрузка операторов через методы класса не используется, если левый операнд не является классом (например, int),
или это класс, который мы не можем изменить (например, std::ostream).


Какой способ перегрузки и когда следует использовать?

В большинстве случаев язык C++ позволяет выбирать самостоятельно способ перегрузки операторов.
Но при работе с бинарными операторами, которые не изменяют левый операнд (например, operator+()), обычно
используется перегрузка через обычную или дружественную функцию, поскольку такая перегрузка работает для всех
типов данных параметров (даже если левый операнд не является объектом класса или является объектом класса, который
изменить нельзя). 
Перегрузка через обычную/дружественную функцию имеет дополнительное преимущество «симметрии», так как все
операнды становятся явными параметрами (а не как у перегрузки через метод класса, когда левый операнд
становится неявным объектом, на который указывает указатель *this).

При работе с бинарными операторами, которые изменяют левый операнд (например, operator+=()), обычно используется
перегрузка через методы класса. В этих случаях левым операндом всегда является объект класса, на который указывает
скрытый указатель *this.

Унарные операторы обычно тоже перегружаются через методы класса, так как в таком случае параметры не используются
вообще.

Поэтому:

 Для операторов присваивания ( = ), индекса ( [] ), вызовафункции ( () ) или выбора члена ( -> ) используйте
перегрузку через методы класса.

 Для унарных операторов используйте перегрузку через методы класса.

 Для перегрузки бинарных операторов, которые изменяют левый операнд (например, operator+=()) используйте
перегрузку через методы класса, если это возможно.

 Для перегрузки бинарных операторов, которые не изменяют левый операнд (например, operator+()) используйте
перегрузку через обычные/дружественные функции.
