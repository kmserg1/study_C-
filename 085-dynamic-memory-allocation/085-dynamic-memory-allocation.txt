УрокNo85. Динамическое выделение памяти


Язык С++ поддерживает три основныхтипа выделения (или «распределения») памяти, с двумя из которых, мы уже знакомы:

 Статическое выделение памяти выполняется для статических и глобальных переменных. Память выделяется один раз
(при запуске программы) и сохраняется на протяжении работы всей программы.

 Автоматическое выделение памяти выполняется для параметров функции и локальных переменных. Память
выделяется при входе в блок, в котором находятся эти переменные, и удаляется привыходе из него.

 Динамическое выделение памяти является темой этого урока.

Оглавление:
1. Динамическое выделение переменных
2. Как работает динамическое выделение памяти?
3. Освобождение памяти
4. Висячие указатели
5. Оператор new
6. Нулевые указатели и динамическое выделение памяти
7. Утечка памяти
8. Заключение


Динамическое выделение переменных

Как статическое, так и автоматическое распределение памяти имеют два общих свойства:
 Размер переменной/массива должен быть известен во время компиляции.
 Выделение и освобождение памяти происходит автоматически (когда переменная создается/уничтожается).

В большинстве случаев с этим всё ОК. Однако, когда дело доходит до работы с пользовательским вводом, то эти ограничения
могут привести к проблемам.
Например, при использовании строки для хранения имени пользователя, мы не знаем наперед насколько длинным оно будет,
пока пользователь его не введет. Или намнужно создать игру с непостоянным количеством монстров (во время игры одни
монстры умирают, другие появляются, пытаясь, таким образом, убить игрока).

Если нам нужно объявить размер всех переменных во время компиляции, тосамое лучшее, что мыможемс делать — это
попытаться угадать их максимальный размер, надеясь, что этого будет достаточно:

1 charname[30]; // будем надеяться,чтопользователь введет имя длиной менее 30 символов!
2 Monster monster[30]; // 30 монстров максимум
3 Polygon rendering[40000]; //этому 3D-рендерингу лучше состоять из менее чем 40000 полигонов!


Это плохое решение, по крайней мере, по трем причинам:

Во-первых, теряется память, если переменные фактически неиспользуются или используются, но не все. Например, если мы
выделим 30 символов для каждого имени, но имена в среднем будут занимать по 15 символов, то потребление памяти
получится в двараза больше, чем нам нужно на самом деле. Или рассмотрим массив rendering: если он использует только 
20000 полигонов, то память для других 20000 полигонов фактически тратится впустую (т.е.не используется)!

Во-вторых, память для большинства обычных переменных (включая фиксированные массивы) выделяется из специального
резервуара памяти — стека. Объем памяти стека в программе, как правило, невелик: в Visual Studio он по умолчанию равен
1МБ. Если вы превысите это значение, то произойдет переполнение стека, и операционная система автоматически завершит
выполнение вашей программы.

В VisualStudio это можно проверить,запустив следующий фрагмент кода:

1 int main()
2 {
3   int array[1000000000]; // выделяем 1 миллиард целочисленных значений
4 }

Лимит в 1 МБ памяти может быть проблематичным для многих программ, особенно где используется графика.

В-третьих, и самое главное, это может привести к искусственным ограничениям и/или переполнению массива.
Что произойдет, если пользователь попытается прочесть 500 записей с диска, но мы выделили память максимум
для 400?
Либо мы выведем пользователю ошибку, что максимальное количество записей — 400, либо (в худшем случае) выполнится
переполнение массива и затем что-то очень нехорошее.

К счастью, эти проблемы легко устраняются с помощью динамического выделения памяти. Динамическое выделение
памяти — этоспособ запроса памяти из операционной системы запущенными программами по мере необходимости. Эта
память не выделяется из ограниченной памяти стека программы, а выделяется из гораздо большего хранилища, управляемого
операционной системой — кучи. На современных компьютерах размер кучи может составлять гигабайты памяти.
Для динамического выделения памяти одной переменной используется оператор new:

1 new int; // динамически выделяем целочисленную переменную и сразу же отбрасываем результат (так как нигде его не сохраняем)

В примере, приведенном выше, мы запрашиваем выделение памяти для целочисленной переменной из операционной системы.
Оператор new возвращает указатель, содержащий адрес выделенной памяти. Для доступа к выделенной памяти создается указатель:

1 int *ptr = new int; // динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы затем иметь доступ к ней

Затем мы можем разыменовать указатель для получения значения:

1 *ptr = 8; // присваиваем значение 8 только что выделенной памяти

Вот один из случаев, когда указатели полезны. Без указателя с адресом на только что выделенную память у нас не было бы
способа получить доступ к ней.


Как работает динамическое выделение памяти?

На вашем компьютере имеется память (возможно, большая её часть), которая доступна для использования программами. При
запуске программы ваша операционная система загружает эту программу в некоторую часть этой памяти. И эта память,
используемая вашей программой, разделена на несколько частей, каждая из которых выполняет определенную задачу. Одна
часть содержит ваш код, другая используется для выполнения обычных операций (отслеживание вызываемых функций,
создание и уничтожение глобальных и локальных переменныхи т.д.). Мы поговорим об этом чуть позже. Темне менее,
большая часть доступной памяти компьютера просто находится в ожидании запросов на выделение от программ.

Когда вы динамически выделяете память, то вы просите операционную систему зарезервировать часть этой памяти для
использования вашей программой. Если ОС может выполнить этот запрос, то возвращается адрес этой памяти обратно в вашу
программу. С этого момента и в дальнейшем ваша программа сможет использовать эту память, как только пожелает. Когда вы
уже выполнили с этой памятью всё, что было необходимо, то её нужно вернуть обратно в операционную систему, для
распределения между другими запросами.
В отличие от статического или автоматического выделения памяти, программа самостоятельно отвечает за запрос и обратный
возврат динамически выделенной памяти.


Освобождение памяти

Когда вы динамически выделяете переменную, то вы также можете её инициализировать посредством прямой
инициализации или uniform-инициализации (вС++11):

1 int *ptr1 =new int (7); // используемпрямую инициализацию
2 int *ptr2 =new int {8}; // используем uniform-инициализацию

Когда уже всё, что требовалось, выполнено с динамически выделенной переменной — нужно явно указать для С++ освободить
эту память. Для переменных это выполняется с помощью оператора delete:

1 // Предположим, что ptr ранее уже был выделен с помощью оператора new
2 delete ptr; // возвращаем память, на которую указывал ptr, обратно в операционную систему
3 ptr = 0; // делаем ptr нулевым указателем (используйте nullptr вместо  0в C++11)

Оператор delete на самом деле ничего не удаляет. Он просто возвращает память, которая была выделена ранее, 
обратно в операционную систему. Затем операционная система может переназначить эту память другому приложению
(или этому же снова).
Хотя может показаться, что мы удаляем переменную, но это не так! Переменная - указатель по-прежнему имеет ту же 
область видимости, что и раньше, и ей можно присвоить новое значение, как и любой другой переменной.
Обратите внимание, удаление указателя, не указывающего на динамически выделенную память, может привести к проблемам.


Висячие указатели

Язык C++ не предоставляет никаких гарантий относительно того, что произойдет с содержимым освобожденной памяти или со
значением удаляемого указателя. В большинстве случаев, память, возвращаемая операционной системе, будет содержать те
же значения, которые были у нее до освобождения, а указатель так и останется указывать на только что освобожденную
(удаленную) память.
Указатель, указывающий на освобожденную память, называется висячим указателем. Разыменование или удаление
висячего указателя приведет к неожиданным результатам. Рассмотрим следующую программу:

1 #include <iostream>
2
3 int main()
4 {
5 	int *ptr = new int;// динамически выделяем  целочисленную переменную
6 	*ptr = 8;// помещаем значение в выделенную ячейку памяти
7
8 	delete ptr; // возвращаем память обратно в операционную систему, ptr теперь является висячим указателем
9
10 	std::cout<< *ptr; // разыменование висячего указателя приведетк неожиданным результатам
11 	delete ptr; // попытка освободить память снова приведет к неожиданным результатам также
12
13 return0;
14 }

Впрограмме, приведенной выше, значение 8, которое ранее было присвоено динамической переменной, после
освобождения может и далее находиться там, а может и нет. Также возможно, что освобожденная память уже моглабыть
выделена другому приложению (или для собственного использования операционной системы), и попытка доступа к ней
приведет к тому, что операционная система автоматически прекратит выполнение вашей программы.
Процесс освобождения памяти может также привести и к созданию нескольких висячих указателей. Рассмотрим следующий
пример:

1 #include <iostream>
2
3 int main()
4 {
5 int *ptr = new int;// динамически выделяемцелочисленную переменную
6 int *otherPtr = ptr; //otherPtr теперь указывает на ту же самую выделенную память, что и ptr
7
8 delete ptr; // возвращаем память обратно в операционную систему. ptr и otherPtr теперь висячие указатели
9 ptr = 0; // ptr теперь уже nullptr
10
11 // Однако, otherPtr по-прежнему является висячим указателем!
12
13 return 0;
14 }

Есть несколько рекомендаций, которые могут здесь помочь:

 Во-первых,старайтесь избегать ситуаций, когда несколько указателей указывают на одну и ту же часть выделенной
памяти. Если это невозможно, то выясните, какой указатель из всех «владеет» памятью (и отвечает за её удаление), а какие
указатели просто получают доступ к ней.

 Во-вторых, когда вы удаляете указатель, и, если он не выходит из области видимости сразу же после удаления, то его
нужно сделать нулевым, т.е. присвоить значение 0 (или nullptr в С++11). Под «выходом из области видимости сразу же
после удаления» имеется в виду, что вы удаляете указатель в самом конце блока, в котором он объявлен.

Правило: Присваивайте удаленным указателям значение 0 (или nullptr в C++11), если они не выходят из области
видимости сразу же после удаления.


Оператор new

При запросе памяти из операционной системы в редких случаях она может быть не выделена (т.е. её может и не быть в
наличии).                                                                               
По умолчанию, если оператор new не сработал и память не выделилась, то генерируется исключение bad_alloc.
Если это исключение будет неправильно обработано (а именно так и будет, поскольку мы еще не рассматривали исключения
и их обработку), то программа просто прекратит свое выполнение (произойдет сбой) с ошибкой необработанного исключения.

Во многих случаях процесс генерации исключения оператором new (как и сбой программы) нежелателен, поэтому есть
альтернативная форма оператора new, которая возвращает нулевой указатель, если память не может быть выделена.
Нужно простодобавить константу std::nothrow между ключевым словом new и типом данных:

1 int *value = new (std::nothrow)int; // указатель value станет нулевым, если динамическое выделение целочисленной переменной не выполнится

В примере, приведенном выше, если оператор new не возвратит указатель с динамически выделенной памятью, то
возвратится нулевой указатель.
Разыменовывать его также не рекомендуется, так как это приведет к неожиданным результатам (скорее всего,к сбою в
программе). Поэтому наилучшей практикой является проверка всех запросов на выделение памяти для обеспечения того, что
эти запросы будут выполнены успешно и память выделится:

1 int *value = new (std::nothrow)int; // запрос на выделение динамической памяти для целочисленногозначения
2 if (!value)//обрабатываем случай, когдаnew возвращает null(т.е.памятьневыделяется)
3 {
4 	// Обработка этого случая
5 	std::cout << "Could not allocate memory";
6 }

Поскольку невыделение памяти оператором new происходит крайне редко, то обычно программисты забывают выполнять эту
проверку!


Нулевые указатели и динамическое выделение памяти

Нулевые указатели (указатели со значением 0 или nullptr) особенно полезны в процессе динамического выделения памяти.
Их наличие как бы сообщает нам: «Этому указателю не выделено никакой памяти». А это, в свою очередь, можно использовать
для выполнения условного выделения памяти:

1 // Если для ptr досих пор не выделено памяти, то выделяем её
2 if (!ptr)
3 	ptr = new int;

Удаление нулевого указателя ни на что не влияет. Таким образом, в следующем нет необходимости:

1 if (ptr)
2 	delete ptr;

Вместо этого вы можете просто написать:

1 delete ptr;

Если ptr не является нулевым, то динамически выделенная переменная будет удалена. Если значением указателя является
нуль, то ничего не произойдет.


Утечка памяти

Динамически выделенная память не имеет области видимости, т.е. она остается выделенной до тех пор, пока не будет явно
освобождена или пока ваша программа не завершит свое выполнение (и операционная системао чистит все буфера памяти
самостоятельно). Однако указатели, используемые для хранения динамически выделенных адресов памяти, следуют правилам
области видимости обычных переменных. Это несоответствие может вызвать интересное поведение, например:

1 void doSomething()
2 {
3 int *ptr = new int;
4 }

Здесь мы динамически выделяем целочисленную переменную, но никогда не освобождаем память через использование
оператора delete. Поскольку указатели следуют всем тем же правилам, что и обычные переменные, то, когда функция
завершит свое выполнение, ptr выйдет из области видимости. Поскольку ptr — это единственная переменная, хранящая
адрес динамически выделенной целочисленной переменной,то, когда ptr уничтожится, больше не останется указателей на
динамически выделенную память. Это означает, что программа «потеряет» адрес динамически выделенной памяти. И в
результате эту динамически выделенную целочисленную переменную нельзя будет удалить.

Это называется утечкой памяти. Утечка памяти происходит, когда ваша программа теряет адрес некоторой динамически
выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему.
Когда это происходит, то программа уже не может удалить эту динамически выделенную память, поскольку больше не знает,
где выделенная память находится. Операционная система также не может использовать эту память, поскольку считается, что
она по-прежнему используется вашей программой.

Утечки памяти «съедают» свободную память во время выполнения программы, уменьшая количество доступной памяти не
только для этой программы, но и для других программ также. Программы с серьезными проблемами с утечкой памяти могут
«съесть» всю доступную память, в результате чего ваш компьютер будет медленнее работать или даже произойдет сбой.
Только после того, как выполнение вашей программы завершится, операционная система сможет очистить и вернуть всю
память, которая «утекла».

Хотя утечка памяти может возникнуть и из-за того, что указатель выходит из области видимости, возможны и другие способы,
которые могут привести к утечкам памяти. Например, если указателю, хранящему адрес динамически выделенной памяти,
присвоить другое значение:

1 int value =7;
2 int *ptr= new int; // выделяем память
3 ptr = &value; // старый адрес утерян - произойдет утечка памяти

Это легко решается удалением указателя перед операцией переприсваивания:

1 int value =7;
2 int *ptr= new int; // выделяемпамять
3 delete ptr; // возвращаем память обратно в операционную систему
4 ptr = &value; // переприсваиваем указателю адрес value

Кроме того, утечка памяти также может произойти и через двойное выделение памяти:

1 int *ptr= new int;
2 ptr = new int; // старый адрес утерян - произойдет утечка памяти

Адрес, возвращаемый из второго выделения памяти, перезаписывает адрес из первого выделения. Следовательно, первое
динамическое выделение становится утечкой памяти!
Точно также этого можно избежать удалением указателя перед операцией переприсваивания.


Заключение

Спомощью операторов new и delete можнод инамически выделять отдельные переменные в программе. Динамически
выделенная память не имеет области видимости и остается выделенной до тех пор, пока не произойдет её освобождение или
пока программа не завершит свое выполнение. Будьте осторожны, не разыменовывайте висячие или нулевые указатели.
На следующем уроке мы рассмотрим использование операторов new и delete для выделения и удаления динамически
выделенных массивов.
