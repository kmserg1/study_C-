Урок No 137. Перегрузка операторов инкремента и декремента


Перегрузка операторов инкремента ( ++ ) и декремента ( −− ) довольно-таки проста, но с одним маленьким нюансом. Есть
две версии операторов инкремента и декремента: версия префикс (например, ++x , --y ) и версия постфикс (например,
x++ , y--).
Поскольку операторы инкремента и декремента являются унарными и изменяют свои операнды, то перегрузку следует
выполнять через методы класса.

Перегрузка операторов инкремента и декремента версии префикс

Перегрузка операторов инкремента и декремента версии префикс аналогична перегрузке любых других унарных
операторов:

1 #include <iostream>
2
3 class Number
4 {
5 private:
6 	int m_number;
7 public:
8 	Number(int number=0)
9 		: m_number(number)
10 	{
11 	}
12
13 	Number& operator++();
14 	Number& operator--();
15
16 	friend std::ostream& operator<< (std::ostream &out, const Number &n);
17 };
18
19 Number& Number::operator++()
20 {
21 	// Если значением переменной m_number является 8, то выполняем сброс значения m_number на 0
22 	if (m_number == 8)
23 		m_number = 0;
24 	// В противном случае, просто увеличиваем m_number на единицу
25 	else
26 		++m_number;
27
28 	return *this;
29 }
30
31 Number& Number::operator--()
32 {
33 	// Если значением переменной m_number является 0, то присваиваем m_number значение 8
34 	if (m_number == 0)
35 		m_number = 8;
36 	// В противном случае, просто уменьшаем m_number на единицу
37 	else
38 		--m_number;
39
40 	return *this;
41 }
42
43 std::ostream& operator<< (std::ostream &out, const Number &n)
44 {
45 	out << n.m_number;
46 	return out;
47 }
48
49 int main()
50 {
51 	Number number(7);
52
53 	std::cout << number;
54 	std::cout << ++number;
55 	std::cout << ++number;
56 	std::cout << --number;
57 	std::cout << --number;
58
59 	return 0;
60 }

Здесь класс Number содержит число от 0 до 8.
Мы перегрузили операторы инкремента/декремента таким образом,чтобы они увеличивали/уменьшали m_number в 
соответствии с заданным диапазоном (если выполняется инкремент и m_number равно 8, то сбрасываем значение 
m_number на 0; если выполняется декременти m_number равно 0 , то присваиваем значение 8 переменной m_number).

Результат выполнения программы:
78087

Обратите внимание, мы возвращаем скрытый указатель *this в функциях перегрузки операторов (т.е. текущий объект
класса Number). 
Таким образом мы можем связать выполнение нескольких операторов в одну «цепочку».


Перегрузка операторов инкремента и декремента версии постфикс

Обычно перегрузка функций осуществляется, если они имеют одно и то же имя, но разное количество и типы параметров
(детально о перегрузке функций читайте в материалах урока No 102). 
Рассмотрим случай с операторами инкремента/декремента версий префикс/постфикс.
Оба имеют одно и то же имя (например, operator++ ), унарные и принимают один параметр одного итого же типа данных. 
Как же тогда их различить при перегрузке?
Дело в том, что язык C++ использует фиктивную переменную (или «фиктивный параметр») для операторов версии
постфикс. Этот фиктивный целочисленный параметр используется только с одной целью: отличить версию постфикс
операторов инкремента/декремента от версии префикс. Выполним перегрузку операторов инкремента/декремента
версии префикс и постфикс в одном классе:

1 #include <iostream>
2
3 class Number
4 {
5 private:
6 	int m_number;
7 public:
8 	Number(int number=0)
9 		: m_number(number)
10 	{
11 	}
12
13 	Number& operator++(); // версия префикс
14 	Number& operator--(); // версия префикс
15
16 	Number operator++(int); // версия постфикс
17 	Number operator--(int); // версия постфикс
18
19 	friend std::ostream& operator<< (std::ostream &out, const Number &n);
20 };
21
22 Number& Number::operator++()
23 {
24 	// Если значением переменной m_number является 8, то выполняем сброс значения m_number на 0
25 	if (m_number == 8)
26 		m_number = 0;
27 	// В противном случае, просто увеличиваем m_number на единицу
28 	else
29 		++m_number;
30
31 	return *this;
32 }
33
34 Number& Number::operator--()
35 {
36 	// Если значением переменной m_number является 0, то присваиваем m_number значение 8
37 	if (m_number == 0)
38 		m_number = 8;
39 	// В противном случае, просто уменьшаем m_number на единицу
40 	else
41 		--m_number;
42
43 	return *this;
44 }
45
46 Number Number::operator++(int)
47 {
48 	// Создаем временный объект класса Number с текущим значением переменной m_number
49 	Number temp(m_number);
50
51 	// Используем оператор инкремента версии префикс для реализации перегрузки оператора инкремента версии постфикс
52 	++(*this); // реализация перегрузки
53
54 	// Возвращаем временный объект
55 	return temp;
56 }
57
58 Number Number::operator--(int)
59 {
60 	// Создаем временный объект класса Number с текущим значением переменной m_number
61 	Number temp(m_number);
62
63 	// Используем оператор декремента версии префикс для реализации перегрузки оператора декремента версии постфикс
64 	--(*this); // реализация перегрузки
65
66 	// Возвращаем временный объект
67 	return temp;
68 }
69
70 std::ostream& operator<< (std::ostream &out, const Number &n)
71 {
72 	out << n.m_number;
73 	return out;
74 }
75
76 int main()
77 {
78 	Number number(6);
79
80 	std::cout << number;
81 	std::cout << ++number; // вызывается Number::operator++();
82 	std::cout << number++; // вызывается Number::operator++(int);
83 	std::cout << number;
84 	std::cout << --number; // вызывается Number::operator--();
85 	std::cout << number--; // вызывается Number::operator--(int);
86 	std::cout << number;
87
88 	return 0;
89 }

Результат выполнения программы:
6778776

Здесь есть несколько интересных моментов:

 Во-первых, мы отделили версию постфикс отверсии префикс использованием целочисленного фиктивного
параметра в версии постфикс.

 Во-вторых, поскольку фиктивный параметр не используется в реализации самой перегрузки, то мы даже не
предоставляем ему имя. Таким образом, компилятор будет рассматривать эту переменную, как простую заглушку
(заполнитель места), и даже не будет предупреждать нас о том, что мы объявили переменную, но никогда её не
использовали.

 В-третьих, операторы версий префикс и постфикс выполняют одно и тоже задание: оба увеличивают/уменьшают
значение переменной объекта. Разница между ними только в значении, которое они возвращают.

Рассмотрим последний пункт детально. 
Операторы версии префикс возвращают объект после того, как он был увеличен или уменьшен. 
В версии постфикс нам нужно возвращать объект до того, как он будет увеличен или уменьшен. И тут
конфуз! Если мы увеличиваем или уменьшаем объект, то мы не можем возвратить его до выполнения инкремента/
декремента, так как операция увеличения/уменьшения уже произошла. С другой стороны, если мы возвращаем объект до
выполнения инкремента/декремента, то сама операция увеличения/уменьшения объекта не выполнится.

Решением является использование временного объекта с текущим значением переменной-члена. Тогда можно
будет увеличить/уменьшить исходный объект, а временный объект возвратить обратно в caller. Таким образом, caller
получит копию объекта до того, как фактический объект будет увеличен или уменьшен, и сама операция инкремента/
декремента выполнится успешно.

Обратите внимание, это означает, что возврат значения по ссылке невозможен, так как мы не можем возвратить ссылку
на локальную переменную (объект), которая будет уничтожена после завершения выполнения тела функции. Также это
означает, что операторы версии постфикс обычно менее эффективны, чем операторы версии префикс, из-за
дополнительных расходов ресурсов на создание временного объекта и выполнения возврата по значению вместо возврата
по ссылке.
Наконец, мы реализовали перегрузку операторов версии постфикс через уже перегруженные операторы версии префикс.
Таким образом, мы сократили дублированный код и упростили внесение изменений в наш класс в будущем (т.е. упростили
поддержку кода).
