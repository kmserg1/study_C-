Урок No164. Модификаторы override и final

Для решения определенных проблем в наследовании в C++11 добавили два специальных модификатора: override и final.
Обратите внимание, эти модификаторы неявляются ключевыми словами — это обычные модификаторы, которые имеют
особое значение в определенных местах использования.
Хотя final используется не часто, override же является фантастическим дополнением, которое вы должны использовать
регулярно. На этом уроке мы рассмотрим оба этих модификатора, а также одно исключение из правил, когда тип возврата
переопределения может не совпадать с типом возврата виртуальной функции родительского класса.

Оглавление:
1. Модификатор override
2. Модификатор final
3. Ковариантный тип возврата


Модификатор override

Как мы уже знаем из предыдущего урока, виртуальная функция дочернего класса является переопределением, только если
совпадают её сигнатура и тип возврата с сигнатурой и типом возврата виртуальной функции родительского класса. А это, в
свою очередь,может привести к проблемам, когда функция, которая должна быть переопределением, на самомделе, им не
является.

Рассмотрим следующий пример

1 #include <iostream>
2
3 class A
4 {
5 public:
6 	virtual const char* getName1(int x) { return "A"; }
7 	virtual const char* getName2(int x) { return "A"; }
8 };
9
10 class B : public A
11 {
12 public:
13 	virtual const char* getName1(short int x) { return "B"; } // тип параметра short int
14 	virtual const char* getName2(int x) const { return "B"; } // метод является const
15 };
16
17 int main()
18 {
19 	B b;
20 	A &rParent = b;
21 	std::cout << rParent.getName1(1) << '\n';
22 	std::cout << rParent.getName2(2) << '\n';
23
24 	return 0;
25 }

Поскольку rParent — это ссылка класса A на объект b , то с помощью виртуальных функций мы намереваемся получить
доступ к B::getName1() и к B::getName2(). Однако, поскольку в B::getName1() другой тип параметра (short int вместо int), то он не
является переопределением метода A::getName1(). Более того, поскольку B::getName2() является const, а A::getName2() — нет, то
B::getName2() также не считается переопределением A::getName2().
Следовательно, результат выполнения программы:
A
A
Конкретно в этом случае, поскольку A и B просто выводят свои имена, довольно легко увидеть, что что-то пошло не так, и
переопределения не вызываются. Однако в более сложной программе, когда методы могут ине возвращать значения, которые
выводятся на экран, найти ошибку уже будет довольно проблематично.
Для решения такого типа проблем и добавили модификатор override в C++11. Модификатор override может использоваться с
любым методом, который должен быть переопределением. Достаточно просто указать override в том месте, где обычно
указывается const (после скобок с параметрами). Если метод не переопределяет виртуальную функцию родительского класса,
токомпилятор выдаст ошибку:

1 #include <iostream>
2
3 class A
4 {
5 public:
6 	virtual const char* getName1(int x) { return "A"; }
7 	virtual const char* getName2(int x) { return "A"; }
8 	virtual const char* getName3(int x) { return "A"; }
9 };
10
11 class B : public A
12 {
13 public:
14 	virtual const char* getName1(short int x) override { return "B"; } // ошибка компиляции, метод не является переопределение
15 	virtual const char* getName2(int x) const override { return "B"; } // ошибка компиляции, метод не является переопределение
16 	virtual const char* getName3(int x) override { return "B"; } // всё хорошо, метод является переопределением A::getName3(in
17
18 };
19
20 int main()
21 {
22 	return 0;
23 }

Здесь мы получим две ошибки: первая для B::getName1() и вторая для B::getName2(), так как ни один из этих методов не
является переопределением виртуальных функций класса А. Метод B::getName3() является переопределением, поэтому с ним
никаких проблем нет.

Использование модификатора override никак не влияет на эффективность или производительность программы, но помогает
избежать непреднамеренных ошибок. Следовательно, настоятельно рекомендуется использовать модификатор override для
каждого из своих переопределений.

Правило: Используйте модификатор override для каждого из своих переопределений.


Модификатор final

Могут быть случаи, когда вы не хотите, чтобы кто-то мог переопределить виртуальную функцию или наследовать
определенный класс. Модификатор final используется именно для этого. Если пользователь пытается переопределить метод
или наследовать класс с модификатором final, то компилято рвыдаст ошибку.
Указывается final в том же месте, в котороми модификатор override, например:

1 class A
2 {
3 public:
4 	virtual const char* getName() { return "A"; }
5 };
6
7 class B : public A
8 {
9 public:
10 	// Заметили final в конце? Это означает, что метод переопределить уже нельзя
11 	virtual const char* getName() override final { return "B"; } // всё хорошо, переопределение A::getName()
12 };
13
14 class C : public B
15 {
16 public:
17 	virtual const char* getName() override { return "C"; } // ошибка компиляции: переопределение метода B::getName(), который я
18 };

Вэтом коде метод B::getName() переопределяет метод A::getName(). Но B::getName() имеет модификатор final, это означает, что
любые дальнейшие переопределения этого метода будут вызывать ошибку компиляции. И действительно, C::getName() уже не
может переопределить B::getName() — компилятор выдаст ошибку.
В случае, если мы хотим запретить наследование определенного класса, то модификатор final указывается после имени класса:

1 class A
2 {
3 public:
4 	virtual const char* getName() { return "A"; }
5 };
6
7 class B final : public A // обратите внимание на модификатор final здесь
8  {
9  public:
10 	virtual const char* getName() override { return "B"; }
11 };
12
13 class C : public B // ошибка компиляции: нельзя наследовать final-класс
14 {
15 public:
16 	virtual const char* getName() override { return "C"; }
17 };

В этом примере класс B объявлен как final. Таким образом, класс C не может наследовать класс B — компилятор выдаст ошибку.


Ковариантный тип возврата

Есть один случай, когда тип возврата переопределения может не совпадать с типом возврата виртуальной функции
родительского класса, но при этом оставаться переопределением. Если типом возврата виртуальной функции является
указатель или ссылка на класс, то переопределения могут возвращать указатель или ссылку на свой собственный класс (т.е.
вместо родительского класса указывать на дочерний класс). Это называется ковариантным типом возврата. Например:

1 #include <iostream>
2
3 class Parent
4 {
5 public:
6 	// Этот метод getThis() возвращает указатель на класс Parent
7 	virtual Parent* getThis() { std::cout << "called Parent::getThis()\n"; return this; }
8 	void printType() { std::cout << "returned a Parent\n"; }
9 };
10
11 class Child : public Parent
12 {
13 public:
14 	// Обычно, типы возврата переопределений и виртуальных функций родительского класса должны совпадать.
15 	// Однако, поскольку Child наследует класс Parent, следующий метод может возвращать Child* вместо Parent*
16 	virtual Child* getThis() { std::cout << "called Child::getThis()\n"; return this; }
17 	void printType() { std::cout << "returned a Child\n"; }
18 };
19
20 int main()
21 {
22 	Child ch;
23 	Parent *p = &ch;
24 	ch.getThis()->printType(); // вызывается Child::getThis(), возвращается Child*, вызывается Child::printType()
25 	p->getThis()->printType(); // вызывается Child::getThis(), возвращается Parent*, вызывается Parent::printType()
26 }

Результатвыполнения программы:
called Child::getThis()
returned a Child
called Child::getThis()
returned a Parent

Некоторые старые компиляторы могут не поддерживать ковариантные типы возврата.

В примере, приведенном выше, мы сначала вызываем ch.getThis(). Поскольку ch является объектом класса Child, то
вызывается Child::getThis(), который возвращает Child*. Этот Child* затем используется для вызова невиртуальной функции
Child::printType().

Затем выполняется p->getThis(). Переменная p является указателем класса Parent на объект ch класса Child.
Parent::getThis() — это виртуальная функция, поэтому вызывается переопределение Child::getThis(). Хотя Child::getThis() и
возвращает Child*, но, поскольку родительская часть объекта возвращает Parent*, возвращаемый Child* преобразовывается в
Parent*. И,таким образом, вызывается Parent::printType().

Другими словами, в вышеприведенном примере мы получим Child* только в том случае, если будем вызывать getThis() с
объектом класса Child.
